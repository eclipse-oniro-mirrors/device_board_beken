diff --git a/kernel/liteos_m/BUILD.gn b/kernel/liteos_m/BUILD.gn
index 35e88fc..b8304d4 100644
--- a/kernel/liteos_m/BUILD.gn
+++ b/kernel/liteos_m/BUILD.gn
@@ -38,9 +38,9 @@ declare_args() {
 
 group("kernel") {
   deps = [
-    "components/bounds_checking_function:sec",
     "kernel:kernel",
     "utils:utils",
+    "//third_party/bounds_checking_function:libsec_static",
   ]
   if (enable_ohos_kernel_liteos_m_cppsupport == true) {
     deps += [ "components/cppsupport:cppsupport" ]
diff --git a/kernel/liteos_m/LICENSE b/kernel/liteos_m/LICENSE
index 208b4cd..b6ffd6e 100644
--- a/kernel/liteos_m/LICENSE
+++ b/kernel/liteos_m/LICENSE
@@ -1,28 +1,28 @@
-Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
-Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-1. Redistributions of source code must retain the above copyright notice, this list of
-   conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright notice, this list
-   of conditions and the following disclaimer in the documentation and/or other materials
-   provided with the distribution.
-
-3. Neither the name of the copyright holder nor the names of its contributors may be used
-   to endorse or promote products derived from this software without specific prior written
-   permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice, this list of
+   conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice, this list
+   of conditions and the following disclaimer in the documentation and/or other materials
+   provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its contributors may be used
+   to endorse or promote products derived from this software without specific prior written
+   permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/kernel/liteos_m/NOTICE b/kernel/liteos_m/NOTICE
index 54e5659..cecba07 100644
--- a/kernel/liteos_m/NOTICE
+++ b/kernel/liteos_m/NOTICE
@@ -1,8 +1,8 @@
-1、In kernel/liteos_m/targets/cortex-m4_stm32f429ig_fire-challenger_iar directory, the files including main.c,
-target_config.h, dprintf.c, board/iar_stm32f429ig_fire-challenger.c and board/iar_stm32f429ig_fire-challenger.h,
-are under the terms of the licence: kernel/liteos_m/LICENSE file,
-and other files are under the terms of the licence: kernel/liteos_m/targets/cortex-m4_stm32f429ig_fire-challenger_iar/LICENSE.pdf file.
-
-2、In kernel/liteos_m/targets/cortex-m7_nucleo_f767zi_gcc directory, the files including target_config.h,
-Core/Inc/task_sample.h and Core/Src/task_sample.c, are under the terms of the licence: kernel/liteos_m/LICENSE file,
-and other files are under the terms of the licence: kernel/liteos_m/targets/cortex-m7_nucleo_f767zi_gcc/LICENSE.pdf file.
+1、In kernel/liteos_m/targets/cortex-m4_stm32f429ig_fire-challenger_iar directory, the files including main.c,
+target_config.h, dprintf.c, board/iar_stm32f429ig_fire-challenger.c and board/iar_stm32f429ig_fire-challenger.h,
+are under the terms of the licence: kernel/liteos_m/LICENSE file,
+and other files are under the terms of the licence: kernel/liteos_m/targets/cortex-m4_stm32f429ig_fire-challenger_iar/LICENSE.pdf file.
+
+2、In kernel/liteos_m/targets/cortex-m7_nucleo_f767zi_gcc directory, the files including target_config.h,
+Core/Inc/task_sample.h and Core/Src/task_sample.c, are under the terms of the licence: kernel/liteos_m/LICENSE file,
+and other files are under the terms of the licence: kernel/liteos_m/targets/cortex-m7_nucleo_f767zi_gcc/LICENSE.pdf file.
diff --git a/kernel/liteos_m/README_zh.md b/kernel/liteos_m/README_zh.md
index dabe1e6..9e9e848 100644
--- a/kernel/liteos_m/README_zh.md
+++ b/kernel/liteos_m/README_zh.md
@@ -41,26 +41,74 @@ OpenHarmony LiteOS-M内核是面向IoT领域构建的轻量级物联网操作系
 
 ## 使用说明<a name="section3732185231214"></a>
 
-LiteOS-M内核提供了三种芯片架构的工程位于targets目录。三种架构的工程编译及使用方式如下：
+OpenHarmony LiteOS-M内核的编译构建系统是一个基于gn和ninja的组件化构建系统，支持按组件配置、裁剪和拼装，按需构建出定制化的产品。编译构建系统的详细信息可以参考[官方开源站点编译系统介绍](https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/porting/%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D.md)。本文主要介绍如何基于gn和ninja编译LiteOS-M工程，GCC+Makefile、IAR、Keil MDK等编译方式可以参考社区爱好者贡献的站点。
 
--   cortex-m3：
+### 搭建系统基础环境
 
-kernel/liteos\_m/targets/cortex-m3\_stm32f103\_simulator\_keil目录是基于STM32F103芯片架构构建的keil工程目录，keil开发工具可通过网络下载并安装。进入cortex-m3\_stm32f103\_simulator\_keil/project目录，双击los\_demo.uvproj文件即可打开相应工程，编译成功后即可通过JLINK或者STM32 ST-LINK Utility烧录至对应单板。
+在搭建各个开发板环境前，需要完成OpenHarmony系统基础环境搭建。系统基础环境主要是指OpenHarmony的编译环境和开发环境，详细介绍请参考官方站点[搭建系统基础环境](https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/quick-start/%E6%90%AD%E5%BB%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83.md)。开发者需要根据环境搭建文档，完成下述软件的安装：Python3.7+、gn、ninja、hb。对于LiteOS-M内核，还需要安装Make构建工具和[ARM GCC编译工具链](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads)。
 
--   cortex-m4：
+### 获取OpenHarmony源码
 
-kernel/liteos\_m/targets/cortex-m4\_stm32f429ig\_fire-challenger\_iar目录是基于STM32F429IG芯片架构构建的IAR工程目录，IAR开发工具可通过网络下载并安装。进入cortex-m4\_stm32f429ig\_fire-challenger\_iar/project目录，双击los\_demo.eww文件即可打开相应工程，编译成功后即可通过JLINK或者STM32 ST-LINK Utility烧录至对应单板。
+开发者需要在Linux服务器上通过Git克隆获取OpenHarmony最新源码，详细的源码获取方式，请见[源码获取](https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/get-code/%E6%BA%90%E7%A0%81%E8%8E%B7%E5%8F%96.md)。获取OpenHarmony完整仓代码后，假设克隆目录为`~/openHarmony`。
 
--   cortex-m7：
+### 获取示例工程源码
+
+以开发板Nucleo-F767Zi为例，演示如何编译运行`OpenHarmony LiteOS-M`内核工程。在本地目录，执行下述命令克隆示例代码。
+
+```
+git clone https://gitee.com/harylee/nucleo_f767zi.git
+```
+
+假设克隆到的代码目录为`~/nucleo_f767zi`。 执行如下命令把代码目录的`device`、`vendor`目录复制到`openHarmony`工程的相应目录。
 
-kernel/liteos\_m/targets/cortex-m7\_nucleo\_f767zi\_gcc目录是基于STM32F767ZI芯片架构构建的Makefile工程目录。编译方式如下：
+```
+cp -r ~/nucleo_f767zi/device/st/nucleo_f767zi ~/openHarmony/device/st/nucleo_f767zi
+
+chmod +x ~/openHarmony/device/st/nucleo_f767zi/build.sh
+
+cp -r ~/nucleo_f767zi/vendor/st ~/openHarmony/vendor/st
+```
+
+关于示例代码目录的说明，可以参考资料站点[板级目录规范](https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/porting/%E7%A7%BB%E6%A4%8D%E6%A6%82%E8%BF%B0-0.md#section6204129143013)。如果需要自行移植开发板，请参考[板级系统移植](https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/porting/%E6%9D%BF%E7%BA%A7%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D.md)。
+
+### 编译运行
+
+编译运行前，交叉编译工具链`bin`目录配置到`PATH`环境变量中或者配置`device/st/nucleo_f767zi/liteos_m/config.gni`文件中`board_toolchain_path`配置项为交叉编译工具链`bin`目录。
+在`OpenHarmony`根目录，执行`hb set`设置产品路径，选择`nucleo_f767zi`产品，然后执行`hb build`开启编译。如下：
 
 ```
-cd kernel/liteos_m/targets/cortex-m7_nucleo_f767zi_gcc
-make clean; make
+user@dev:~/OpenHarmony$ hb set
+
+[OHOS INFO] Input code path: # 直接按回车，然后选择nucleo_f767zi产品即可
+
+OHOS Which product do you need? nucleo_f767zi@st
+
+user@dev:~/OpenHarmony$ hb build
 ```
 
-编译成功后在cortex-m7\_nucleo\_f767zi\_gcc/build目录下生成NUCLEO-F767.hex可执行文件，通过烧录工具STM32 ST-LINK Utility烧录到对应的单板。
+最终的镜像生成在`~/openHarmony/out/nucleo_f767zi/`目录中，通过`STM32 ST-LINK Utility`软件将镜像文件下载至单板查看运行效果。
+
+### 社区移植工程链接
+
+LiteOS-M内核移植的具体开发板的工程由社区开发者提供，可以访问社区开发者代码仓获取。如果您移植支持了更多开发板，可以提供链接给我们进行社区分享。
+
+-   cortex-m3：
+
+    - STM32F103   https://gitee.com/rtos_lover/stm32f103_simulator_keil
+
+        该仓包含OpenHarmony LiteOS-M内核基于STM32F103芯片架构构建的Keil工程，支持Keil MDK方式进行编译。
+
+-   cortex-m4：
+
+    - 野火挑战者STM32F429IGTb   https://gitee.com/harylee/stm32f429ig_firechallenger
+
+        该仓包含OpenHarmony LiteOS-M内核移植支持`野火挑战者STM32F429IGTb`开发板的工程代码，支持Ninja、GCC、IAR等方式进行编译。
+
+-   cortex-m7：
+
+    - Nucleo-F767ZI   https://gitee.com/harylee/nucleo_f767zi
+
+        该仓包含OpenHarmony LiteOS-M内核移植支持`Nucleo-F767ZI`开发板的工程代码，支持Ninja、GCC、IAR等方式进行编译。
 
 ## 修改日志
 
diff --git a/kernel/liteos_m/arch_spec.md b/kernel/liteos_m/arch_spec.md
index 0b3650f..2ce739e 100644
--- a/kernel/liteos_m/arch_spec.md
+++ b/kernel/liteos_m/arch_spec.md
@@ -1,36 +1,36 @@
 ```
 .
-├── components                                                  --- 可选组件，可裁剪，依赖kernel
-│   ├── cppsupport                                              --- C++支持
-│   └── cpup                                                    --- CPUP功能
-├── kal                                                         --- 内核抽象层
-│   ├── cmsis                                                   --- cmsis标准支持
-│   └── posix                                                   --- posix标准支持
-├── kernel                                                      --- 内核最小功能集支持
-│   ├── arch                                                    --- 硬件架构相关
-│   │   ├── arm                                                 --- arm32架构
-│   │   │   └── cortex-m4                                       --- cortex-m4架构
-│   │   │       └── iar                                         ---
+├── components                                                  --- Optional components
+│   ├── cppsupport                                              --- C++
+│   └── cpup                                                    --- CPUP
+├── kal                                                         --- Kernel Abstraction Layer
+│   ├── cmsis                                                   --- cmsis
+│   └── posix                                                   --- posix
+├── kernel                                                      --- Minimalistic kernel funtionalities
+│   ├── arch                                                    --- Support for hardware architectures
+│   │   ├── arm                                                 --- arm32
+│   │   │   └── cortex-m4                                       --- cortex-m4
+│   │   │       └── iar                                         
 │   │   │           ├── los_atomic.h
 │   │   │           ├── los_context.h
 │   │   │           ├── los_interrupt.h
 │   │   │           └── los_mpu.h
 │   │   └── include
-│   │       ├── los_arch_atomic.h                               --- 定义通用arch的原子操作
-│   │       ├── los_arch_context.h                              --- 定义通用arch的上下文切换
-│   │       ├── los_arch.h                                      --- 定义通用arch初始化
-│   │       └── los_arch_interrupt.h                            --- 定义通用arch中断
+│   │       ├── los_arch_atomic.h                               --- Atomic operations
+│   │       ├── los_arch_context.h                              --- Context switch
+│   │       ├── los_arch.h                                      --- Initialization
+│   │       └── los_arch_interrupt.h                            --- Interrupts
 │   ├── include
-│   │   ├── los_config.h                                        --- 功能开关和配置参数
-│   │   ├── los_event.h                                         --- 事件
-│   │   ├── los_liteos.h                                        --- liteos最小功能集对外提供的头文件
-│   │   ├── los_memory.h                                        --- 堆内存管理
-│   │   ├── los_mutex.h                                         --- 互斥锁
-│   │   ├── los_queue.h                                         --- 队列
-│   │   ├── los_scheduler.h                                     --- 调度算法
-│   │   ├── los_sem.h                                           --- 信号量
-│   │   ├── los_task.h                                          --- 任务
-│   │   └── los_timer.h                                         --- 定时器
+│   │   ├── los_config.h                                        --- Configuration parameters
+│   │   ├── los_event.h                                         --- Events management
+│   │   ├── los_liteos.h                                        --- Kernel types and functions
+│   │   ├── los_memory.h                                        --- Heap memory management
+│   │   ├── los_mutex.h                                         --- Mutex
+│   │   ├── los_queue.h                                         --- Queue
+│   │   ├── los_scheduler.h                                     --- Scheduler
+│   │   ├── los_sem.h                                           --- Semaphores
+│   │   ├── los_task.h                                          --- Tasks
+│   │   └── los_timer.h                                         --- Timer
 │   └── src
 ├── targets
 │   └── targets
@@ -40,13 +40,13 @@
 │           ├── Libraries
 │           ├── main.c
 │           ├── project
-│           ├── target_config.h                                 --- 板级配置功能开关和配置参数
+│           ├── target_config.h                                 --- Hardware target configuration
 │           └── Utilities
 └── utils
     ├── include
-    │   ├── los_compiler.h                                      --- 编译工具配置，类型定义
-    │   ├── los_debug.h                                         --- debug，printf相关
-    │   ├── los_error.h                                         --- 错误定义
+    │   ├── los_compiler.h                                      --- Compiler configuration
+    │   ├── los_debug.h                                         --- Debugging facilities
+    │   ├── los_error.h                                         --- Errors codes and definitions
     │   └── los_list.h
     └── src
 ```
diff --git a/kernel/liteos_m/components/backtrace/BUILD.gn b/kernel/liteos_m/components/backtrace/BUILD.gn
index c6839ea..9d1dc2b 100644
--- a/kernel/liteos_m/components/backtrace/BUILD.gn
+++ b/kernel/liteos_m/components/backtrace/BUILD.gn
@@ -34,7 +34,6 @@ static_library("backtrace") {
     "../../kernel/include",
     "../../kernel/arch/include",
     "../../utils",
-    "./",
     "//third_party/bounds_checking_function/include",
   ]
 }
diff --git a/kernel/liteos_m/components/backtrace/los_backtrace.c b/kernel/liteos_m/components/backtrace/los_backtrace.c
index dc0c42f..2eb1f1a 100644
--- a/kernel/liteos_m/components/backtrace/los_backtrace.c
+++ b/kernel/liteos_m/components/backtrace/los_backtrace.c
@@ -28,17 +28,10 @@
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
 #include "los_backtrace.h"
 #include "los_task.h"
 #include "los_debug.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
-
 #if (LOSCFG_BACKTRACE_TYPE != 0)
 #if (LOSCFG_BACKTRACE_TYPE == 1)
 #define OS_BACKTRACE_START     2
@@ -125,7 +118,7 @@ STATIC INLINE UINT32 OsStackAddrGet(UINTPTR *stackStart, UINTPTR *stackEnd, UINT
             *stackEnd = (UINTPTR)taskCB->topOfStack + taskCB->stackSize;
             if ((SP < (UINTPTR)taskCB->topOfStack) || (SP >= *stackEnd)) {
                 PRINT_ERR("msp statck [0x%x, 0x%x], cur task stack [0x%x, 0x%x], cur sp(0x%x) is overflow!\n",
-                           CODE_START_ADDR, CSTACK_END_ADDR, (UINTPTR)taskCB->topOfStack, *stackEnd, SP);
+                          CODE_START_ADDR, CSTACK_END_ADDR, (UINTPTR)taskCB->topOfStack, *stackEnd, SP);
                 return LOS_NOK;
             }
         }
@@ -135,7 +128,7 @@ STATIC INLINE UINT32 OsStackAddrGet(UINTPTR *stackStart, UINTPTR *stackEnd, UINT
             *stackEnd = CSTACK_END_ADDR;
             if ((*stackStart < CODE_START_ADDR) || (*stackStart >= CSTACK_END_ADDR)) {
                 PRINT_ERR("msp stack [0x%x, 0x%x], cur sp(0x%x) is overflow!\n",
-                           CODE_START_ADDR, CSTACK_END_ADDR, *stackStart);
+                          CODE_START_ADDR, CSTACK_END_ADDR, *stackStart);
                 return LOS_NOK;
             }
             PRINTK("msp, start = %x, end = %x\n", *stackStart, *stackEnd);
@@ -146,7 +139,7 @@ STATIC INLINE UINT32 OsStackAddrGet(UINTPTR *stackStart, UINTPTR *stackEnd, UINT
             *stackEnd = (UINTPTR)taskCB->topOfStack + taskCB->stackSize;
             if ((*stackStart < (UINTPTR)taskCB->topOfStack) || (*stackStart >= *stackEnd)) {
                 PRINT_ERR("psp stack [0x%x, 0x%x], cur sp(0x%x) is overflow, cur task id is %d!\n",
-                           taskCB->topOfStack, *stackEnd, *stackStart, taskID);
+                          taskCB->topOfStack, *stackEnd, *stackStart, taskID);
                 return LOS_NOK;
             }
             PRINTK("psp, start = %x, end = %x\n", *stackStart, *stackEnd);
@@ -232,7 +225,7 @@ STATIC INLINE BOOL OsBackTraceFpCheck(UINT32 value);
 #define OS_FP_CHECK(value)     (((UINT32)(value) != FP_INIT_VALUE) && OS_FP_ALIGN(value))
 
 STATIC INLINE UINTPTR OsFpGet(VOID)
-{
+{
     UINTPTR fp = 0;
     __asm volatile("mv %0, s0" : "=r"(fp));
     dsb();
@@ -243,8 +236,8 @@ VOID LOS_RecordLR(UINTPTR *LR, UINT32 LRSize, UINT32 jumpCount, UINTPTR SP)
 {
     UNUSED(SP);
     UINT32 backFp = OsFpGet();
-    UINT32 tmpFp;
-    UINT32 backRa;
+    UINT32 tmpFp;
+    UINT32 backRa;
     UINT32 count = 0;
     UINT32 index = 0;
 
@@ -253,7 +246,7 @@ VOID LOS_RecordLR(UINTPTR *LR, UINT32 LRSize, UINT32 jumpCount, UINTPTR SP)
     }
 
     while (OS_FP_CHECK(backFp)) {
-        tmpFp = backFp;
+        tmpFp = backFp;
         backRa = *((UINT32 *)(UINTPTR)(tmpFp - OS_RA_OFFSET));
         backFp = *((UINT32 *)(UINTPTR)(tmpFp - OS_FP_OFFSET));
         if (index++ < jumpCount) {
@@ -264,8 +257,119 @@ VOID LOS_RecordLR(UINTPTR *LR, UINT32 LRSize, UINT32 jumpCount, UINTPTR SP)
         count++;
         if ((count == LRSize) || (backFp == tmpFp) ||
             (!OsStackDataIsCodeAddr(backRa))) {
-            break;
-        }
+            break;
+        }
+    }
+
+    if (count < LRSize) {
+        LR[count] = 0;
+    }
+}
+#elif (LOSCFG_BACKTRACE_TYPE == 3)
+STATIC INLINE UINTPTR OsAddrIsValid(UINTPTR sp)
+{
+    UINTPTR pc;
+    BOOL ret;
+
+    /* The stack space pointed to by the current SP may store the LR,
+       so need decrease a word to PC. */
+    pc = *((UINTPTR *)sp) - sizeof(UINTPTR);
+
+    if (!OS_IS_THUMB_INSTRUCTION(pc)) {
+        return 0;
+    }
+
+    /* PC in thumb mode is an odd number, fix the PC address by decreasing one byte. */
+    pc = *((UINTPTR *)sp) - 1;
+
+    ret = OsStackDataIsCodeAddr(pc);
+    if (ret == FALSE) {
+        return 0;
+    }
+
+    ret = OsInsIsBlOrBlx(pc - sizeof(UINTPTR));
+    if (ret == FALSE) {
+        return 0;
+    }
+
+    return pc;
+}
+
+STATIC INLINE UINT32 OsStackAddrGet(UINTPTR *stackStart, UINTPTR *stackEnd, UINTPTR SP)
+{
+    if (SP != 0) {
+        *stackStart = SP;
+        if ((SP >= CODE_START_ADDR) && (SP < CSTACK_END_ADDR)) {
+            *stackEnd = CSTACK_END_ADDR;
+        } else {
+            UINT32 taskID = LOS_CurTaskIDGet();
+            LosTaskCB *taskCB = OS_TCB_FROM_TID(taskID);
+            *stackEnd = (UINTPTR)taskCB->topOfStack + taskCB->stackSize;
+            if ((SP < (UINTPTR)taskCB->topOfStack) || (SP >= *stackEnd)) {
+                PRINT_ERR("msp statck [0x%x, 0x%x], cur task stack [0x%x, 0x%x], cur sp(0x%x) is overflow!\n",
+                          CODE_START_ADDR, CSTACK_END_ADDR, (UINTPTR)taskCB->topOfStack, *stackEnd, SP);
+                return LOS_NOK;
+            }
+        }
+    } else {
+        if (HalSpGet() != HalPspGet()) {
+            *stackStart = HalMspGet();
+            *stackEnd = CSTACK_END_ADDR;
+            if ((*stackStart < CODE_START_ADDR) || (*stackStart >= CSTACK_END_ADDR)) {
+                PRINT_ERR("msp stack [0x%x, 0x%x], cur sp(0x%x) is overflow!\n",
+                          CODE_START_ADDR, CSTACK_END_ADDR, *stackStart);
+                return LOS_NOK;
+            }
+            PRINTK("msp, start = %x, end = %x\n", *stackStart, *stackEnd);
+        } else {
+            *stackStart = HalPspGet();
+            UINT32 taskID = LOS_CurTaskIDGet();
+            LosTaskCB *taskCB = OS_TCB_FROM_TID(taskID);
+            *stackEnd = (UINTPTR)taskCB->topOfStack + taskCB->stackSize;
+            if ((*stackStart < (UINTPTR)taskCB->topOfStack) || (*stackStart >= *stackEnd)) {
+                PRINT_ERR("psp stack [0x%x, 0x%x], cur sp(0x%x) is overflow, cur task id is %d!\n",
+                          taskCB->topOfStack, *stackEnd, *stackStart, taskID);
+                return LOS_NOK;
+            }
+            PRINTK("psp, start = %x, end = %x\n", *stackStart, *stackEnd);
+        }
+    }
+
+    return LOS_OK;
+}
+
+VOID LOS_RecordLR(UINTPTR *LR, UINT32 LRSize, UINT32 jumpCount, UINTPTR SP)
+{
+    if (LR == NULL) {
+        return;
+    }
+
+    UINTPTR stackStart;
+    UINTPTR stackEnd;
+    UINT32 count = 0;
+    UINT32 index = 0;
+    UINTPTR sp;
+    UINTPTR pc;
+    UINT32 ret;
+
+    ret = OsStackAddrGet(&stackStart, &stackEnd, SP);
+    if (ret != LOS_OK) {
+        return;
+    }
+
+    /* Traverse the stack space and find the LR address. */
+    for (sp = stackStart; sp < stackEnd; sp += sizeof(UINTPTR)) {
+        pc = OsAddrIsValid(sp);
+        if ((pc != 0) && (count < LRSize)) {
+            if (index++ < jumpCount) {
+                continue;
+            }
+            LR[count] = pc;
+            count++;
+            if (count == LRSize) {
+                break;
+            }
+        }
     }
 
     if (count < LRSize) {
@@ -304,9 +408,4 @@ VOID LOS_BackTraceInit(VOID)
 }
 #endif
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
diff --git a/kernel/liteos_m/components/bounds_checking_function/BUILD.gn b/kernel/liteos_m/components/bounds_checking_function/BUILD.gn
old mode 100755
new mode 100644
diff --git a/kernel/liteos_m/components/bounds_checking_function/README.OpenSource b/kernel/liteos_m/components/bounds_checking_function/README.OpenSource
index 578713d..c07b384 100644
--- a/kernel/liteos_m/components/bounds_checking_function/README.OpenSource
+++ b/kernel/liteos_m/components/bounds_checking_function/README.OpenSource
@@ -1,13 +1,13 @@
-[
-    {
-        "Name"                  : "bounds_checking_function",
-        "License"               : "Mulan Permissive Software License，Version 2",
-        "License File"          : "LICENSE",
-        "Version Number"        : "v1.1.10",
-        "Owner"                 : "jianghan2@huawei.com",
-        "PDM Number"            : "05835DMT",
-        "Upstream URL"          : "https://gitee.com/openeuler/bounds_checking_function",
-        "Use Application URL"   : "http://pdm.huawei.com/Windchill/hwdispatcher/iris/?status=view&pboid=OR:ext.huawei.huaweipbo.HuaweiPBO:70160914898&virtualid=basicinfo&lang=en",
-        "Description"           : "following the standard of C11 Annex K (bound-checking interfaces), functions of the common memory/string operation classes, such as memcpy_s, strcpy_s, are selected and implemented."
-    }
+[
+    {
+        "Name"                  : "bounds_checking_function",
+        "License"               : "Mulan Permissive Software License，Version 2",
+        "License File"          : "LICENSE",
+        "Version Number"        : "v1.1.10",
+        "Owner"                 : "jianghan2@huawei.com",
+        "PDM Number"            : "05835DMT",
+        "Upstream URL"          : "https://gitee.com/openeuler/bounds_checking_function",
+        "Use Application URL"   : "http://pdm.huawei.com/Windchill/hwdispatcher/iris/?status=view&pboid=OR:ext.huawei.huaweipbo.HuaweiPBO:70160914898&virtualid=basicinfo&lang=en",
+        "Description"           : "following the standard of C11 Annex K (bound-checking interfaces), functions of the common memory/string operation classes, such as memcpy_s, strcpy_s, are selected and implemented."
+    }
 ]
\ No newline at end of file
diff --git a/kernel/liteos_m/components/cppsupport/BUILD.gn b/kernel/liteos_m/components/cppsupport/BUILD.gn
index d74632f..2cb08a2 100644
--- a/kernel/liteos_m/components/cppsupport/BUILD.gn
+++ b/kernel/liteos_m/components/cppsupport/BUILD.gn
@@ -30,8 +30,5 @@
 static_library("cppsupport") {
   sources = [ "los_cppsupport.c" ]
 
-  include_dirs = [
-    "../../utils",
-    "./",
-  ]
+  include_dirs = [ "../../utils" ]
 }
diff --git a/kernel/liteos_m/components/cppsupport/los_cppsupport.c b/kernel/liteos_m/components/cppsupport/los_cppsupport.c
index dcdbe8b..057c3ba 100644
--- a/kernel/liteos_m/components/cppsupport/los_cppsupport.c
+++ b/kernel/liteos_m/components/cppsupport/los_cppsupport.c
@@ -31,11 +31,6 @@
 
 #include "los_cppsupport.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
 typedef VOID (*InitFunc)(VOID);
 
@@ -53,8 +48,3 @@ INT32 LOS_CppSystemInit(UINTPTR initArrayStart, UINTPTR initArrayEnd)
 }
 
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/components/cpup/BUILD.gn b/kernel/liteos_m/components/cpup/BUILD.gn
index acd1d08..bec5189 100644
--- a/kernel/liteos_m/components/cpup/BUILD.gn
+++ b/kernel/liteos_m/components/cpup/BUILD.gn
@@ -34,7 +34,6 @@ static_library("cpup") {
     "../../kernel/include",
     "../../kernel/arch/include",
     "../../utils",
-    "./",
     "//third_party/bounds_checking_function/include",
   ]
 }
diff --git a/kernel/liteos_m/components/cpup/los_cpup.c b/kernel/liteos_m/components/cpup/los_cpup.c
old mode 100755
new mode 100644
index 4456d59..5b8bbfd
--- a/kernel/liteos_m/components/cpup/los_cpup.c
+++ b/kernel/liteos_m/components/cpup/los_cpup.c
@@ -30,15 +30,9 @@
  */
 
 #include "los_cpup.h"
-#include "securec.h"
 #include "los_memory.h"
 #include "los_debug.h"
-#include "los_timer.h"
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
+#include "los_tick.h"
 
 #if (LOSCFG_BASE_CORE_CPUP == 1)
 
@@ -61,15 +55,6 @@ LITE_OS_SEC_BSS OsCpupCB  *g_cpup = NULL;
 LITE_OS_SEC_BSS UINT64    g_lastRecordTime;
 LITE_OS_SEC_BSS UINT16    g_hisPos; /* <current Sampling point of historyTime */
 
-
-LITE_OS_SEC_TEXT_MINOR STATIC INLINE UINT64 OsGetCurrentCyclesCount(VOID)
-{
-    UINT32 high = 0;
-    UINT32 low = 0;
-    HalGetCpuCycle(&high, &low);
-    return (((UINT64)high << 32) + low); // 32 means bits of word
-}
-
 /*****************************************************************************
 Function   : OsCpupInit
 Description: initialization of CPUP
@@ -110,7 +95,7 @@ LITE_OS_SEC_TEXT_MINOR VOID OsTskCycleStart(VOID)
 
     taskID = g_losTask.newTask->taskID;
     g_cpup[taskID].cpupID = taskID;
-    g_cpup[taskID].startTime = OsGetCurrentCyclesCount();
+    g_cpup[taskID].startTime = LOS_SysCycleGet();
 
     return;
 }
@@ -135,7 +120,7 @@ LITE_OS_SEC_TEXT_MINOR VOID OsTskCycleEnd(VOID)
         return;
     }
 
-    cpuCycle = OsGetCurrentCyclesCount();
+    cpuCycle = LOS_SysCycleGet();
 
     if (cpuCycle < g_cpup[taskID].startTime) {
         cpuCycle += g_cyclesPerTick;
@@ -163,7 +148,7 @@ LITE_OS_SEC_TEXT_MINOR VOID OsTskCycleEndStart(VOID)
     }
 
     taskID = g_losTask.runTask->taskID;
-    cpuCycle = OsGetCurrentCyclesCount();
+    cpuCycle = LOS_SysCycleGet();
 
     if (g_cpup[taskID].startTime != 0) {
         if (cpuCycle < g_cpup[taskID].startTime) {
@@ -229,7 +214,7 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_SysCpuUsage(VOID)
     UINT64  cpuCycleAll = 0;
     UINT32  cpupRet = 0;
     UINT16  loopNum;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
 
     if (g_cpupInitFlg == 0) {
         return LOS_ERRNO_CPUP_NO_INIT;
@@ -268,7 +253,7 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_HistorySysCpuUsage(UINT16 mode)
     UINT16  loopNum;
     UINT16  curPos;
     UINT16  prePos = 0;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
 
     if (g_cpupInitFlg == 0) {
         return LOS_ERRNO_CPUP_NO_INIT;
@@ -315,7 +300,7 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskCpuUsage(UINT32 taskID)
 {
     UINT64  cpuCycleAll = 0;
     UINT16  loopNum;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     UINT32  cpupRet = 0;
 
     if (g_cpupInitFlg == 0) {
@@ -364,7 +349,7 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_HistoryTaskCpuUsage(UINT32 taskID, UINT16 mode
     UINT64  cpuCycleCurTsk = 0;
     UINT16  loopNum, curPos;
     UINT16  prePos = 0;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     UINT32  cpupRet = 0;
 
     if (g_cpupInitFlg == 0) {
@@ -417,7 +402,7 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_AllTaskCpuUsage(CPUP_INFO_S *cpupInfo, UINT16
     UINT16  loopNum;
     UINT16  curPos;
     UINT16  prePos = 0;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     UINT64  cpuCycleAll = 0;
     UINT64  cpuCycleCurTsk = 0;
 
@@ -528,10 +513,3 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_CpupUsageMonitor(CPUP_TYPE_E type, CPUP_MODE_E
 }
 
 #endif /* LOSCFG_BASE_CORE_CPUP */
-
-
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/components/cpup/los_cpup.h b/kernel/liteos_m/components/cpup/los_cpup.h
index b73d67d..dd8ca9a 100644
--- a/kernel/liteos_m/components/cpup/los_cpup.h
+++ b/kernel/liteos_m/components/cpup/los_cpup.h
@@ -179,7 +179,183 @@ extern UINT32 OsCpupInit(VOID);
  */
 extern VOID OsTskCycleEndStart(VOID);
 
+/**
+ * @ingroup los_cpup
+ * Count the CPU usage structures of all tasks.
+ */
+typedef struct tagCpupInfo {
+    UINT16 usStatus;            /**< save the cur task status     */
+    UINT32 uwUsage;             /**< Usage. The value range is [0,1000].   */
+} CPUP_INFO_S;
+
+/**
+ * @ingroup los_monitor
+ * Type of the CPU usage query.
+ */
+typedef enum {
+    SYS_CPU_USAGE = 0,   /* system cpu occupancy rate */
+    TASK_CPU_USAGE,      /* task cpu occupancy rate */
+} CPUP_TYPE_E;
 
+/**
+ * @ingroup los_monitor
+ * Mode of the CPU usage query.
+ */
+typedef enum {
+    CPUP_IN_10S = 0,     /* cpu occupancy rate in 10s */
+    CPUP_IN_1S,          /* cpu occupancy rate in 1s */
+    CPUP_LESS_THAN_1S,   /* cpu occupancy rate less than 1s, if the input mode is none of them, it will be this. */
+} CPUP_MODE_E;
+
+/**
+ * @ingroup los_cpup
+ * @brief Obtain the current CPU usage.
+ *
+ * @par Description:
+ * This API is used to obtain the current CPU usage.
+ * @attention
+ * <ul>
+ * <li>This API can be called only after the CPU usage is initialized. Otherwise, error codes will be returned.</li>
+ * <li> The precision of the CPU usage can be adjusted by changing the value of the CPUP_PRECISION macro.</li>
+ * </ul>
+ *
+ * @param None.
+ *
+ * @retval #OS_ERRNO_CPUP_NO_INIT           0x02001e02: The CPU usage is not initialized.
+ * @retval #cpup                            [0,100], current CPU usage, of which the precision is adjustable.
+ * @par Dependency:
+ * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_SysCpuUsage
+ */
+extern UINT32 LOS_SysCpuUsage(VOID);
+
+/**
+ * @ingroup los_cpup
+ * @brief Obtain the historical CPU usage.
+ *
+ * @par Description:
+ * This API is used to obtain the historical CPU usage.
+ * @attention
+ * <ul>
+ * <li>This API can be called only after the CPU usage is initialized. Otherwise, the CPU usage fails to be obtained.</li>
+ * </ul>
+ *
+ * @param  mode     [IN] UINT16. Task mode. The parameter value 0 indicates that the CPU usage within 10s will be
+ * obtained, and the parameter value 1 indicates that the CPU usage in the former 1s will be obtained. Other values
+ * indicate that the CPU usage in the period that is less than 1s will be obtained.
+ *
+ * @retval #OS_ERRNO_CPUP_NO_INIT           0x02001e02: The CPU usage is not initialized.
+ * @retval #cpup                            [0,100], historical CPU usage, of which the precision is adjustable.
+ * @par Dependency:
+ * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_HistoryTaskCpuUsage
+ */
+extern UINT32 LOS_HistorySysCpuUsage(UINT16 mode);
+
+/**
+ * @ingroup los_cpup
+ * @brief Obtain the CPU usage of a specified task.
+ *
+ * @par Description:
+ * This API is used to obtain the CPU usage of a task specified by a passed-in task ID.
+ * @attention
+ * <ul>
+ * <li>This API can be called only after the CPU usage is initialized. Otherwise, the CPU usage fails to be obtained.</li>
+ * <li>The passed-in task ID must be valid and the task specified by the task ID must be created. Otherwise,
+ * the CPU usage fails to be obtained.</li>
+ * </ul>
+ *
+ * @param taskID   [IN] UINT32. Task ID.
+ *
+ * @retval #OS_ERRNO_CPUP_NO_INIT             0x02001e02: The CPU usage is not initialized.
+ * @retval #OS_ERRNO_CPUP_TSK_ID_INVALID      0x02001e05: The target task ID is invalid.
+ * @retval #OS_ERRNO_CPUP_THREAD_NO_CREATED   0x02001e04: The target thread is not created.
+ * @retval #cpup                              [0,100], CPU usage of the specified task.
+ * @par Dependency:
+ * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_HistoryTaskCpuUsage
+ */
+extern UINT32 LOS_TaskCpuUsage(UINT32 taskID);
+
+/**
+ * @ingroup los_cpup
+ * @brief  Obtain the historical CPU usage of a specified task.
+ *
+ * @par Description:
+ * This API is used to obtain the historical CPU usage of a task specified by a passed-in task ID.
+ * @attention
+ * <ul>
+ * <li>This API can be called only after the CPU usage is initialized. Otherwise,
+ * the CPU usage fails to be obtained.</li>
+ * <li>The passed-in task ID must be valid and the task specified by the task ID must be created. Otherwise,
+ * the CPU usage fails to be obtained.</li>
+ * </ul>
+ *
+ * @param taskID   [IN] UINT32. Task ID.
+ * @param mode     [IN] UINT16. Task mode. The parameter value 0 indicates that the CPU usage within 10s
+ * will be obtained, and the parameter value 1 indicates that the CPU usage in the former 1s will be obtained.
+ * Other values indicate that the CPU usage in the period that is less than 1s will be obtained.
+ *
+ * @retval #OS_ERRNO_CPUP_NO_INIT             0x02001e02: The CPU usage is not initialized.
+ * @retval #OS_ERRNO_CPUP_TSK_ID_INVALID      0x02001e05: The target task ID is invalid.
+ * @retval #OS_ERRNO_CPUP_THREAD_NO_CREATED   0x02001e04: The target thread is not created.
+ * @retval #cpup                              [0,100], CPU usage of the specified task.
+ * @par Dependency:
+ * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_HistorySysCpuUsage
+ */
+extern UINT32 LOS_HistoryTaskCpuUsage(UINT32 taskID, UINT16 mode);
+
+/**
+ * @ingroup los_cpup
+ * @brief Obtain the CPU usage of all tasks.
+ *
+ * @par Description:
+ * This API is used to obtain the CPU usage of all tasks according to maximum number of threads.
+ * @attention
+ * <ul>
+ * <li>This API can be called only after the CPU usage is initialized. Otherwise, the CPU usage fails to be obtained.</li>
+ * <li>The input parameter pointer must not be NULL, Otherwise, the CPU usage fails to be obtained.</li>
+ * </ul>
+ *
+ * @param cpupInfo    [OUT]Type.   CPUP_INFO_S* Pointer to the task CPUP information structure to be obtained.
+ * @param mode        [IN] UINT16. Task mode. The parameter value 0 indicates that the CPU usage within 10s
+ * will be obtained, and the parameter value 1 indicates that the CPU usage in the former 1s will be obtained.
+ * Other values indicate that the CPU usage in the period that is less than 1s will be obtained.
+ *
+ * @retval #OS_ERRNO_CPUP_NO_INIT           0x02001e02: The CPU usage is not initialized.
+ * @retval #OS_ERRNO_CPUP_TASK_PTR_NULL     0x02001e01: The input parameter pointer is NULL.
+ * @retval #LOS_OK                          0x00000000: The CPU usage of all tasks is successfully obtained.
+ * @par Dependency:
+ * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_SysCpuUsage
+ */
+extern UINT32 LOS_AllTaskCpuUsage(CPUP_INFO_S *cpupInfo, UINT16 mode);
+
+/**
+ * @ingroup los_monitor
+ * @brief Obtain CPU usage history of certain task.
+ *
+ * @par Description:
+ * This API is used to obtain CPU usage history of certain task.
+ * @attention
+ * <ul>
+ * <li>This API can be called only after the CPU usage is initialized. Otherwise, -1 will be returned.</li>
+ * <li> Only in SYS_CPU_USAGE type, uwTaskID is invalid.</li>
+ * </ul>
+ *
+ * @param type        [IN] cpup type, SYS_CPU_USAGE and TASK_CPU_USAGE
+ * @param mode        [IN] mode,CPUP_IN_10S = usage in 10s,CPUP_IN_1S = usage in last 1s,
+ * CPUP_LESS_THAN_1S = less than 1s, if the inpuit mode is none of them, it will be as CPUP_LESS_THAN_1S.
+ * @param taskID      [IN] task ID, Only in SYS_CPU_USAGE type, taskID is invalid
+ *
+ * @retval #OS_ERROR           -1:CPU usage info obtain failed.
+ * @retval #LOS_OK              0:CPU usage info is successfully obtained.
+ * @par Dependency:
+ * <ul><li>los_monitor.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_CpupUsageMonitor
+ */
+extern UINT32 LOS_CpupUsageMonitor(CPUP_TYPE_E type, CPUP_MODE_E mode, UINT32 taskID);
 
 #ifdef __cplusplus
 #if __cplusplus
diff --git a/kernel/liteos_m/components/exchook/BUILD.gn b/kernel/liteos_m/components/exchook/BUILD.gn
index 3550c55..fc93d9d 100644
--- a/kernel/liteos_m/components/exchook/BUILD.gn
+++ b/kernel/liteos_m/components/exchook/BUILD.gn
@@ -36,7 +36,6 @@ static_library("exchook") {
     "../../kernel/arch/include",
     "../../kernel/include",
     "../../utils",
-    "./",
     "//third_party/bounds_checking_function/include",
   ]
 }
diff --git a/kernel/liteos_m/components/exchook/los_exc_info.c b/kernel/liteos_m/components/exchook/los_exc_info.c
index dd412e1..d31cb75 100644
--- a/kernel/liteos_m/components/exchook/los_exc_info.c
+++ b/kernel/liteos_m/components/exchook/los_exc_info.c
@@ -30,7 +30,6 @@
  */
 
 #include "los_exc_info.h"
-#include "securec.h"
 #include "los_debug.h"
 #include "los_interrupt.h"
 #include "los_task.h"
@@ -38,11 +37,6 @@
 #include "los_membox.h"
 #include "los_memory.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
 #if (LOSCFG_PLATFORM_EXC == 1)
 #define EXC_MSG_ARRAY_INIT_VALUE   0xff
@@ -300,9 +294,4 @@ VOID OsExcMsgDumpInit(VOID)
 }
 #endif
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
diff --git a/kernel/liteos_m/components/exchook/los_exchook.c b/kernel/liteos_m/components/exchook/los_exchook.c
old mode 100755
new mode 100644
index 067d6c9..cecacfa
--- a/kernel/liteos_m/components/exchook/los_exchook.c
+++ b/kernel/liteos_m/components/exchook/los_exchook.c
@@ -54,7 +54,7 @@ STATIC VOID DoExcHookInRegOrder(EXC_TYPE excType, struct Node *node)
 
 STATIC VOID DoExcHook(EXC_TYPE excType)
 {
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     if (excType >= EXC_TYPE_END) {
         return;
     }
@@ -88,7 +88,7 @@ STATIC struct Node *GetFreeNode(VOID)
 
 UINT32 LOS_RegExcHook(EXC_TYPE excType, ExcHookFn excHookFn)
 {
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     struct Node *node = NULL;
     if (excType >= EXC_TYPE_END || excHookFn == NULL) {
         return LOS_ERRNO_SYS_PTR_NULL;
@@ -110,7 +110,7 @@ UINT32 LOS_RegExcHook(EXC_TYPE excType, ExcHookFn excHookFn)
 
 UINT32 LOS_UnRegExcHook(EXC_TYPE excType, ExcHookFn excHookFn)
 {
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     struct Node *node = NULL;
     struct Node *preNode = NULL;
     if (excType >= EXC_TYPE_END || excHookFn == NULL) {
diff --git a/kernel/liteos_m/components/exchook/los_exchook.h b/kernel/liteos_m/components/exchook/los_exchook.h
old mode 100755
new mode 100644
diff --git a/kernel/liteos_m/components/fs/BUILD.gn b/kernel/liteos_m/components/fs/BUILD.gn
index 094d2ed..7a7401c 100644
--- a/kernel/liteos_m/components/fs/BUILD.gn
+++ b/kernel/liteos_m/components/fs/BUILD.gn
@@ -27,13 +27,24 @@
 # OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 # ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+static_library("fs_operations") {
+  sources = [
+    "./fs.c",
+  ]
+}
+
 declare_args() {
   enable_ohos_kernel_liteos_m_fatfs = true
+  enable_ohos_kernel_liteos_m_littlefs = false
 }
 
 group("fs") {
   deps = []
+  deps += [ ".:fs_operations" ]
   if (enable_ohos_kernel_liteos_m_fatfs == true) {
     deps += [ "fatfs:fatfs" ]
   }
+  if (enable_ohos_kernel_liteos_m_littlefs == true) {
+    deps += [ "littlefs:littlefs" ]
+  }
 }
diff --git a/kernel/liteos_m/components/fs/fatfs/BUILD.gn b/kernel/liteos_m/components/fs/fatfs/BUILD.gn
index ee0075c..411fdf3 100644
--- a/kernel/liteos_m/components/fs/fatfs/BUILD.gn
+++ b/kernel/liteos_m/components/fs/fatfs/BUILD.gn
@@ -29,18 +29,20 @@
 
 static_library("fatfs") {
   sources = [
+    "//third_party/FatFs/source/diskio.c",
+    "//third_party/FatFs/source/ff.c",
+    "//third_party/FatFs/source/ffsystem.c",
+    "//third_party/FatFs/source/ffunicode.c",
     "fatfs.c",
-    "fs.c",
   ]
 
   include_dirs = [
+    "../",
     "../../../kernel/arch/include",
     "../../../kernel/include",
     "../../../utils",
     "../../../kal/cmsis",
-    "../../../kal",
     "../../../kal/posix/include",
-    "./",
     "//third_party/bounds_checking_function/include",
     "//third_party/FatFs/source/",
   ]
diff --git a/kernel/liteos_m/components/fs/fatfs/fatfs.c b/kernel/liteos_m/components/fs/fatfs/fatfs.c
old mode 100755
new mode 100644
index 363bc8a..f883f5f
--- a/kernel/liteos_m/components/fs/fatfs/fatfs.c
+++ b/kernel/liteos_m/components/fs/fatfs/fatfs.c
@@ -29,22 +29,20 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#define _GNU_SOURCE 1
 #include "ff.h"
-#if FF_USE_EXPAND
-#define _GNU_SOURCE
-#endif
 #include "fatfs.h"
 #include "errno.h"
+#include "stdbool.h"
 #include "limits.h"
 #include "pthread.h"
 #include "time.h"
 #include "securec.h"
 #include "los_compiler.h"
 #include "los_debug.h"
-#include "cmsis_os.h"
+#include "cmsis_os2.h"
+#include "fs_operations.h"
 
-#define FS_SUCCESS            0
-#define FS_FAILURE            (-1)
 /* the max name length of different parts should not bigger than 32 */
 #define FS_DRIVE_NAME_MAX_LEN 32
 
@@ -1259,8 +1257,8 @@ OUT:
 
 static int do_truncate(int fd, off_t length, UINT count)
 {
-    FRESULT res;
-    INT32 ret = FR_OK;
+    FRESULT res = FR_OK;
+    INT32 ret = FS_SUCCESS;
     DWORD csz;
 
     csz = (DWORD)(g_handle[fd].fil.obj.fs)->csize * SS(g_handle[fd].fil.obj.fs); /* Cluster size */
@@ -1421,3 +1419,27 @@ OUT:
     FsUnlock();
     return ret;
 }
+
+struct MountOps g_fatfsMnt = {
+    .Mount = fatfs_mount,
+    .Umount = fatfs_umount,
+    .Umount2 = fatfs_umount2,
+    .Statfs = fatfs_statfs,
+};
+
+struct FileOps g_fatfsFops = {
+    .Mkdir = fatfs_mkdir,
+    .Unlink = fatfs_unlink,
+    .Rmdir = fatfs_rmdir,
+    .Opendir = fatfs_opendir,
+    .Readdir = fatfs_readdir,
+    .Closedir = fatfs_closedir,
+    .Open = fatfs_open,
+    .Close = fatfs_close,
+    .Write = fatfs_write,
+    .Read = fatfs_read,
+    .Seek = fatfs_lseek,
+    .Rename = fatfs_rename,
+    .Getattr = fatfs_stat,
+    .Fsync = fatfs_fsync,
+};
\ No newline at end of file
diff --git a/kernel/liteos_m/components/fs/fatfs/fatfs.h b/kernel/liteos_m/components/fs/fatfs/fatfs.h
old mode 100755
new mode 100644
diff --git a/kernel/liteos_m/components/fs/fatfs/fs.c b/kernel/liteos_m/components/fs/fs.c
old mode 100755
new mode 100644
similarity index 56%
rename from kernel/liteos_m/components/fs/fatfs/fs.c
rename to kernel/liteos_m/components/fs/fs.c
index 7435e82..66ed8af
--- a/kernel/liteos_m/components/fs/fatfs/fs.c
+++ b/kernel/liteos_m/components/fs/fs.c
@@ -28,7 +28,7 @@
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
+#include "fs_operations.h"
 #include "fatfs.h"
 #include "dirent.h"
 #include "errno.h"
@@ -42,8 +42,12 @@
 #include "sys/stat.h"
 #include "unistd.h"
 
+struct FsMap g_fsmap[MAX_FILESYSTEM_LEN] = {0};
+struct FsMap *g_fs = NULL;
+
 #ifdef LOSCFG_NET_LWIP_SACK
 #include "lwip/lwipopts.h"
+#include "lwip/sockets.h"
 #define CONFIG_NSOCKET_DESCRIPTORS  LWIP_CONFIG_NUM_SOCKETS
 #else
 #define CONFIG_NSOCKET_DESCRIPTORS  0
@@ -91,12 +95,12 @@ static size_t GetCanonicalPath(const char *cwd, const char *path, char *buf, siz
     size_t tmpLen = strlen(cwd) + strlen(path) + offset;
     char *tmpBuf = (char *)malloc(tmpLen);
     if (tmpBuf == NULL) {
-        return 0;
+        return FS_SUCCESS;
     }
 
     if (-1 == sprintf_s(tmpBuf, tmpLen, "/%s/%s/", cwd, path)) {
         free(tmpBuf);
-        return 0;
+        return FS_SUCCESS;
     }
 
     char *p;
@@ -105,7 +109,7 @@ static size_t GetCanonicalPath(const char *cwd, const char *path, char *buf, siz
     while ((p = strstr(tmpBuf, "/./")) != NULL) {
         if (EOK != memmove_s(p, tmpLen - (p - tmpBuf), p + offset, tmpLen - (p - tmpBuf) - offset)) {
             free(tmpBuf);
-            return 0;
+            return FS_SUCCESS;
         }
     }
 
@@ -113,7 +117,7 @@ static size_t GetCanonicalPath(const char *cwd, const char *path, char *buf, siz
     while ((p = strstr(tmpBuf, "//")) != NULL) {
         if (EOK != memmove_s(p, tmpLen - (p - tmpBuf), p + 1, tmpLen - (p - tmpBuf) - 1)) {
             free(tmpBuf);
-            return 0;
+            return FS_SUCCESS;
         }
     }
 
@@ -126,7 +130,7 @@ static size_t GetCanonicalPath(const char *cwd, const char *path, char *buf, siz
         }
         if (EOK != memmove_s(start, tmpLen - (start - tmpBuf), p + offset, tmpLen - (p - tmpBuf) - offset)) {
             free(tmpBuf);
-            return 0;
+            return FS_SUCCESS;
         }
     }
 
@@ -143,7 +147,7 @@ static size_t GetCanonicalPath(const char *cwd, const char *path, char *buf, siz
 
     if (EOK != memcpy_s(buf, bufSize, tmpBuf, (((totalLen + 1) > bufSize) ? bufSize : (totalLen + 1)))) {
         free(tmpBuf);
-        return 0;
+        return FS_SUCCESS;
     }
 
     buf[bufSize - 1] = 0;
@@ -152,21 +156,83 @@ static size_t GetCanonicalPath(const char *cwd, const char *path, char *buf, siz
 }
 #endif
 
+static void InitMountInfo(void)
+{
+    extern struct MountOps g_fatfsMnt;
+    extern struct FileOps g_fatfsFops;
+    g_fsmap[0].fileSystemtype = strdup("fat");
+    g_fsmap[0].fsMops = &g_fatfsMnt;
+    g_fsmap[0].fsFops = &g_fatfsFops;
+    extern struct MountOps g_lfsMnt;
+    extern struct FileOps g_lfsFops;
+    g_fsmap[1].fileSystemtype = strdup("littlefs");
+    g_fsmap[1].fsMops = &g_lfsMnt;
+    g_fsmap[1].fsFops = &g_lfsFops;
+}
+
+static struct FsMap *MountFindfs(const char *fileSystemtype)
+{
+    struct FsMap *m = NULL;
+
+    for (int i = 0; i < MAX_FILESYSTEM_LEN; i++) {
+        m = &(g_fsmap[i]);
+        if (m->fileSystemtype && strcmp(fileSystemtype, m->fileSystemtype) == 0) {
+            return m;
+        }
+    }
+
+    return NULL;
+}
+
 int mount(const char *source, const char *target,
           const char *filesystemtype, unsigned long mountflags,
           const void *data)
 {
-    return fatfs_mount(source, target, filesystemtype, mountflags, data);
+    static int initFlag = 0;
+
+    if (initFlag == 0) {
+        InitMountInfo();
+        initFlag = 1;
+    }
+
+    g_fs = MountFindfs(filesystemtype);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+
+    if (g_fs->fsMops == NULL || g_fs->fsMops->Mount == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+
+    return g_fs->fsMops->Mount(source, target, filesystemtype, mountflags, data);
 }
 
 int umount(const char *target)
 {
-    return fatfs_umount(target);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsMops == NULL || g_fs->fsMops->Umount == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsMops->Umount(target);
 }
 
 int umount2(const char *target, int flag)
 {
-    return fatfs_umount2(target, flag);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsMops == NULL || g_fs->fsMops->Umount2 == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsMops->Umount2(target, flag);
 }
 
 int open(const char *path, int oflag, ...)
@@ -175,30 +241,30 @@ int open(const char *path, int oflag, ...)
     unsigned flags = O_RDONLY | O_WRONLY | O_RDWR | O_APPEND | O_CREAT | O_LARGEFILE | O_TRUNC | O_EXCL | O_DIRECTORY;
     if ((unsigned)oflag & ~flags) {
         errno = EINVAL;
-        return -1;
+        return FS_FAILURE;
     }
 
     size_t pathLen = strlen(path) + 1;
     char *canonicalPath = (char *)malloc(pathLen);
     if (!canonicalPath) {
         errno = ENOMEM;
-        return -1;
+        return FS_FAILURE;
     }
     if (GetCanonicalPath(NULL, path, canonicalPath, pathLen) == 0) {
         FREE_AND_SET_NULL(canonicalPath);
         errno = ENOMEM;
-        return -1;
+        return FS_FAILURE;
     }
 
     if (strcmp(canonicalPath, RANDOM_DEV_PATH) == 0) {
         FREE_AND_SET_NULL(canonicalPath);
         if ((O_ACCMODE & (unsigned)oflag) != O_RDONLY) {
             errno = EPERM;
-            return -1;
+            return FS_FAILURE;
         }
         if ((unsigned)oflag & O_DIRECTORY) {
             errno = ENOTDIR;
-            return -1;
+            return FS_FAILURE;
         }
         return RANDOM_DEV_FD;
     }
@@ -206,21 +272,29 @@ int open(const char *path, int oflag, ...)
         FREE_AND_SET_NULL(canonicalPath);
         if ((unsigned)oflag & O_DIRECTORY) {
             errno = EPERM;
-            return -1;
+            return FS_FAILURE;
         }
         errno = EISDIR;
-        return -1;
+        return FS_FAILURE;
     }
     FREE_AND_SET_NULL(canonicalPath);
 #endif
-    return fatfs_open(path, oflag);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Open == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Open(path, oflag);
 }
 
 int close(int fd)
 {
 #ifdef LOSCFG_RANDOM_DEV
     if (fd == RANDOM_DEV_FD) {
-        return 0;
+        return FS_SUCCESS;
     }
 #endif
 #ifdef LOSCFG_NET_LWIP_SACK
@@ -228,7 +302,15 @@ int close(int fd)
         return closesocket(fd);
     }
 #endif
-    return fatfs_close(fd);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Close == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Close(fd);
 }
 
 ssize_t read(int fd, void *buf, size_t nbyte)
@@ -236,11 +318,11 @@ ssize_t read(int fd, void *buf, size_t nbyte)
 #ifdef LOSCFG_RANDOM_DEV
     if (fd == RANDOM_DEV_FD) {
         if (nbyte == 0) {
-            return 0;
+            return FS_SUCCESS;
         }
         if (buf == NULL) {
             errno = EINVAL;
-            return -1;
+            return FS_FAILURE;
         }
         if (nbyte > 1024) {
             nbyte = 1024; /* hks_generate_random: random_size must <= 1024 */
@@ -248,7 +330,7 @@ ssize_t read(int fd, void *buf, size_t nbyte)
         struct hks_blob key = {HKS_BLOB_TYPE_RAW, (uint8_t *)buf, nbyte};
         if (hks_generate_random(&key) != 0) {
             errno = EIO;
-            return -1;
+            return FS_FAILURE;
         }
         return (ssize_t)nbyte;
     }
@@ -258,7 +340,15 @@ ssize_t read(int fd, void *buf, size_t nbyte)
         return recv(fd, buf, nbyte, 0);
     }
 #endif
-    return fatfs_read(fd, buf, nbyte);
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Read == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Read(fd, buf, nbyte);
 }
 
 ssize_t write(int fd, const void *buf, size_t nbyte)
@@ -266,7 +356,7 @@ ssize_t write(int fd, const void *buf, size_t nbyte)
 #ifdef LOSCFG_RANDOM_DEV
     if (fd == RANDOM_DEV_FD) {
         errno = EBADF; /* "/dev/random" is readonly */
-        return -1;
+        return FS_FAILURE;
     }
 #endif
 #ifdef LOSCFG_NET_LWIP_SACK
@@ -274,70 +364,182 @@ ssize_t write(int fd, const void *buf, size_t nbyte)
         return send(fd, buf, nbyte, 0);
     }
 #endif
-    return fatfs_write(fd, buf, nbyte);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Write == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Write(fd, buf, nbyte);
 }
 
 off_t lseek(int fd, off_t offset, int whence)
 {
-    return fatfs_lseek(fd, offset, whence);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Seek == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Seek(fd, offset, whence);
 }
 
 int unlink(const char *path)
 {
-    return fatfs_unlink(path);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Unlink == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Unlink(path);
 }
 
 int fstat(int fd, struct stat *buf)
 {
-    return fatfs_fstat(fd, buf);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Fstat == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Fstat(fd, buf);
 }
 
 int stat(const char *path, struct stat *buf)
 {
-    return fatfs_stat(path, buf);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Stat == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Stat(path, buf);
 }
 
 int fsync(int fd)
 {
-    return fatfs_fsync(fd);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Fsync == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Fsync(fd);
 }
 
 int mkdir(const char *path, mode_t mode)
 {
-    return fatfs_mkdir(path, mode);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Mkdir == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Mkdir(path, mode);
 }
 
 DIR *opendir(const char *dirName)
 {
-    return fatfs_opendir(dirName);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return NULL;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Opendir == NULL) {
+        errno = ENOSYS;
+        return NULL;
+    }
+    return g_fs->fsFops->Opendir(dirName);
 }
 
 struct dirent *readdir(DIR *dir)
 {
-    return fatfs_readdir(dir);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return NULL;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Readdir == NULL) {
+        errno = ENOSYS;
+        return NULL;
+    }
+    return g_fs->fsFops->Readdir(dir);
 }
 
 int closedir(DIR *dir)
 {
-    return fatfs_closedir(dir);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Closedir == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Closedir(dir);
 }
 
 int rmdir(const char *path)
 {
-    return fatfs_rmdir(path);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Rmdir == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Rmdir(path);
 }
 
 int rename(const char *oldName, const char *newName)
 {
-    return fatfs_rename(oldName, newName);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Rename == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Rename(oldName, newName);
 }
 
 int statfs(const char *path, struct statfs *buf)
 {
-    return fatfs_statfs(path, buf);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsMops == NULL || g_fs->fsMops->Statfs == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsMops->Statfs(path, buf);
 }
 
 int ftruncate(int fd, off_t length)
 {
-    return fatfs_ftruncate(fd, length);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Ftruncate == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Ftruncate(fd, length);
 }
diff --git a/kernel/liteos_m/components/fs/fs_operations.h b/kernel/liteos_m/components/fs/fs_operations.h
new file mode 100644
index 0000000..172ab60
--- /dev/null
+++ b/kernel/liteos_m/components/fs/fs_operations.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _FS_OPERATIONS_H_
+#define _FS_OPERATIONS_H_
+
+#include "fcntl.h"
+#include "dirent.h"
+#include "unistd.h"
+#include "sys/mount.h"
+#include "sys/stat.h"
+#include "sys/statfs.h"
+
+#define FS_SUCCESS            0
+#define FS_FAILURE            (-1)
+#define MAX_FILESYSTEM_LEN 2
+
+struct MountOps {
+    int (*Mount)(const char *source, const char *target, const char *filesystemtype, unsigned long mountflags,
+        const void *data);
+    int (*Umount)(const char* target);
+    int (*Umount2)(const char* target, int flag);
+    int (*Statfs)(const char *path, struct statfs *buf);
+};
+
+struct FsMap {
+    const char *fileSystemtype;
+    const struct MountOps *fsMops;
+    const struct FileOps *fsFops;
+};
+
+struct FileOps {
+    int (*Open)(const char *path, int openFlag, ...);
+    int (*Close)(int fd);
+    int (*Unlink)(const char *fileName);
+    int (*Rmdir)(const char *dirName);
+    int (*Mkdir)(const char *dirName, mode_t mode);
+    struct dirent *(*Readdir)(DIR *dir);
+    DIR *(*Opendir)(const char *dirName);
+    int (*Closedir)(DIR *dir);
+    int (*Read)(int fd, void *buf, size_t len);
+    int (*Write)(int fd, const void *buf, size_t len);
+    off_t (*Seek)(int fd, off_t offset, int whence);
+    int (*Getattr)(const char *path, struct stat *buf);
+    int (*Rename)(const char *oldName, const char *newName);
+    int (*Fsync)(int fd);
+    int (*Fstat)(int fd, struct stat *buf);
+    int (*Stat)(const char *path, struct stat *buf);
+    int (*Ftruncate)(int fd, off_t length);
+};
+
+#endif /* _FS_OPERATIONS_H_ */
diff --git a/kernel/liteos_m/components/fs/littlefs/BUILD.gn b/kernel/liteos_m/components/fs/littlefs/BUILD.gn
new file mode 100644
index 0000000..f3d8c9e
--- /dev/null
+++ b/kernel/liteos_m/components/fs/littlefs/BUILD.gn
@@ -0,0 +1,45 @@
+# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021, Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("littlefs") {
+  sources = [
+    "lfs_api.c",
+  ]
+
+  include_dirs = [
+    "../../../kernel/arch/include",
+    "../../../kernel/include",
+    "../../../utils",
+    "../../../kal/cmsis",
+    "../../../kal",
+    "../../../kal/posix/include",
+    "./",
+    "//third_party/littlefs/include",
+  ]
+}
diff --git a/kernel/liteos_m/components/fs/littlefs/lfs_api.c b/kernel/liteos_m/components/fs/littlefs/lfs_api.c
new file mode 100644
index 0000000..b95d41a
--- /dev/null
+++ b/kernel/liteos_m/components/fs/littlefs/lfs_api.c
@@ -0,0 +1,555 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "lfs_api.h"
+
+lfs_t g_lfs;
+FileDirInfo g_lfsDir[LFS_MAX_OPEN_DIRS] = {0};
+
+struct FileOpInfo g_fsOp[LFS_MAX_MOUNT_SIZE] = {0};
+static LittleFsHandleStruct g_handle[LITTLE_FS_MAX_OPEN_FILES] = {0};
+struct dirent g_nameValue;
+static pthread_mutex_t g_FslocalMutex = PTHREAD_MUTEX_INITIALIZER;
+static const char *const g_littlefsMntName[LFS_MAX_MOUNT_SIZE] = {"/a","/b","/c"};
+
+FileOpInfo GetFsOpInfo(void)
+{
+    return g_fsOp;
+}
+
+LittleFsHandleStruct *LfsAllocFd(const char *fileName, int *fd)
+{
+    pthread_mutex_lock(&g_FslocalMutex);
+    for (int i = 0; i < LITTLE_FS_MAX_OPEN_FILES; i++) {
+        if (g_handle[i].useFlag == 0) {
+            *fd = i;
+            g_handle[i].useFlag = 1;
+            g_handle[i].pathName = strdup(fileName);
+            pthread_mutex_unlock(&g_FslocalMutex);
+            return &(g_handle[i]);
+        }
+    }
+    pthread_mutex_unlock(&g_FslocalMutex);
+    *fd = INVALID_FD;
+    return NULL;
+}
+
+BOOL CheckFileIsOpen(const char *fileName)
+{
+    pthread_mutex_lock(&g_FslocalMutex);
+    for (int i = 0; i < LITTLE_FS_MAX_OPEN_FILES; i++) {
+        if (g_handle[i].useFlag == 1) {
+            if (strcmp(g_handle[i].pathName, fileName) == 0) {
+                pthread_mutex_unlock(&g_FslocalMutex);
+                return TRUE;
+            }
+        }
+    }
+    pthread_mutex_unlock(&g_FslocalMutex);
+    return FALSE;
+}
+
+FileDirInfo *GetFreeDir(const char *dirName)
+{
+    pthread_mutex_lock(&g_FslocalMutex);
+    for (int i = 0; i < LFS_MAX_OPEN_DIRS; i++) {
+        if (g_lfsDir[i].useFlag == 0) {
+            g_lfsDir[i].useFlag = 1;
+            g_lfsDir[i].dirName = strdup(dirName);
+            pthread_mutex_unlock(&g_FslocalMutex);
+            return &(g_lfsDir[i]);
+        }
+    }
+    pthread_mutex_unlock(&g_FslocalMutex);
+    return NULL;
+}
+
+BOOL CheckDirIsOpen(const char *dirName)
+{
+    pthread_mutex_lock(&g_FslocalMutex);
+    for (int i = 0; i < LFS_MAX_OPEN_DIRS; i++) {
+        if (g_lfsDir[i].useFlag == 1) {
+            if(strcmp(g_lfsDir[i].dirName, dirName) == 0) {
+                pthread_mutex_unlock(&g_FslocalMutex);
+                return TRUE;
+            }
+        }
+    }
+    pthread_mutex_unlock(&g_FslocalMutex);
+    return FALSE;
+}
+
+BOOL CheckPathIsMounted(const char *pathName, struct FileOpInfo **fileOpInfo)
+{
+    char tmpName[LITTLEFS_MAX_LFN_LEN] = {0};
+    int mountPathNameLen = 0;
+    int len = strlen(pathName) + 1;
+
+    pthread_mutex_lock(&g_FslocalMutex);
+    for (int i = 0; i < LFS_MAX_MOUNT_SIZE; i++) {
+        if (g_fsOp[i].useFlag == 1) {
+            mountPathNameLen = strlen(g_fsOp[i].dirName);
+            if(len < mountPathNameLen + 1) {
+                pthread_mutex_unlock(&g_FslocalMutex);
+                return FALSE;
+            }
+
+            (void)strncpy_s(tmpName, LITTLEFS_MAX_LFN_LEN, pathName, mountPathNameLen);
+            tmpName[mountPathNameLen] = '\0';
+
+            if(strcmp(tmpName, g_fsOp[i].dirName) == 0) {
+                *fileOpInfo = &(g_fsOp[i]);
+                pthread_mutex_unlock(&g_FslocalMutex);
+                return TRUE;
+            }
+        }
+    }
+    pthread_mutex_unlock(&g_FslocalMutex);
+    return FALSE;
+}
+
+struct FileOpInfo *AllocMountRes(const char* target, struct FileOps *fileOps)
+{
+    pthread_mutex_lock(&g_FslocalMutex);
+    for (int i = 0; i < LFS_MAX_MOUNT_SIZE; i++) {
+        if (g_fsOp[i].useFlag == 0 && strcmp(target, g_littlefsMntName[i]) == 0) {
+            g_fsOp[i].useFlag = 1;
+            g_fsOp[i].fsVops = fileOps;
+            g_fsOp[i].dirName == strdup(target);
+            pthread_mutex_unlock(&g_FslocalMutex);
+            return &(g_fsOp[i]);
+        }
+    }
+
+    pthread_mutex_unlock(&g_FslocalMutex);
+    return NULL;
+}
+
+struct FileOpInfo *GetMountRes(const char*target, int *mountIndex)
+{
+    pthread_mutex_lock(&g_FslocalMutex);
+    for (int i = 0; i < LFS_MAX_MOUNT_SIZE; i++) {
+        if (g_fsOp[i].useFlag == 1) {
+            if (g_fsOp[i].dirName && strcmp(target, g_fsOp[i].dirName) == 0) {
+                *mountIndex = i;
+                pthread_mutex_unlock(&g_FslocalMutex);
+                return &(g_fsOp[i]);
+            }
+        }
+    }
+
+    pthread_mutex_unlock(&g_FslocalMutex);
+    return NULL;
+}
+
+int FreeMountResByIndex(int mountIndex)
+{
+    if (mountIndex < 0 || mountIndex >= LFS_MAX_MOUNT_SIZE) {
+        return VFS_ERROR;
+    }
+
+    pthread_mutex_lock(&g_FslocalMutex);
+    if (g_fsOp[mountIndex].useFlag == 1 && g_fsOp[mountIndex].dirName != NULL) {
+        g_fsOp[mountIndex].useFlag = 0;
+        free(g_fsOp[mountIndex].dirName);
+        g_fsOp[mountIndex].dirName = NULL;
+    }
+    pthread_mutex_unlock(&g_FslocalMutex);
+
+    return VFS_OK;
+}
+
+int FreeMountRes(const char *target)
+{
+    pthread_mutex_lock(&g_FslocalMutex);
+    for (int i = 0; i < LFS_MAX_MOUNT_SIZE; i++) {
+        if (g_fsOp[i].useFlag == 1) {
+            if (g_fsOp[i].dirName && strcmp(target, g_fsOp[i].dirName) == 0) {
+                g_fsOp[i].useFlag = 0;
+                free(g_fsOp[i].dirName);
+                g_fsOp[i].dirName = NULL;
+                pthread_mutex_unlock(&g_FslocalMutex);
+                return VFS_OK;
+            }
+        }
+    }
+
+    pthread_mutex_unlock(&g_FslocalMutex);
+    return VFS_ERROR;
+}
+
+const struct MountOps g_lfsMnt = {
+    .Mount = LfsMount,
+    .Umount = LfsUmount,
+};
+
+const struct FileOps g_lfsFops = {
+    .Mkdir = LfsMkdir,
+    .Unlink = LfsUnlink,
+    .Rmdir = LfsRmdir,
+    .Opendir = LfsOpendir,
+    .Readdir = LfsReaddir,
+    .Closedir = LfsClosedir,
+    .Open = LfsOpen,
+    .Close = LfsClose,
+    .Write = LfsWrite,
+    .Read = LfsRead,
+    .Seek = LfsSeek,
+    .Rename = LfsRename,
+    .Getattr = LfsStat,
+    .Fsync = LfsFsync,
+};
+
+int LfsMount(const char *source, const char *target, const char *fileSystemType, unsigned long mountflags,
+    const void *data)
+{
+    int ret;
+    struct FileOpInfo *fileOpInfo = NULL;
+
+    if (target == NULL || fileSystemType == NULL || data == NULL) {
+        ret = VFS_ERROR;
+        goto errout;
+    }
+
+    if (strcmp(fileSystemType, "littlefs") != 0) {
+        ret = VFS_ERROR;
+        goto errout;
+    }
+
+    if (CheckPathIsMounted(target, &fileOpInfo)) {
+        ret = VFS_OK;
+        goto errout;
+    }
+
+    // select free mount resource
+    fileOpInfo = AllocMountRes(target, &g_lfsFops);
+    if (fileOpInfo == NULL) {
+        ret = VFS_ERROR;
+        goto errout;
+    }
+    
+    return lfs_mount(&(fileOpInfo->lfsInfo), (struct lfs_config*)data);
+errout:
+    return ret;
+}
+
+int LfsUmount(const char *target)
+{
+    int ret, mountIndex = -1;
+    struct FileOpInfo *fileOpInfo = NULL;
+
+    if (target == NULL) {
+        return VFS_ERROR;
+    }
+
+    fileOpInfo = GetMountRes(target, &mountIndex);
+    if (fileOpInfo == NULL) {
+        return VFS_ERROR;
+    }
+
+    ret = lfs_unmount(&(fileOpInfo->lfsInfo));
+
+    (void)FreeMountResByIndex(mountIndex);
+    return ret;
+}
+
+int LfsUnlink(const char *fileName)
+{
+    struct FileOpInfo *fileOpInfo = NULL;
+
+    if (fileName == NULL) {
+        return VFS_ERROR;
+    }
+
+    if (CheckPathIsMounted(fileName, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
+        return VFS_ERROR;
+    }
+
+    return lfs_remove(&(fileOpInfo->lfsInfo), fileName);
+}
+
+int LfsMkdir(const char *dirName, mode_t mode)
+{
+    struct FileOpInfo *fileOpInfo = NULL;
+
+    if (dirName == NULL) {
+        return VFS_ERROR;
+    }
+
+    if (CheckPathIsMounted(dirName, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
+        return VFS_ERROR;
+    }
+
+    return lfs_mkdir(&(fileOpInfo->lfsInfo), dirName);
+}
+
+int LfsRmdir(const char *dirName)
+{
+    struct FileOpInfo *fileOpInfo = NULL;
+
+    if (dirName == NULL) {
+        return VFS_ERROR;
+    }
+
+    if (CheckPathIsMounted(dirName, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
+        return VFS_ERROR;
+    }
+
+    return lfs_remove(&(fileOpInfo->lfsInfo), dirName);
+}
+
+DIR *LfsOpendir(const char *dirName)
+{
+    int ret;
+    struct FileOpInfo *fileOpInfo = NULL;
+
+    if (dirName == NULL) {
+        return VFS_ERROR;
+    }
+
+    if (CheckPathIsMounted(dirName, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
+        return VFS_ERROR;
+    }
+
+    if (CheckDirIsOpen(dirName)) {
+        goto errout;
+    }
+
+    FileDirInfo *dirInfo = GetFreeDir(dirName);
+    if (dirInfo == NULL) {
+        goto errout;
+    }
+
+    ret = lfs_dir_open(&(fileOpInfo->lfsInfo), (lfs_dir_t *)(&(dirInfo->dir)), dirName);
+
+    if (ret != 0) {
+        goto errout;
+    }
+
+    dirInfo->lfsHandle = &(fileOpInfo->lfsInfo);
+
+    return (DIR *)dirInfo;
+
+errout:
+    return NULL;
+}
+
+struct dirent *LfsReaddir(DIR *dir)
+{
+    int ret;
+    struct lfs_info lfsInfo;
+
+    FileDirInfo *dirInfo = (FileDirInfo *)dir;
+
+    if (dirInfo == NULL || dirInfo->lfsHandle == NULL) {
+        return NULL;
+    }
+
+    ret = lfs_dir_read(dirInfo->lfsHandle, (lfs_dir_t *)(&(dirInfo->dir)), &lfsInfo);
+    if (ret == 0) {
+        pthread_mutex_lock(&g_FslocalMutex);
+        g_nameValue.d_name = strdup(lfsInfo.name);
+        if (lfsInfo.type == LFS_TYPE_DIR) {
+            g_nameValue.d_type = DT_DIR;
+        } else if (lfsInfo.type == LFS_TYPE_REG) {
+            g_nameValue.d_type = DT_REG;
+        }
+
+        g_nameValue.d_reclen = lfsInfo.size;
+        pthread_mutex_unlock(&g_FslocalMutex);
+
+        return &g_nameValue;
+    }
+
+    return NULL;
+}
+
+int LfsClosedir(const DIR *dir)
+{
+    FileDirInfo *dirInfo = (FileDirInfo *)dir;
+
+    if (dirInfo == NULL || dirInfo->lfsHandle == NULL) {
+        return VFS_ERROR;
+    }
+
+    return lfs_dir_close(dirInfo->lfsHandle, (lfs_dir_t *)(&(dirInfo->dir)));
+}
+
+int LfsOpen(const char *pathName, int openFlag, int mode)
+{
+    int fd = INVALID_FD;
+    struct FileOpInfo *fileOpInfo = NULL;
+
+    if (pathName == NULL) {
+        goto errout;
+    }
+
+    if (CheckPathIsMounted(pathName, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
+        goto errout;
+    }
+    // if file is already open, return invalid fd
+    if (CheckFileIsOpen(pathName)) {
+        goto errout;
+    }
+
+    LittleFsHandleStruct *fsHandle = LfsAllocFd(pathName, &fd);
+    if (fd == INVALID_FD) {
+        goto errout;
+    }
+
+    int err = lfs_file_open(&(fileOpInfo->lfsInfo), &(fsHandle->file), pathName, openFlag);
+    if (err != 0) {
+        goto errout;
+    }
+
+    g_handle[fd].lfsHandle = &(fileOpInfo->lfsInfo);
+    return fd;
+errout:
+    return INVALID_FD;
+}
+
+int LfsRead(int fd, void *buf, unsigned int len)
+{
+    if (fd >= LITTLE_FS_MAX_OPEN_FILES || fd < 0 || buf == NULL) {
+        return VFS_ERROR;
+    }
+
+    if (g_handle[fd].lfsHandle == NULL) {
+        return VFS_ERROR;
+    }
+
+    return lfs_file_read(g_handle[fd].lfsHandle, &(g_handle[fd].file), buf, len);
+}
+
+int LfsWrite(int fd, const void *buf, unsigned int len)
+{
+    if (fd >= LITTLE_FS_MAX_OPEN_FILES || fd < 0 || buf == NULL) {
+        return VFS_ERROR;
+    }
+
+    if (g_handle[fd].lfsHandle == NULL) {
+        return VFS_ERROR;
+    }
+
+    return lfs_file_write(g_handle[fd].lfsHandle, &(g_handle[fd].file), buf, len);
+}
+
+int LfsSeek(int fd, off_t offset, int whence)
+{
+    if (fd >= LITTLE_FS_MAX_OPEN_FILES || fd < 0) {
+        return VFS_ERROR;
+    }
+
+    if (g_handle[fd].lfsHandle == NULL) {
+        return VFS_ERROR;
+    }
+
+    return lfs_file_seek(g_handle[fd].lfsHandle, &(g_handle[fd].file), offset, whence);
+}
+
+int LfsClose(int fd)
+{
+    int ret = VFS_ERROR;
+
+    if (fd >= LITTLE_FS_MAX_OPEN_FILES || fd < 0) {
+        return ret;
+    }
+
+    if (g_handle[fd].lfsHandle == NULL) {
+        return VFS_ERROR;
+    }
+
+    pthread_mutex_lock(&g_FslocalMutex);
+    ret = lfs_file_close(g_handle[fd].lfsHandle, &(g_handle[fd].file));
+    g_handle[fd].useFlag = 0;
+    if (g_handle[fd].pathName != NULL) {
+        free(g_handle[fd].pathName);
+        g_handle[fd].pathName = NULL;
+    }
+
+    if (g_handle[fd].lfsHandle != NULL) {
+        g_handle[fd].lfsHandle = NULL;
+    }
+    pthread_mutex_unlock(&g_FslocalMutex);
+
+    return ret;    
+}
+
+int LfsRename(const char *oldName, const char *newName)
+{
+    struct FileOpInfo *fileOpInfo = NULL;
+
+    if (oldName == NULL || newName == NULL) {
+        return VFS_ERROR;
+    }
+
+    if (CheckPathIsMounted(oldName, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
+        return VFS_ERROR;
+    }
+
+    return lfs_rename(&(fileOpInfo->lfsInfo), oldName, newName);
+}
+
+int LfsStat(const char *path, struct stat *buf)
+{
+    int ret;
+    struct lfs_info info;
+    struct FileOpInfo *fileOpInfo = NULL;
+
+    if (path == NULL || buf == NULL) {
+        return VFS_ERROR;
+    }
+
+    if (CheckPathIsMounted(path, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
+        return VFS_ERROR;
+    }
+
+    ret = lfs_stat(&(fileOpInfo->lfsInfo), path, &info);
+    if (ret == 0) {
+        buf->st_size = info.size;
+    }
+
+    return ret;    
+}
+
+int LfsFsync(int fd)
+{
+    if (fd >= LITTLE_FS_MAX_OPEN_FILES || fd < 0) {
+        return VFS_ERROR;
+    }
+
+    if (g_handle[fd].lfsHandle == NULL) {
+        return VFS_ERROR;
+    }
+
+    return lfs_file_sync(g_handle[fd].lfsHandle, &(g_handle[fd].file));
+}
+
diff --git a/kernel/liteos_m/components/fs/littlefs/lfs_api.h b/kernel/liteos_m/components/fs/littlefs/lfs_api.h
new file mode 100644
index 0000000..a9b78ca
--- /dev/null
+++ b/kernel/liteos_m/components/fs/littlefs/lfs_api.h
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LFS_API_H_
+#define _LFS_API_H_
+
+#include "bits/alltypes.h"
+#include "sys/stat.h"
+
+#include "dirent.h"
+#include "lfs.h"
+#include "lfs_util.h"
+#include "memory.h"
+#include "pthread.h"
+
+#define INVALID_FD (-1)
+
+typedef unsigned mode_t;
+
+#ifndef VFS_ERROR
+#define VFS_ERROR (-1)
+#endif
+
+#ifndef VFS_OK
+#define VFS_OK  0
+#endif
+
+typedef struct {
+    uint8_t useFlag;
+    const char *pathName;
+    lfs_t *lfsHandle;
+    lfs_file_t file;
+} LittleFsHandleStruct;
+
+struct FileOpInfo {
+    uint8_t useFlag;
+    struct FileOps *fsVops;
+    char *dirName;
+    lfs_t lfsInfo;
+};
+
+typedef struct {
+    uint8_t useFlag;
+    char *dirName;
+    lfs_t *lfsHandle;
+    lfs_dir_t dir;
+} FileDirInfo;
+
+#define LITTLE_FS_MAX_OPEN_FILES 100
+#define LITTLE_FS_STANDARD_NAME_LENGTH 50
+#define LITTLE_FS_MAX_NAME_LEN 255
+
+#define MAX_DEF_BUF_NUM 21
+#define MAX_BUFFER_LEN 100
+#define MAX_WRITE_FILE_LEN 500
+#define MAX_READ_FILE_LEN 500
+#define LITTLEFS_MAX_LFN_LEN 255
+
+#ifndef LFS_MAX_OPEN_DIRS
+#define LFS_MAX_OPEN_DIRS 10
+#endif
+
+#ifndef LFS_MAX_MOUNT_SIZE
+#define LFS_MAX_MOUNT_SIZE 3
+#endif
+
+
+LittleFsHandleStruct *GetFreeFd(int *fd);
+
+int InitMountInfo(const char *fileSystemType, const struct MountOps *fsMops);
+int LfsMount(const char *source, const char *target, const char *fileSystemType, unsigned long mountflags,
+    const void *data);
+
+int LfsUmount(const char *target);
+int LfsUnlink(const char *fileName);
+int LfsMkdir(const char *dirName, mode_t mode);
+int LfsRmdir(const char *dirName);
+DIR *LfsOpendir(const char *dirName);
+struct dirent *LfsReaddir(DIR *dir);
+int LfsClosedir(const DIR *dir);
+int LfsOpen(const char *pathName, int openFlag, int mode);
+int LfsRead(int fd, void *buf, unsigned int len);
+int LfsWrite(int fd, const void *buf, unsigned int len);
+int LfsSeek(int fd, off_t offset, int whence);
+int LfsClose(int fd);
+int LfsRename(const char *oldName, const char *newName);
+int LfsStat(const char *path, struct stat *buf);
+int LfsFsync(int fd);
+
+FileOpInfo GetFsOpInfo(void);
+const struct FsMap *MountFindfs(const char *filesystemtype);
+
+#endif /* _LFS_API_H_ */
+
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/cc.h b/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/cc.h
index 746bf9e..64e364f 100644
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/cc.h
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/cc.h
@@ -32,19 +32,42 @@
 #ifndef _LWIP_PORTING_CC_H_
 #define _LWIP_PORTING_CC_H_
 
+#ifdef LITTLE_ENDIAN
+#undef LITTLE_ENDIAN
+#endif
+
+#ifdef BIG_ENDIAN
+#undef BIG_ENDIAN
+#endif
+
+#include <endian.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include "securec.h"
-#include "log.h"
+#include "memory_pool.h"
 
 #ifdef htons
 #define LWIP_DONT_PROVIDE_BYTEORDER_FUNCTIONS
 #endif
 
-#define LWIP_PROVIDE_ERRNO 1
-#define __SIZEOF_POINTER__ 4   // 32位系统
+#define SOCKLEN_T_DEFINED
+#define SA_FAMILY_T_DEFINED
+#define IN_PORT_T_DEFINED
+
+#define LWIP_TIMEVAL_PRIVATE    0
+#define LWIP_ERRNO_STDINCLUDE
+#define LWIP_SOCKET_STDINCLUDE
+
+#define LWIP_DNS_API_DEFINE_ERRORS    0
+#define LWIP_DNS_API_DEFINE_FLAGS     0
+#define LWIP_DNS_API_DECLARE_STRUCTS  0
+#define LWIP_DNS_API_DECLARE_H_ERRNO  0
+
+#ifndef __SIZEOF_POINTER__
+#define __SIZEOF_POINTER__ 4   // 32 bit system
+#endif
 
-#define LOS_TASK_STATUS_DETACHED   0x0100  // 预留字段
+#define LOS_TASK_STATUS_DETACHED   0x0100  // reserved
 
 #if defined(__arm__) && defined(__ARMCC_VERSION)
     /* Keil uVision4 tools */
@@ -96,7 +119,6 @@ extern void HilogPrintf(const char *fmt, ...);
 #define init_waitqueue_head(...)
 #define poll_check_waiters(...)
 #define IOCTL_CMD_CASE_HANDLER()
-#define DF_NADDR(addr)
 
 #define DNS_SERVER_ADDRESS(ipaddr)        (ip4_addr_set_u32(ipaddr, ipaddr_addr("114.114.114.114")))
 #define DNS_SERVER_ADDRESS_SECONDARY(ipaddr)        (ip4_addr_set_u32(ipaddr, ipaddr_addr("114.114.115.115")))
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/sys_arch.h b/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/sys_arch.h
index 95f7f80..16b89d7 100644
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/sys_arch.h
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/sys_arch.h
@@ -33,8 +33,6 @@
 #define _LWIP_PORTING_SYS_ARCH_H_
 
 #include <stdint.h>
-#include "memory_pool.h"
-#include "los_mux.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/inet.h b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/inet.h
new file mode 100644
index 0000000..3a77c31
--- /dev/null
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/inet.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LWIP_PORTING_INET_H_
+#define _LWIP_PORTING_INET_H_
+
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include_next <lwip/inet.h>
+
+#if LWIP_IPV4
+#define inet_addr_from_ip4addr(target_inaddr, source_ipaddr) \
+            ((target_inaddr)->s_addr = ip4_addr_get_u32(source_ipaddr))
+#define inet_addr_to_ip4addr(target_ipaddr, source_inaddr) \
+            (ip4_addr_set_u32(target_ipaddr, (source_inaddr)->s_addr))
+
+/* directly map this to the lwip internal functions */
+#define inet_addr(cp)                   ipaddr_addr(cp)
+#define inet_aton(cp, addr)             ip4addr_aton(cp, (ip4_addr_t*)addr)
+#define inet_ntoa(addr)                 ip4addr_ntoa((const ip4_addr_t*)&(addr))
+#define inet_ntoa_r(addr, buf, buflen)  ip4addr_ntoa_r((const ip4_addr_t*)&(addr), buf, buflen)
+#endif /* LWIP_IPV4 */
+#if LWIP_IPV6
+#define inet6_addr_from_ip6addr(target_in6addr, source_ip6addr) \
+            {(target_in6addr)->s6_addr32[0] = (source_ip6addr)->addr[0]; \
+            (target_in6addr)->s6_addr32[1] = (source_ip6addr)->addr[1]; \
+            (target_in6addr)->s6_addr32[2] = (source_ip6addr)->addr[2]; \
+            (target_in6addr)->s6_addr32[3] = (source_ip6addr)->addr[3];}
+#define inet6_addr_to_ip6addr(target_ip6addr, source_in6addr) \
+            {(target_ip6addr)->addr[0] = (source_in6addr)->s6_addr32[0]; \
+            (target_ip6addr)->addr[1] = (source_in6addr)->s6_addr32[1]; \
+            (target_ip6addr)->addr[2] = (source_in6addr)->s6_addr32[2]; \
+            (target_ip6addr)->addr[3] = (source_in6addr)->s6_addr32[3]; \
+            ip6_addr_clear_zone(target_ip6addr);}
+#endif /* LWIP_IPV6 */
+
+#endif /* _LWIP_PORTING_INET_H_ */
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/lwipopts.h b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/lwipopts.h
index 7d07775..ab54f69 100644
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/lwipopts.h
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/lwipopts.h
@@ -134,8 +134,7 @@
 #define LWIP_NETIF_LOOPBACK             1
 #define LWIP_POSIX_SOCKETS_IO_NAMES     0
 #define LWIP_RAW                        1
-#define CONFIG_NFILE_DESCRIPTORS        1
-#define LWIP_SOCKET_OFFSET              CONFIG_NFILE_DESCRIPTORS
+#define LWIP_SOCKET_OFFSET              FAT_MAX_OPEN_FILES
 #define LWIP_SO_RCVBUF                  1
 #define LWIP_SO_RCVTIMEO                1
 #define LWIP_SO_SNDTIMEO                1
diff --git a/kernel/liteos_m/kal/cmsis/cmsis_liteos.c b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/netdb.h
similarity index 89%
rename from kernel/liteos_m/kal/cmsis/cmsis_liteos.c
rename to kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/netdb.h
index 0b745fc..aea2dbc 100644
--- a/kernel/liteos_m/kal/cmsis/cmsis_liteos.c
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/netdb.h
@@ -1,38 +1,38 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "los_config.h"
-
-#if (CMSIS_OS_VER == 1)
-#error "cmsis version 1.0 is not supported now!"
-#elif (CMSIS_OS_VER == 2)
-#include "cmsis_liteos2.c"
-#endif
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LWIP_PORTING_NETDB_H_
+#define _LWIP_PORTING_NETDB_H_
+
+#include <netdb.h>
+#include_next <lwip/netdb.h>
+
+#endif /* _LWIP_PORTING_NETDB_H_ */
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/netif.h b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/netif.h
index 421a5fb..1e57b76 100644
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/netif.h
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/netif.h
@@ -32,6 +32,9 @@
 #ifndef _LWIP_PORTING_NETIF_H_
 #define _LWIP_PORTING_NETIF_H_
 
+#include <net/if.h>
+#include <netinet/ip.h>
+
 #define netif_find netifapi_netif_find_by_name
 
 #if LWIP_DHCPS
@@ -39,12 +42,11 @@
                                             LWIP_NETIF_CLIENT_DATA_INDEX_DHCPS
 #endif
 
-#define LWIP_NETIF_FULLNAME 16
 #define linkoutput      linkoutput; \
                         void (*drv_send)(struct netif *netif, struct pbuf *p); \
                         u8_t (*drv_set_hwaddr)(struct netif *netif, u8_t *addr, u8_t len); \
                         void (*drv_config)(struct netif *netif, u32_t config_flags, u8_t setBit); \
-                        char full_name[LWIP_NETIF_FULLNAME]; \
+                        char full_name[IFNAMSIZ]; \
                         u16_t link_layer_type
 #include_next <lwip/netif.h>
 #undef linkoutput
@@ -52,7 +54,7 @@
 #undef LWIP_NETIF_CLIENT_DATA_INDEX_DHCP
 #endif
 
-#include <lwip/etharp.h> // For ETHARP_HWADDR_LEN, by `hieth-sf src/interface.c' and `wal/wal_net.c'
+#include <lwip/etharp.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -60,9 +62,9 @@ extern "C" {
 
 // redefine NETIF_NAMESIZE which was defined in netif.h
 #undef NETIF_NAMESIZE
-#define NETIF_NAMESIZE LWIP_NETIF_FULLNAME
+#define NETIF_NAMESIZE IFNAMSIZ
 
-#define LOOPBACK_IF         0 // 772
+#define LOOPBACK_IF         0
 #define ETHERNET_DRIVER_IF  1
 #define WIFI_DRIVER_IF      801
 #define BT_PROXY_IF         802
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/include/sys/socket.h b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/sockets.h
similarity index 56%
rename from kernel/liteos_m/components/net/lwip-2.1/porting/include/sys/socket.h
rename to kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/sockets.h
index c5f27a6..3ff2869 100644
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/include/sys/socket.h
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/sockets.h
@@ -1,79 +1,83 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef	_SYS_SOCKET_PORTING_H
-#define	_SYS_SOCKET_PORTING_H
-
-#include "lwip/sockets.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-int socket (int, int, int);
-
-int bind (int, const struct sockaddr *, socklen_t);
-int connect (int, const struct sockaddr *, socklen_t);
-int listen (int, int);
-int accept (int, struct sockaddr *__restrict, socklen_t *__restrict);
-
-int getsockname (int, struct sockaddr *__restrict, socklen_t *__restrict);
-int getpeername (int, struct sockaddr *__restrict, socklen_t *__restrict);
-
-ssize_t send (int, const void *, size_t, int);
-ssize_t recv (int, void *, size_t, int);
-ssize_t sendto (int, const void *, size_t, int, const struct sockaddr *, socklen_t);
-ssize_t recvfrom (int, void *__restrict, size_t, int, struct sockaddr *__restrict, socklen_t *__restrict);
-ssize_t sendmsg (int, const struct msghdr *, int);
-ssize_t recvmsg (int, struct msghdr *, int);
-
-int getsockopt (int, int, int, void *__restrict, socklen_t *__restrict);
-int setsockopt (int, int, int, const void *, socklen_t);
-
-const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
-int inet_pton(int af, const char *src, void *dst);
-
-int shutdown (int, int);
-int closesocket(int sockfd);
-
-int ioctlsocket(int s, long cmd, void *argp);
-
-#if LWIP_SOCKET_SELECT
-int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, struct timeval *timeout);
-#endif
-#if LWIP_SOCKET_POLL
-int poll(struct pollfd *fds, nfds_t nfds, int timeout);
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-#endif
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LWIP_PORTING_SOCKETS_H_
+#define _LWIP_PORTING_SOCKETS_H_
+
+#include <sys/socket.h>
+#include <poll.h>
+#include <netinet/tcp.h>
+#include <netinet/in.h>
+#include <sys/ioctl.h>
+#include <sys/select.h>
+#include <limits.h>
+#include <fcntl.h>
+#include_next <lwip/sockets.h>
+#include <fatfs.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if FD_SETSIZE < (LWIP_SOCKET_OFFSET + MEMP_NUM_NETCONN)
+#error "external FD_SETSIZE too small for number of sockets"
+#else
+#define LWIP_SELECT_MAXNFDS FD_SETSIZE
+#endif
+
+#if IOV_MAX > 0xFFFF
+#error "IOV_MAX larger than supported by LwIP"
+#endif
+
+#if LWIP_UDP && LWIP_UDPLITE
+#define UDPLITE_SEND_CSCOV 0x01 /* sender checksum coverage */
+#define UDPLITE_RECV_CSCOV 0x02 /* minimal receiver checksum coverage */
+#endif
+
+// For BSD 4.4 socket sa_len compatibility
+#define DF_NADDR(addr)
+#define SA_LEN(addr, _)  (IP_IS_V4_VAL(addr) ? sizeof(struct sockaddr_in) : sizeof(struct sockaddr_in6))
+#define sa_len sa_data[0] * 0 + SA_LEN(naddr, _)
+#define sin_len sin_zero[0]
+#define sin6_len sin6_addr.s6_addr[0]
+
+// for sockets.c, TCP_KEEPALIVE is not supported currently
+#define TCP_KEEPALIVE   0xFF
+#define SIN_ZERO_LEN    8
+
+int closesocket(int sockfd);
+int ioctlsocket(int s, long cmd, void *argp);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _LWIP_PORTING_SOCKETS_H_ */
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/src/netdb_porting.c b/kernel/liteos_m/components/net/lwip-2.1/porting/src/netdb_porting.c
index df905f7..804d7e0 100644
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/src/netdb_porting.c
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/src/netdb_porting.c
@@ -29,7 +29,7 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "netdb.h"
+#include "lwip/netdb.h"
 
 struct hostent *gethostbyname(const char *name)
 {
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/src/sys_arch.c b/kernel/liteos_m/components/net/lwip-2.1/porting/src/sys_arch.c
old mode 100755
new mode 100644
index f0c332d..82dadc4
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/src/sys_arch.c
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/src/sys_arch.c
@@ -38,7 +38,7 @@
 #include <los_sem.h>
 #include <los_mux.h>
 #include "cmsis_os2.h"
-#include <los_timer.h>
+#include <los_tick.h>
 #include <los_config.h>
 
 #ifndef LOSCFG_KERNEL_SMP
@@ -82,8 +82,7 @@ sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread, void *arg,
 void sys_init(void)
 {
     /* set rand seed to make random sequence diff on every startup */
-    UINT32 seedhsb, seedlsb;
-    HalGetCpuCycle(&seedhsb, &seedlsb);
+    UINT32 seedlsb = (UINT32)LOS_SysCycleGet();
     srand(seedlsb);
 }
 
diff --git a/kernel/liteos_m/config/target_config.h b/kernel/liteos_m/config/target_config.h
new file mode 100644
index 0000000..4b43564
--- /dev/null
+++ b/kernel/liteos_m/config/target_config.h
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**@defgroup los_config System configuration items
+ * @ingroup kernel
+ */
+
+#ifndef _TARGET_CONFIG_H_
+#define _TARGET_CONFIG_H_
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+//#include "sys_config.h"
+//#include "bk_los_timer.h"
+
+#define CMSIS_OS_VER                  2 
+
+#define LOS_TICK_UNIT_CLOCK                26000000 
+#define LOS_TICK_MS                        2
+#define LOS_TICKS_PER_SECOND              (1000UL/LOS_TICK_MS)
+
+/*=============================================================================
+ *System clock module configuration
+ *=============================================================================*/
+#define OS_SYS_CLOCK                                        (LOS_TICK_UNIT_CLOCK) 
+#define LOSCFG_BASE_CORE_TICK_PER_SECOND                    (LOS_TICKS_PER_SECOND)
+#define LOSCFG_BASE_CORE_TICK_HW_TIME                       0
+#define LOSCFG_BASE_CORE_TICK_WTIMER                        0
+#define LOSCFG_BASE_CORE_TICK_RESPONSE_MAX                  0xFFFFFFFF
+
+/*=============================================================================
+ *Hardware interrupt module configuration
+ *=============================================================================*/
+#define LOSCFG_PLATFORM_HWI                                 1
+#define LOSCFG_PLATFORM_HWI_LIMIT                           128
+
+/*=============================================================================
+ *Task module configuration
+ *=============================================================================*/
+#define LOSCFG_BASE_CORE_TSK_LIMIT                          30
+#define LOSCFG_BASE_CORE_TSK_IDLE_STACK_SIZE                (0x500U)
+#define LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE             (0x3D0U)
+
+/*scheduler occupies too much stack for every thread*/
+#define LOSCFG_BASE_CORE_TSK_MIN_STACK_SIZE                 (0x300U)
+#define LOSCFG_BASE_CORE_TIMESLICE                          1
+#define LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT                  20000
+
+/*=============================================================================
+ *Semaphore module configuration
+ *=============================================================================*/
+#define LOSCFG_BASE_IPC_SEM                                 1
+#define LOSCFG_BASE_IPC_SEM_LIMIT                           32
+
+/*=============================================================================
+ *Mutex module configuration
+ *=============================================================================*/
+#define LOSCFG_BASE_IPC_MUX                                 1
+#define LOSCFG_BASE_IPC_MUX_LIMIT                           32
+
+/*=============================================================================
+ *Queue module configuration
+ *=============================================================================*/
+#define LOSCFG_BASE_IPC_QUEUE                               1
+#define LOSCFG_BASE_IPC_QUEUE_LIMIT                         32
+
+/*=============================================================================
+ *Software timer module configuration
+ *=============================================================================*/
+#define LOSCFG_BASE_CORE_SWTMR                              1
+#define LOSCFG_BASE_CORE_SWTMR_ALIGN                        1
+#define LOSCFG_BASE_CORE_SWTMR_LIMIT                        32
+
+/*=============================================================================
+ *Memory module configuration
+ *=============================================================================*/
+#define LOSCFG_SYS_EXTERNAL_HEAP                            1
+#define OS_SYS_MEM_SIZE                                     0x0001000
+#define LOSCFG_BASE_MEM_NODE_INTEGRITY_CHECK                1
+#define LOSCFG_BASE_MEM_NODE_SIZE_CHECK                     1
+
+#define LOSCFG_MEM_MUL_POOL                                 0
+
+#define OS_SYS_MEM_NUM                                      20
+#define LOSCFG_KERNEL_MEM_SLAB                              0
+/*=============================================================================
+ *Exception module configuration
+ *=============================================================================*/
+#define LOSCFG_PLATFORM_EXC                                 0
+
+extern void uart_putc(char c);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+
+#endif /* _TARGET_CONFIG_H */
diff --git "a/kernel/liteos_m/figures/OpenHarmony-LiteOS-M\346\240\270\345\206\205\346\240\270\346\236\266\346\236\204\345\233\276.png" "b/kernel/liteos_m/figures/OpenHarmony-LiteOS-M\342\225\221\342\225\246\342\224\200\342\224\214\342\225\221\342\225\246\342\225\235\342\226\204\342\225\243\342\225\243\342\225\220\342\225\235.png"
similarity index 100%
rename from "kernel/liteos_m/figures/OpenHarmony-LiteOS-M\346\240\270\345\206\205\346\240\270\346\236\266\346\236\204\345\233\276.png"
rename to "kernel/liteos_m/figures/OpenHarmony-LiteOS-M\342\225\221\342\225\246\342\224\200\342\224\214\342\225\221\342\225\246\342\225\235\342\226\204\342\225\243\342\225\243\342\225\220\342\225\235.png"
diff --git a/kernel/liteos_m/kal/BUILD.gn b/kernel/liteos_m/kal/BUILD.gn
index 05c2d2a..97dc738 100644
--- a/kernel/liteos_m/kal/BUILD.gn
+++ b/kernel/liteos_m/kal/BUILD.gn
@@ -27,29 +27,21 @@
 # OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 # ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+import("//build/lite/config/component/lite_component.gni")
+
 declare_args() {
   enable_ohos_kernel_liteos_m_cmsis = true
   enable_ohos_kernel_liteos_m_posix = true
 }
 
-static_library("kal") {
-  sources = [ "kal.c" ]
-
-  include_dirs = [
-    "../kernel/arch/include",
-    "../kernel/include",
-    "../utils",
-    "../kal/cmsis",
-    "../kal",
-  ]
-
-  deps = []
+lite_component("kal") {
+  features = []
 
   if (enable_ohos_kernel_liteos_m_cmsis == true) {
-    deps += [ "cmsis/" ]
+    features += [ "cmsis" ]
   }
 
   if (enable_ohos_kernel_liteos_m_posix == true) {
-    deps += [ "posix/" ]
+    features += [ "posix" ]
   }
 }
diff --git a/kernel/liteos_m/kal/cmsis/BUILD.gn b/kernel/liteos_m/kal/cmsis/BUILD.gn
index 7cb21e4..5636b07 100644
--- a/kernel/liteos_m/kal/cmsis/BUILD.gn
+++ b/kernel/liteos_m/kal/cmsis/BUILD.gn
@@ -28,14 +28,6 @@
 # ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 static_library("cmsis") {
-  sources = [ "cmsis_liteos.c" ]
+  sources = [ "cmsis_liteos2.c" ]
 
-  include_dirs = [
-    "//third_party/bounds_checking_function/include",
-    "../../kernel/include",
-    "../../kernel/arch/include",
-    "../../utils",
-    "../../kal/cmsis",
-    "../../kal",
-  ]
 }
diff --git a/kernel/liteos_m/kal/cmsis/LICENSE.txt b/kernel/liteos_m/kal/cmsis/LICENSE.txt
deleted file mode 100644
index 8dada3e..0000000
--- a/kernel/liteos_m/kal/cmsis/LICENSE.txt
+++ /dev/null
@@ -1,201 +0,0 @@
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "{}"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright {yyyy} {name of copyright owner}
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
diff --git a/kernel/liteos_m/kal/cmsis/README.OpenSource b/kernel/liteos_m/kal/cmsis/README.OpenSource
deleted file mode 100644
index c05284e..0000000
--- a/kernel/liteos_m/kal/cmsis/README.OpenSource
+++ /dev/null
@@ -1,11 +0,0 @@
-[
-    {
-        "Name"                  : "CMSIS",
-        "License"               : "Apache License V2.0",
-        "License File"          : "LICENSE.txt",
-        "Version Number"        : "5.7.0",
-        "Owner"                 : "denny.shenwei@huawei.com",
-        "Upstream URL"          : "http://www.arm.com/zh/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php",
-        "Description"           : "The Cortex Microcontroller Software Interface Standard (CMSIS) is a vendor-independent hardware abstraction layer for microcontrollers that are based on Arm® Cortex® processors"
-    }
-]
diff --git a/kernel/liteos_m/kal/cmsis/cmsis_liteos2.c b/kernel/liteos_m/kal/cmsis/cmsis_liteos2.c
old mode 100755
new mode 100644
index c37552a..3553086
--- a/kernel/liteos_m/kal/cmsis/cmsis_liteos2.c
+++ b/kernel/liteos_m/kal/cmsis/cmsis_liteos2.c
@@ -28,8 +28,8 @@
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-#include "cmsis_os.h"
+#include "cmsis_os2.h"
+#include "kal.h"
 #include "los_event.h"
 #include "los_membox.h"
 #include "los_memory.h"
@@ -40,25 +40,23 @@
 #include "los_swtmr.h"
 #include "los_task.h"
 #include "los_timer.h"
-#include "kal.h"
 #include "los_debug.h"
 
 #include "string.h"
 #include "securec.h"
-
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
-#if (CMSIS_OS_VER == 2)
+#define LOS_PRIORITY_WIN 8
 
 /* Kernel initialization state */
 static osKernelState_t g_kernelState;
 
 extern BOOL g_taskScheduled;
 
-#define LOS_PRIORITY_WIN 8
+/* LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO <---> osPriorityNormal */
+#define LOS_PRIORITY(cmsisPriority) (LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO - ((cmsisPriority) - osPriorityNormal))
+#define CMSIS_PRIORITY(losPriority) (osPriorityNormal + (LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO - (losPriority)))
+
+/* OS_TASK_PRIORITY_HIGHEST and OS_TASK_PRIORITY_LOWEST is reserved for internal TIMER and IDLE task use only. */
+#define ISVALID_LOS_PRIORITY(losPrio) ((losPrio) > OS_TASK_PRIORITY_HIGHEST && (losPrio) < OS_TASK_PRIORITY_LOWEST)
 
 const osVersion_t g_stLosVersion = { 001, 001 };
 
@@ -74,8 +72,6 @@ const osVersion_t g_stLosVersion = { 001, 001 };
 #define KERNEL_ID "HUAWEI-LiteOS"
 
 //  ==== Kernel Management Functions ====
-uint32_t osTaskStackWaterMarkGet(UINT32 taskID);
-
 
 osStatus_t osKernelInitialize(void)
 {
@@ -242,25 +238,7 @@ int32_t osKernelRestoreLock(int32_t lock)
 
 uint32_t osKernelGetTickCount(void)
 {
-    uint64_t ticks;
-    UINTPTR uvIntSave;
-
-    if (OS_INT_ACTIVE) {
-#ifndef LITEOS_WIFI_IOT_VERSION
-        ticks = g_ullTickCount;
-#else
-        ticks = g_tickCount;
-#endif
-    } else {
-        uvIntSave = LOS_IntLock();
-#ifndef LITEOS_WIFI_IOT_VERSION
-        ticks = g_ullTickCount;
-#else
-        ticks = g_tickCount;
-#endif
-        LOS_IntRestore(uvIntSave);
-    }
-
+    uint64_t ticks = LOS_TickCountGet();
     return (uint32_t)ticks;
 }
 
@@ -279,12 +257,11 @@ uint32_t osKernelGetTickFreq(void)
 
 uint32_t osKernelGetSysTimerCount(void)
 {
-    uint32_t countHigh = 0;
     uint32_t countLow = 0;
     if (OS_INT_ACTIVE) {
         countLow = 0U;
     } else {
-        HalGetCpuCycle((UINT32 *)&countHigh, (UINT32 *)&countLow);
+        countLow = (UINT32)LOS_SysCycleGet();
     }
     return countLow;
 }
@@ -316,11 +293,7 @@ osThreadId_t osThreadNew(osThreadFunc_t func, void *argument, const osThreadAttr
 
     (void)memset_s(&stTskInitParam, sizeof(TSK_INIT_PARAM_S), 0, sizeof(TSK_INIT_PARAM_S));
     stTskInitParam.pfnTaskEntry = (TSK_ENTRY_FUNC)func;
-#ifndef LITEOS_WIFI_IOT_VERSION
     stTskInitParam.uwArg = (UINT32)argument;
-#else
-    stTskInitParam.auwArgs[0] = (UINT32)argument;
-#endif
     stTskInitParam.uwStackSize = attr->stack_size;
     stTskInitParam.pcName = (CHAR *)attr->name;
     stTskInitParam.usTaskPrio = OS_TASK_PRIORITY_LOWEST - ((UINT16)(attr->priority) - LOS_PRIORITY_WIN); /* 0~31 */
@@ -336,7 +309,6 @@ osThreadId_t osThreadNew(osThreadFunc_t func, void *argument, const osThreadAttr
     return (osThreadId_t)pstTaskCB;
 }
 
-
 const char *osThreadGetName(osThreadId_t thread_id)
 {
     LosTaskCB *pstTaskCB = NULL;
@@ -370,11 +342,7 @@ void *osThreadGetArgument(void)
     if (taskCb == NULL) {
         return NULL;
     }
-#ifndef LITEOS_WIFI_IOT_VERSION
     return (void *)(taskCb->arg);
-#else
-    return (void *)(taskCb->args[0]);
-#endif
 }
 
 osThreadState_t osThreadGetState(osThreadId_t thread_id)
@@ -395,7 +363,7 @@ osThreadState_t osThreadGetState(osThreadId_t thread_id)
     } else if (taskStatus & OS_TASK_STATUS_READY) {
         stState = osThreadReady;
     } else if (taskStatus &
-        (OS_TASK_STATUS_DELAY | OS_TASK_STATUS_PEND | OS_TASK_STATUS_SUSPEND | OS_TASK_STATUS_PEND_QUEUE)) {
+        (OS_TASK_STATUS_DELAY | OS_TASK_STATUS_PEND | OS_TASK_STATUS_SUSPEND)) {
         stState = osThreadBlocked;
     } else if (taskStatus & OS_TASK_STATUS_UNUSED) {
         stState = osThreadInactive;
@@ -425,18 +393,18 @@ uint32_t osTaskStackWaterMarkGet(UINT32 taskID)
 {
     UINT32 uwCount = 0;
     UINT32 *ptopOfStack;
-    UINTPTR uvIntSave;
+    UINT32 intSave = 0;
     LosTaskCB *pstTaskCB = NULL;
 
     if (taskID > LOSCFG_BASE_CORE_TSK_LIMIT) {
         return 0;
     }
 
-    uvIntSave = LOS_IntLock();
+    intSave = LOS_IntLock();
 
     pstTaskCB = OS_TCB_FROM_TID(taskID);
     if (OS_TASK_STATUS_UNUSED & (pstTaskCB->taskStatus)) {
-        LOS_IntRestore(uvIntSave);
+        LOS_IntRestore(intSave);
         return 0;
     }
 
@@ -450,7 +418,7 @@ uint32_t osTaskStackWaterMarkGet(UINT32 taskID)
 
     uwCount *= sizeof(UINT32);
 
-    LOS_IntRestore(uvIntSave);
+    LOS_IntRestore(intSave);
     return uwCount;
 }
 
@@ -483,12 +451,12 @@ osStatus_t osThreadSetPriority(osThreadId_t thread_id, osPriority_t priority)
         return osErrorParameter;
     }
 
-    if (priority < osPriorityLow1 || priority > osPriorityAboveNormal6) {
+    usPriority = LOS_PRIORITY(priority);
+    if (!ISVALID_LOS_PRIORITY(usPriority)) {
         return osErrorParameter;
     }
 
     pstTaskCB = (LosTaskCB *)thread_id;
-    usPriority = OS_TASK_PRIORITY_LOWEST - ((UINT16)priority - LOS_PRIORITY_WIN);
     uwRet = LOS_TaskPriSet(pstTaskCB->taskID, usPriority);
     switch (uwRet) {
         case LOS_ERRNO_TSK_PRIOR_ERROR:
@@ -521,7 +489,7 @@ osPriority_t osThreadGetPriority(osThreadId_t thread_id)
         return osPriorityError;
     }
 
-    return (osPriority_t)(OS_TASK_PRIORITY_LOWEST - (usRet - LOS_PRIORITY_WIN));
+    return (osPriority_t)CMSIS_PRIORITY(usRet);
 }
 
 
@@ -654,6 +622,13 @@ uint32_t osThreadGetCount(void)
 }
 
 
+void osThreadExit(void)
+{
+    (void)LOS_TaskDelete(LOS_CurTaskIDGet());
+    UNREACHABLE;
+}
+
+
 osStatus_t osDelay(uint32_t ticks)
 {
     UINT32 uwRet = LOS_OK;
@@ -661,7 +636,7 @@ osStatus_t osDelay(uint32_t ticks)
         return osOK;
     }
     if (osKernelGetState() != osKernelRunning) {
-        HalDelay(ticks);
+        LOS_UDelay(ticks * OS_US_PER_TICK);
     } else {
         uwRet = LOS_TaskDelay(ticks);
     }
@@ -724,6 +699,34 @@ osTimerId_t osTimerNew(osTimerFunc_t func, osTimerType_t type, void *argument, c
     return (osTimerId_t)OS_SWT_FROM_SID(usSwTmrID);
 }
 
+
+#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
+osTimerId_t osTimerExtNew(osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr,
+    osTimerRouses_t ucRouses, osTimerAlign_t ucSensitive)
+{
+    UNUSED(attr);
+    UINT32 usSwTmrID;
+    UINT8 mode;
+
+    if ((OS_INT_ACTIVE) || (NULL == func) || ((osTimerOnce != type) && (osTimerPeriodic != type))) {
+        return (osTimerId_t)NULL;
+    }
+
+    if (osTimerOnce == type) {
+        mode = LOS_SWTMR_MODE_NO_SELFDELETE;
+    } else {
+        mode = LOS_SWTMR_MODE_PERIOD;
+    }
+    if (LOS_OK != LOS_SwtmrCreate(1, mode, (SWTMR_PROC_FUNC)func, &usSwTmrID,
+        (UINT32)(UINTPTR)argument, ucRouses, ucSensitive)) {
+        return (osTimerId_t)NULL;
+    }
+
+    return (osTimerId_t)OS_SWT_FROM_SID(usSwTmrID);
+}
+#endif
+
+
 osStatus_t osTimerStart(osTimerId_t timer_id, uint32_t ticks)
 {
     UINT32 uwRet;
@@ -733,7 +736,7 @@ osStatus_t osTimerStart(osTimerId_t timer_id, uint32_t ticks)
         return osErrorParameter;
     }
 
-    UINTPTR intSave = LOS_IntLock();
+    UINT32 intSave = LOS_IntLock();
     pstSwtmr = (SWTMR_CTRL_S *)timer_id;
     pstSwtmr->uwInterval = ticks;
     uwRet = LOS_SwtmrStart(pstSwtmr->usTimerID);
@@ -863,7 +866,7 @@ uint32_t osEventFlagsSet(osEventFlagsId_t ef_id, uint32_t flags)
 uint32_t osEventFlagsClear(osEventFlagsId_t ef_id, uint32_t flags)
 {
     PEVENT_CB_S pstEventCB = (PEVENT_CB_S)ef_id;
-    UINTPTR uwIntSave;
+    UINT32 intSave = 0;
     uint32_t rflags;
     UINT32 uwRet;
 
@@ -871,11 +874,11 @@ uint32_t osEventFlagsClear(osEventFlagsId_t ef_id, uint32_t flags)
         return (uint32_t)osFlagsErrorParameter;
     }
 
-    uwIntSave = LOS_IntLock();
+    intSave = LOS_IntLock();
     rflags = pstEventCB->uwEventID;
 
     uwRet = LOS_EventClear(pstEventCB, ~flags);
-    LOS_IntRestore(uwIntSave);
+    LOS_IntRestore(intSave);
     if (uwRet != LOS_OK) {
         return (uint32_t)osFlagsErrorParameter;
     } else {
@@ -887,16 +890,16 @@ uint32_t osEventFlagsClear(osEventFlagsId_t ef_id, uint32_t flags)
 uint32_t osEventFlagsGet(osEventFlagsId_t ef_id)
 {
     PEVENT_CB_S pstEventCB = (PEVENT_CB_S)ef_id;
-    UINTPTR uwIntSave;
+    UINT32 intSave = 0;
     uint32_t rflags;
 
     if (pstEventCB == NULL) {
-        return (uint32_t)osFlagsErrorParameter;
+        return (UINT32) osFlagsErrorParameter;
     }
 
-    uwIntSave = LOS_IntLock();
+    intSave = LOS_IntLock();
     rflags = pstEventCB->uwEventID;
-    LOS_IntRestore(uwIntSave);
+    LOS_IntRestore(intSave);
 
     return rflags;
 }
@@ -948,16 +951,16 @@ uint32_t osEventFlagsWait(osEventFlagsId_t ef_id, uint32_t flags, uint32_t optio
 osStatus_t osEventFlagsDelete(osEventFlagsId_t ef_id)
 {
     PEVENT_CB_S pstEventCB = (PEVENT_CB_S)ef_id;
-    UINTPTR uwIntSave;
+    UINT32 intSave = 0;
     osStatus_t uwRet;
 
-    uwIntSave = LOS_IntLock();
+    intSave = LOS_IntLock();
     if (LOS_EventDestroy(pstEventCB) == LOS_OK) {
         uwRet = osOK;
     } else {
         uwRet = osErrorParameter;
     }
-    LOS_IntRestore(uwIntSave);
+    LOS_IntRestore(intSave);
 
     if (LOS_MemFree(m_aucSysMem0, (void *)pstEventCB) == LOS_OK) {
         uwRet = osOK;
@@ -1034,7 +1037,7 @@ osStatus_t osMutexRelease(osMutexId_t mutex_id)
 
 osThreadId_t osMutexGetOwner(osMutexId_t mutex_id)
 {
-    UINT32 uwIntSave;
+    UINT32 intSave = 0;
     LosTaskCB *pstTaskCB;
 
     if (OS_INT_ACTIVE) {
@@ -1045,9 +1048,9 @@ osThreadId_t osMutexGetOwner(osMutexId_t mutex_id)
         return NULL;
     }
 
-    uwIntSave = LOS_IntLock();
+    intSave = LOS_IntLock();
     pstTaskCB = ((LosMuxCB *)mutex_id)->owner;
-    LOS_IntRestore(uwIntSave);
+    LOS_IntRestore(intSave);
 
     return (osThreadId_t)pstTaskCB;
 }
@@ -1152,7 +1155,7 @@ osStatus_t osSemaphoreRelease(osSemaphoreId_t semaphore_id)
 
 uint32_t osSemaphoreGetCount(osSemaphoreId_t semaphore_id)
 {
-    UINT32 uwIntSave;
+    UINT32 intSave = 0;
     UINT32 uwCount;
 
     if (OS_INT_ACTIVE) {
@@ -1163,9 +1166,9 @@ uint32_t osSemaphoreGetCount(osSemaphoreId_t semaphore_id)
         return 0;
     }
 
-    uwIntSave = LOS_IntLock();
+    intSave = LOS_IntLock();
     uwCount = ((LosSemCB *)semaphore_id)->semCount;
-    LOS_IntRestore(uwIntSave);
+    LOS_IntRestore(intSave);
 
     return uwCount;
 }
@@ -1302,15 +1305,15 @@ uint32_t osMessageQueueGetMsgSize(osMessageQueueId_t mq_id)
 uint32_t osMessageQueueGetCount(osMessageQueueId_t mq_id)
 {
     uint32_t count;
-    UINTPTR uwIntSave;
+    UINT32 intSave = 0;
     LosQueueCB *pstQueue = (LosQueueCB *)mq_id;
 
     if (pstQueue == NULL) {
         count = 0U;
     } else {
-        uwIntSave = LOS_IntLock();
+        intSave = LOS_IntLock();
         count = (uint32_t)(pstQueue->readWriteableCnt[OS_QUEUE_READ]);
-        LOS_IntRestore(uwIntSave);
+        LOS_IntRestore(intSave);
     }
     return count;
 }
@@ -1319,15 +1322,15 @@ uint32_t osMessageQueueGetCount(osMessageQueueId_t mq_id)
 uint32_t osMessageQueueGetSpace(osMessageQueueId_t mq_id)
 {
     uint32_t space;
-    UINTPTR uwIntSave;
+    UINT32 intSave = 0;
     LosQueueCB *pstQueue = (LosQueueCB *)mq_id;
 
     if (pstQueue == NULL) {
         space = 0U;
     } else {
-        uwIntSave = LOS_IntLock();
+        intSave = LOS_IntLock();
         space = (uint32_t)pstQueue->readWriteableCnt[OS_QUEUE_WRITE];
-        LOS_IntRestore(uwIntSave);
+        LOS_IntRestore(intSave);
     }
     return space;
 }
@@ -1354,12 +1357,9 @@ osStatus_t osMessageQueueDelete(osMessageQueueId_t mq_id)
         return osErrorResource;
     }
 }
-void osThreadExit(void)
-{
-    return;
-}
 #endif
 
+
 #define MP_ALLOC        1U
 #define MD_ALLOC        2U
 #define MEM_POOL_VALID  0xFFEEFF00
@@ -1449,7 +1449,7 @@ void *osMemoryPoolAlloc(osMemoryPoolId_t mp_id, uint32_t timeout)
 {
     MemPoolCB *mp = (MemPoolCB *)mp_id;
     LOS_MEMBOX_NODE *node = NULL;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
 
     UNUSED(timeout);
 
@@ -1476,7 +1476,7 @@ osStatus_t osMemoryPoolFree(osMemoryPoolId_t mp_id, void *block)
     MemPoolCB *mp = (MemPoolCB *)mp_id;
     LOS_MEMBOX_NODE *node = NULL;
     LOS_MEMBOX_NODE *nodeTmp = NULL;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
 
     if ((mp_id == NULL) || (block == NULL)) {
         return osErrorParameter;
@@ -1507,7 +1507,7 @@ osStatus_t osMemoryPoolFree(osMemoryPoolId_t mp_id, void *block)
 osStatus_t osMemoryPoolDelete(osMemoryPoolId_t mp_id)
 {
     MemPoolCB *mp = (MemPoolCB *)mp_id;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
 
     if (OS_INT_ACTIVE) {
         return osErrorISR;
@@ -1542,7 +1542,7 @@ osStatus_t osMemoryPoolDelete(osMemoryPoolId_t mp_id)
 uint32_t osMemoryPoolGetCapacity(osMemoryPoolId_t mp_id)
 {
     MemPoolCB *mp = (MemPoolCB *)mp_id;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     uint32_t num;
 
     if (mp_id == NULL) {
@@ -1563,7 +1563,7 @@ uint32_t osMemoryPoolGetCapacity(osMemoryPoolId_t mp_id)
 uint32_t osMemoryPoolGetBlockSize(osMemoryPoolId_t mp_id)
 {
     MemPoolCB *mp = (MemPoolCB *)mp_id;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     uint32_t size;
 
     if (mp_id == NULL) {
@@ -1584,7 +1584,7 @@ uint32_t osMemoryPoolGetBlockSize(osMemoryPoolId_t mp_id)
 uint32_t osMemoryPoolGetCount(osMemoryPoolId_t mp_id)
 {
     MemPoolCB *mp = (MemPoolCB *)mp_id;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     uint32_t count;
 
     if (mp_id == NULL) {
@@ -1605,7 +1605,7 @@ uint32_t osMemoryPoolGetCount(osMemoryPoolId_t mp_id)
 uint32_t osMemoryPoolGetSpace(osMemoryPoolId_t mp_id)
 {
     MemPoolCB *mp = (MemPoolCB *)mp_id;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     uint32_t space;
 
     if (mp_id == NULL) {
@@ -1628,7 +1628,7 @@ const char *osMemoryPoolGetName(osMemoryPoolId_t mp_id)
 {
     MemPoolCB *mp = (MemPoolCB *)mp_id;
     const char *p = NULL;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
 
     if (mp_id == NULL) {
         return NULL;
@@ -1646,10 +1646,3 @@ const char *osMemoryPoolGetName(osMemoryPoolId_t mp_id)
 
     return p;
 }
-
-#endif // (CMSIS_OS_VER == 2)
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/kal/kal.h b/kernel/liteos_m/kal/cmsis/kal.h
old mode 100755
new mode 100644
similarity index 96%
rename from kernel/liteos_m/kal/kal.h
rename to kernel/liteos_m/kal/cmsis/kal.h
index 2dbcd1e..8940e33
--- a/kernel/liteos_m/kal/kal.h
+++ b/kernel/liteos_m/kal/cmsis/kal.h
@@ -1,79 +1,79 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _KAL_H
-#define _KAL_H
-
-#include "los_config.h"
-#include "los_compiler.h"
-#include "cmsis_os2.h"
-
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
-
-#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
-/**
-* @brief Enumerates timer permissions.
-*
-* @since 1.0
-* @version 1.0
-*/
-typedef enum  {
-  /** The timer is not allowed to wake up the RTOS. */
-  osTimerRousesIgnore       =     0,
-  /** The timer is allowed to wake up the RTOS. */
-  osTimerRousesAllow        =     1
-} osTimerRouses_t;
-
-/**
-* @brief Enumerates timer alignment modes.
-*
-*/
-typedef enum  {
-  /** The timer ignores alignment. */
-  osTimerAlignIgnore        =     0,
-  /** The timer allows alignment. */
-  osTimerAlignAllow         =     1
-} osTimerAlign_t;
-
-osTimerId_t osTimerExtNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr,
-                           osTimerRouses_t ucRouses, osTimerAlign_t ucSensitive);
-#endif
-
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _KAL_H
+#define _KAL_H
+
+#include "los_config.h"
+#include "los_compiler.h"
+#include "cmsis_os2.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
+/**
+* @brief Enumerates timer permissions.
+*
+* @since 1.0
+* @version 1.0
+*/
+typedef enum  {
+  /** The timer is not allowed to wake up the RTOS. */
+  osTimerRousesIgnore       =     0,
+  /** The timer is allowed to wake up the RTOS. */
+  osTimerRousesAllow        =     1
+} osTimerRouses_t;
+
+/**
+* @brief Enumerates timer alignment modes.
+*
+*/
+typedef enum  {
+  /** The timer ignores alignment. */
+  osTimerAlignIgnore        =     0,
+  /** The timer allows alignment. */
+  osTimerAlignAllow         =     1
+} osTimerAlign_t;
+
+osTimerId_t osTimerExtNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr,
+                           osTimerRouses_t ucRouses, osTimerAlign_t ucSensitive);
+#endif
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
 #endif /* _KAL_H */
\ No newline at end of file
diff --git a/kernel/liteos_m/kal/posix/BUILD.gn b/kernel/liteos_m/kal/posix/BUILD.gn
index aaacb08..1fd65b2 100644
--- a/kernel/liteos_m/kal/posix/BUILD.gn
+++ b/kernel/liteos_m/kal/posix/BUILD.gn
@@ -27,6 +27,10 @@
 # OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 # ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+declare_args() {
+  SDK_BASE = "../../../.."
+}
+
 static_library("posix") {
   sources = [
     "src/errno.c",
@@ -34,16 +38,30 @@ static_library("posix") {
     "src/malloc.c",
     "src/pthread.c",
     "src/pthread_attr.c",
+    "src/pthread_cond.c",
     "src/pthread_mutex.c",
     "src/semaphore.c",
     "src/time.c",
   ]
 
   include_dirs = [
-    "include",
-    "../../kernel/arch/include",
+    "//third_party/bounds_checking_function/include",
     "../../kernel/include",
+    "../../kernel/arch/include",
+    "../../kernel/arch/arm/arm9/gcc",
+    "../../config",
     "../../utils",
-    "//third_party/bounds_checking_function/include",
+    "../../port",
+    "../../targets/bk72xx",
+    
+    "${SDK_BASE}/config",
+    "${SDK_BASE}/beken378/release",
+    "${SDK_BASE}/beken378/common",
+    "${SDK_BASE}/beken378/driver/include",
+    "${SDK_BASE}/beken378/driver/common",
+    "${SDK_BASE}/beken378/driver/entry",
+    "${SDK_BASE}/beken378/ip/common",
+    
+    "include",
   ]
 }
diff --git a/kernel/liteos_m/kal/posix/include/bits/alltypes.h b/kernel/liteos_m/kal/posix/include/bits/alltypes.h
old mode 100755
new mode 100644
diff --git a/kernel/liteos_m/kal/posix/include/limits.h b/kernel/liteos_m/kal/posix/include/limits.h
index b71daa3..eefb247 100644
--- a/kernel/liteos_m/kal/posix/include/limits.h
+++ b/kernel/liteos_m/kal/posix/include/limits.h
@@ -1,10 +1,14 @@
 #ifndef _LIMITS_H
 #define _LIMITS_H
 
+#include "los_config.h"
+
 #ifdef __ICCARM__ /* for iar */
 #define PATH_MAX 256
 #define MQ_PRIO_MAX 1
 #define PTHREAD_STACK_MIN LOSCFG_BASE_CORE_TSK_MIN_STACK_SIZE
+#define IOV_MAX 1024
+#define SSIZE_MAX LONG_MAX
 #include_next <limits.h>
 #else
 
@@ -73,9 +77,9 @@
 #define PTHREAD_KEYS_MAX 128
 #define PTHREAD_STACK_MIN LOSCFG_BASE_CORE_TSK_MIN_STACK_SIZE
 #define PTHREAD_DESTRUCTOR_ITERATIONS 4
-#define SEM_VALUE_MAX 0x7fffffff
-#define SEM_NSEMS_MAX 256
-#define DELAYTIMER_MAX 0x7fffffff
+#define SEM_VALUE_MAX OS_SEM_COUNTING_MAX_COUNT
+#define SEM_NSEMS_MAX LOSCFG_BASE_IPC_SEM_LIMIT
+#define DELAYTIMER_MAX 32
 #define MQ_PRIO_MAX 1
 #define LOGIN_NAME_MAX 256
 
diff --git a/kernel/liteos_m/kal/posix/include/signal.h b/kernel/liteos_m/kal/posix/include/signal.h
old mode 100755
new mode 100644
diff --git a/kernel/liteos_m/kal/posix/include/sys/resource.h b/kernel/liteos_m/kal/posix/include/sys/resource.h
index 3068328..dc5f52d 100644
--- a/kernel/liteos_m/kal/posix/include/sys/resource.h
+++ b/kernel/liteos_m/kal/posix/include/sys/resource.h
@@ -27,7 +27,7 @@ struct rlimit {
 struct rusage {
 	struct timeval ru_utime;
 	struct timeval ru_stime;
-	/* linux extentions, but useful */
+	/* linux extensions, but useful */
 	long	ru_maxrss;
 	long	ru_ixrss;
 	long	ru_idrss;
diff --git a/kernel/liteos_m/kal/posix/include/wchar.h b/kernel/liteos_m/kal/posix/include/wchar.h
index 6369f11..f1068f2 100644
--- a/kernel/liteos_m/kal/posix/include/wchar.h
+++ b/kernel/liteos_m/kal/posix/include/wchar.h
@@ -17,8 +17,10 @@ extern "C" {
 #define __NEED_wchar_t
 #define __NEED_wint_t
 #define __NEED_mbstate_t
+#define __NEED_off_t
 
 #if __STDC_VERSION__ < 201112L
+#define __NEED_off_t
 #define __NEED_struct__IO_FILE
 #endif
 
diff --git a/kernel/liteos_m/kal/posix/musl_src/exit/assert.c b/kernel/liteos_m/kal/posix/musl_src/exit/assert.c
index 828810e..fb7d5c0 100644
--- a/kernel/liteos_m/kal/posix/musl_src/exit/assert.c
+++ b/kernel/liteos_m/kal/posix/musl_src/exit/assert.c
@@ -2,9 +2,6 @@
 #include "los_context.h"
 #include "los_debug.h"
 
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
 
 void __assert(const char* file, int line, const char* expr) {
   PRINT_ERR("__assert error: %s, %d, %s\n", file, line, expr);
@@ -23,7 +20,3 @@ void __assert_fail(const char* expr, const char* file, int line, const char* fun
   LOS_Panic("__assert error:\n");
   while (1);
 }
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
\ No newline at end of file
diff --git a/kernel/liteos_m/kal/posix/musl_src/internal/atomic.h b/kernel/liteos_m/kal/posix/musl_src/internal/atomic.h
new file mode 100644
index 0000000..f938879
--- /dev/null
+++ b/kernel/liteos_m/kal/posix/musl_src/internal/atomic.h
@@ -0,0 +1,318 @@
+#ifndef _ATOMIC_H
+#define _ATOMIC_H
+
+#include <stdint.h>
+
+#include "atomic_arch.h"
+
+#ifdef a_ll
+
+#ifndef a_pre_llsc
+#define a_pre_llsc()
+#endif
+
+#ifndef a_post_llsc
+#define a_post_llsc()
+#endif
+
+#ifndef a_cas
+#define a_cas a_cas
+static inline int a_cas(volatile int *p, int t, int s)
+{
+	int old;
+	a_pre_llsc();
+	do old = a_ll(p);
+	while (old==t && !a_sc(p, s));
+	a_post_llsc();
+	return old;
+}
+#endif
+
+#ifndef a_swap
+#define a_swap a_swap
+static inline int a_swap(volatile int *p, int v)
+{
+	int old;
+	a_pre_llsc();
+	do old = a_ll(p);
+	while (!a_sc(p, v));
+	a_post_llsc();
+	return old;
+}
+#endif
+
+#ifndef a_fetch_add
+#define a_fetch_add a_fetch_add
+static inline int a_fetch_add(volatile int *p, int v)
+{
+	int old;
+	a_pre_llsc();
+	do old = a_ll(p);
+	while (!a_sc(p, (unsigned)old + v));
+	a_post_llsc();
+	return old;
+}
+#endif
+
+#ifndef a_fetch_and
+#define a_fetch_and a_fetch_and
+static inline int a_fetch_and(volatile int *p, int v)
+{
+	int old;
+	a_pre_llsc();
+	do old = a_ll(p);
+	while (!a_sc(p, old & v));
+	a_post_llsc();
+	return old;
+}
+#endif
+
+#ifndef a_fetch_or
+#define a_fetch_or a_fetch_or
+static inline int a_fetch_or(volatile int *p, int v)
+{
+	int old;
+	a_pre_llsc();
+	do old = a_ll(p);
+	while (!a_sc(p, old | v));
+	a_post_llsc();
+	return old;
+}
+#endif
+
+#endif
+
+#ifdef a_ll_p
+
+#ifndef a_cas_p
+#define a_cas_p a_cas_p
+static inline void *a_cas_p(volatile void *p, void *t, void *s)
+{
+	void *old;
+	a_pre_llsc();
+	do old = a_ll_p(p);
+	while (old==t && !a_sc_p(p, s));
+	a_post_llsc();
+	return old;
+}
+#endif
+
+#endif
+
+#ifndef a_cas
+#error missing definition of a_cas
+#endif
+
+#ifndef a_swap
+#define a_swap a_swap
+static inline int a_swap(volatile int *p, int v)
+{
+	int old;
+	do old = *p;
+	while (a_cas(p, old, v) != old);
+	return old;
+}
+#endif
+
+#ifndef a_fetch_add
+#define a_fetch_add a_fetch_add
+static inline int a_fetch_add(volatile int *p, int v)
+{
+	int old;
+	do old = *p;
+	while (a_cas(p, old, (unsigned)old+v) != old);
+	return old;
+}
+#endif
+
+#ifndef a_fetch_and
+#define a_fetch_and a_fetch_and
+static inline int a_fetch_and(volatile int *p, int v)
+{
+	int old;
+	do old = *p;
+	while (a_cas(p, old, old&v) != old);
+	return old;
+}
+#endif
+#ifndef a_fetch_or
+#define a_fetch_or a_fetch_or
+static inline int a_fetch_or(volatile int *p, int v)
+{
+	int old;
+	do old = *p;
+	while (a_cas(p, old, old|v) != old);
+	return old;
+}
+#endif
+
+#ifndef a_and
+#define a_and a_and
+static inline void a_and(volatile int *p, int v)
+{
+	a_fetch_and(p, v);
+}
+#endif
+
+#ifndef a_or
+#define a_or a_or
+static inline void a_or(volatile int *p, int v)
+{
+	a_fetch_or(p, v);
+}
+#endif
+
+#ifndef a_inc
+#define a_inc a_inc
+static inline void a_inc(volatile int *p)
+{
+	a_fetch_add(p, 1);
+}
+#endif
+
+#ifndef a_dec
+#define a_dec a_dec
+static inline void a_dec(volatile int *p)
+{
+	a_fetch_add(p, -1);
+}
+#endif
+
+#ifndef a_store
+#define a_store a_store
+static inline void a_store(volatile int *p, int v)
+{
+#ifdef a_barrier
+	a_barrier();
+	*p = v;
+	a_barrier();
+#else
+	a_swap(p, v);
+#endif
+}
+#endif
+
+#ifndef a_barrier
+#define a_barrier a_barrier
+static void a_barrier()
+{
+	volatile int tmp = 0;
+	a_cas(&tmp, 0, 0);
+}
+#endif
+
+#ifndef a_spin
+#define a_spin a_barrier
+#endif
+
+#ifndef a_and_64
+#define a_and_64 a_and_64
+static inline void a_and_64(volatile uint64_t *p, uint64_t v)
+{
+	union { uint64_t v; uint32_t r[2]; } u = { v };
+	if (u.r[0]+1) a_and((int *)p, u.r[0]);
+	if (u.r[1]+1) a_and((int *)p+1, u.r[1]);
+}
+#endif
+
+#ifndef a_or_64
+#define a_or_64 a_or_64
+static inline void a_or_64(volatile uint64_t *p, uint64_t v)
+{
+	union { uint64_t v; uint32_t r[2]; } u = { v };
+	if (u.r[0]) a_or((int *)p, u.r[0]);
+	if (u.r[1]) a_or((int *)p+1, u.r[1]);
+}
+#endif
+
+#ifndef a_cas_p
+typedef char a_cas_p_undefined_but_pointer_not_32bit[-sizeof(char) == 0xffffffff ? 1 : -1];
+#define a_cas_p a_cas_p
+static inline void *a_cas_p(volatile void *p, void *t, void *s)
+{
+	return (void *)a_cas((volatile int *)p, (int)t, (int)s);
+}
+#endif
+
+#ifndef a_or_l
+#define a_or_l a_or_l
+static inline void a_or_l(volatile void *p, long v)
+{
+	if (sizeof(long) == sizeof(int)) a_or(p, v);
+	else a_or_64(p, v);
+}
+#endif
+
+#ifndef a_crash
+#define a_crash a_crash
+static inline void a_crash()
+{
+	*(volatile char *)0=0;
+}
+#endif
+
+#ifndef a_ctz_32
+#define a_ctz_32 a_ctz_32
+static inline int a_ctz_32(uint32_t x)
+{
+#ifdef a_clz_32
+	return 31-a_clz_32(x&-x);
+#else
+	static const char debruijn32[32] = {
+		0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13,
+		31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14
+	};
+	return debruijn32[(x&-x)*0x076be629 >> 27];
+#endif
+}
+#endif
+
+#ifndef a_ctz_64
+#define a_ctz_64 a_ctz_64
+static inline int a_ctz_64(uint64_t x)
+{
+	static const char debruijn64[64] = {
+		0, 1, 2, 53, 3, 7, 54, 27, 4, 38, 41, 8, 34, 55, 48, 28,
+		62, 5, 39, 46, 44, 42, 22, 9, 24, 35, 59, 56, 49, 18, 29, 11,
+		63, 52, 6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,
+		51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12
+	};
+	if (sizeof(long) < 8) {
+		uint32_t y = x;
+		if (!y) {
+			y = x>>32;
+			return 32 + a_ctz_32(y);
+		}
+		return a_ctz_32(y);
+	}
+	return debruijn64[(x&-x)*0x022fdd63cc95386dull >> 58];
+}
+#endif
+
+static inline int a_ctz_l(unsigned long x)
+{
+	return (sizeof(long) < 8) ? a_ctz_32(x) : a_ctz_64(x);
+}
+
+#ifndef a_clz_64
+#define a_clz_64 a_clz_64
+static inline int a_clz_64(uint64_t x)
+{
+#ifdef a_clz_32
+	if (x>>32)
+		return a_clz_32(x>>32);
+	return a_clz_32(x) + 32;
+#else
+	uint32_t y;
+	int r;
+	if (x>>32) y=x>>32, r=0; else y=x, r=32;
+	if (y>>16) y>>=16; else r |= 16;
+	if (y>>8) y>>=8; else r |= 8;
+	if (y>>4) y>>=4; else r |= 4;
+	if (y>>2) y>>=2; else r |= 2;
+	return r | !(y>>1);
+#endif
+}
+#endif
+
+#endif
diff --git a/kernel/liteos_m/kal/posix/musl_src/internal/libc.h b/kernel/liteos_m/kal/posix/musl_src/internal/libc.h
new file mode 100644
index 0000000..85a102e
--- /dev/null
+++ b/kernel/liteos_m/kal/posix/musl_src/internal/libc.h
@@ -0,0 +1,19 @@
+#ifndef LIBC_H
+#define LIBC_H
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <limits.h>
+
+struct __locale_map;
+
+struct __locale_struct {
+	const struct __locale_map *cat[6];
+};
+
+#define __NEED_locale_t
+#include <bits/alltypes.h>
+
+
+
+#endif
diff --git a/kernel/liteos_m/kal/posix/musl_src/internal/locale_impl.h b/kernel/liteos_m/kal/posix/musl_src/internal/locale_impl.h
index c842565..47b7c9e 100644
--- a/kernel/liteos_m/kal/posix/musl_src/internal/locale_impl.h
+++ b/kernel/liteos_m/kal/posix/musl_src/internal/locale_impl.h
@@ -1,9 +1,12 @@
 #ifndef _LOCALE_IMPL_H
 #define _LOCALE_IMPL_H
 
+#define __NEED_locale_t
+
 #include <locale.h>
 #include <stdlib.h>
 #include "libc.h"
+#include "pthread_impl.h"
 #include "../include/features.h"
 
 #define LOCALE_NAME_MAX 23
@@ -27,7 +30,6 @@ hidden const char *__lctrans_impl(const char *, const struct __locale_map *);
 hidden int __loc_is_allocated(locale_t);
 hidden char *__gettextdomain(void);
 
-
 #define LOC_MAP_FAILED ((const struct __locale_map *)-1)
 
 #define LCTRANS(msg, lc, loc) __lctrans(msg, (loc)->cat[(lc)])
@@ -36,6 +38,9 @@ hidden char *__gettextdomain(void);
 #define C_LOCALE ((locale_t)&__c_locale)
 #define UTF8_LOCALE ((locale_t)&__c_dot_utf8_locale)
 
+#define CURRENT_LOCALE ((locale_t)&__c_locale)
+
+#define CURRENT_UTF8 (!!((locale_t)&__c_dot_utf8_locale)->cat[LC_CTYPE])
 
 #undef MB_CUR_MAX
 #define MB_CUR_MAX (CURRENT_UTF8 ? 4 : 1)
diff --git a/kernel/liteos_m/kal/posix/musl_src/internal/pthread_impl.h b/kernel/liteos_m/kal/posix/musl_src/internal/pthread_impl.h
new file mode 100644
index 0000000..76b3ec9
--- /dev/null
+++ b/kernel/liteos_m/kal/posix/musl_src/internal/pthread_impl.h
@@ -0,0 +1,136 @@
+#ifndef _PTHREAD_IMPL_H
+#define _PTHREAD_IMPL_H
+
+#include <pthread.h>
+#include <errno.h>
+#include <limits.h>
+#include <sys/mman.h>
+#include "libc.h"
+// #include "atomic.h"
+#include "../include/features.h"
+
+enum {
+	DT_EXITING = 0,
+	DT_JOINABLE,
+	DT_DETACHED,
+};
+
+struct __timer {
+	int timerid;
+	pthread_t thread;
+};
+
+#define __SU (sizeof(size_t)/sizeof(int))
+
+#define _a_stacksize __u.__s[0]
+#define _a_guardsize __u.__s[1]
+#define _a_stackaddr __u.__s[2]
+#define _a_detach __u.__i[3*__SU+0]
+#define _a_sched __u.__i[3*__SU+1]
+#define _a_policy __u.__i[3*__SU+2]
+#define _a_prio __u.__i[3*__SU+3]
+#define _m_type __u.__i[0]
+#define _m_lock __u.__vi[1]
+#define _m_waiters __u.__vi[2]
+#define _m_prev __u.__p[3]
+#define _m_next __u.__p[4]
+#define _m_count __u.__i[5]
+#define _c_shared __u.__p[0]
+#define _c_seq __u.__vi[2]
+#define _c_waiters __u.__vi[3]
+#define _c_clock __u.__i[4]
+#define _c_lock __u.__vi[8]
+#define _c_head __u.__p[1]
+#define _c_tail __u.__p[5]
+#define _rw_lock __u.__vi[0]
+#define _rw_waiters __u.__vi[1]
+#define _rw_shared __u.__i[2]
+#define _b_lock __u.__vi[0]
+#define _b_waiters __u.__vi[1]
+#define _b_limit __u.__i[2]
+#define _b_count __u.__vi[3]
+#define _b_waiters2 __u.__vi[4]
+#define _b_inst __u.__p[3]
+
+#ifndef CANARY
+#define CANARY canary
+#endif
+
+#ifndef DTP_OFFSET
+#define DTP_OFFSET 0
+#endif
+
+#ifndef tls_mod_off_t
+#define tls_mod_off_t size_t
+#endif
+
+#define SIGTIMER 32
+#define SIGCANCEL 33
+#define SIGSYNCCALL 34
+
+#define SIGALL_SET ((sigset_t *)(const unsigned long long [2]){ -1,-1 })
+#define SIGPT_SET \
+	((sigset_t *)(const unsigned long [_NSIG/8/sizeof(long)]){ \
+	[sizeof(long)==4] = 3UL<<(32*(sizeof(long)>4)) })
+#define SIGTIMER_SET \
+	((sigset_t *)(const unsigned long [_NSIG/8/sizeof(long)]){ \
+	 0x80000000 })
+
+void *__tls_get_addr(tls_mod_off_t *);
+hidden int __init_tp(void *);
+hidden void *__copy_tls(unsigned char *);
+hidden void __reset_tls(void);
+
+hidden void __membarrier_init(void);
+hidden void __dl_thread_cleanup(void);
+hidden void __testcancel(void);
+hidden void __do_cleanup_push(struct pthread_cleanup_buffer *);
+hidden void __do_cleanup_pop(struct pthread_cleanup_buffer *);
+hidden void __pthread_tsd_run_dtors(void);
+
+hidden void __pthread_key_delete_synccall(void (*)(void *), void *);
+hidden int __pthread_key_delete_impl(pthread_key_t);
+
+extern hidden volatile size_t __pthread_tsd_size;
+extern hidden void *__pthread_tsd_main[];
+extern hidden volatile int __aio_fut;
+extern hidden volatile int __eintr_valid_flag;
+
+hidden int __clone(int (*)(void *), void *, int, void *, ...);
+hidden int __thread_clone(int (*func)(void *), int flags, pthread_t *thread, unsigned char *sp);
+hidden int __set_thread_area(void *);
+hidden int __libc_sigaction(int, const struct sigaction *, struct sigaction *);
+hidden void __unmapself(void *, size_t);
+
+hidden int __timedwait(volatile int *, int, clockid_t, const struct timespec *, int);
+hidden int __timedwait_cp(volatile int *, int, clockid_t, const struct timespec *, int);
+hidden void __wait(volatile int *, volatile int *, int, int);
+
+hidden void __acquire_ptc(void);
+hidden void __release_ptc(void);
+hidden void __inhibit_ptc(void);
+
+hidden void __tl_lock(void);
+hidden void __tl_unlock(void);
+hidden void __tl_sync(pthread_t);
+
+extern hidden volatile int __thread_list_lock;
+
+extern hidden unsigned __default_stacksize;
+extern hidden unsigned __default_guardsize;
+
+#define DEFAULT_STACK_SIZE 131072
+#define DEFAULT_GUARD_SIZE 8192
+
+#define DEFAULT_STACK_MAX (8<<20)
+#define DEFAULT_GUARD_MAX (1<<20)
+
+#define __ATTRP_C11_THREAD ((void*)(uintptr_t)-1)
+
+#define MUSL_TYPE_THREAD    (-1)
+#define MUSL_TYPE_PROCESS   (0)
+
+#define PTHREAD_MUTEX_TYPE_MASK 3
+#define PTHREAD_PRIORITY_LOWEST 31
+
+#endif
diff --git a/kernel/liteos_m/kal/posix/musl_src/internal/stdio_impl.h b/kernel/liteos_m/kal/posix/musl_src/internal/stdio_impl.h
index 8b32cbd..fa94606 100644
--- a/kernel/liteos_m/kal/posix/musl_src/internal/stdio_impl.h
+++ b/kernel/liteos_m/kal/posix/musl_src/internal/stdio_impl.h
@@ -4,6 +4,7 @@
 #define __NEED_struct__IO_FILE
 
 #include <stdio.h>
+#include <bits/alltypes.h>
 #include "../include/features.h"
 
 #define UNGET 8
diff --git a/kernel/liteos_m/kal/posix/musl_src/locale/__lctrans.c b/kernel/liteos_m/kal/posix/musl_src/locale/__lctrans.c
new file mode 100644
index 0000000..9fbe762
--- /dev/null
+++ b/kernel/liteos_m/kal/posix/musl_src/locale/__lctrans.c
@@ -0,0 +1,19 @@
+#include <locale.h>
+#include "locale_impl.h"
+
+static const char *dummy(const char *msg, const struct __locale_map *lm)
+{
+	return msg;
+}
+
+weak_alias(dummy, __lctrans_impl);
+
+const char *__lctrans(const char *msg, const struct __locale_map *lm)
+{
+	return __lctrans_impl(msg, lm);
+}
+
+const char *__lctrans_cur(const char *msg)
+{
+	return __lctrans_impl(msg, CURRENT_LOCALE->cat[LC_MESSAGES]);
+}
diff --git a/kernel/liteos_m/kal/posix/musl_src/locale/c_locale.c b/kernel/liteos_m/kal/posix/musl_src/locale/c_locale.c
new file mode 100644
index 0000000..77ccf58
--- /dev/null
+++ b/kernel/liteos_m/kal/posix/musl_src/locale/c_locale.c
@@ -0,0 +1,15 @@
+#include "locale_impl.h"
+#include <stdint.h>
+
+static const uint32_t empty_mo[] = { 0x950412de, 0, -1, -1, -1 };
+
+const struct __locale_map __c_dot_utf8 = {
+	.map = empty_mo,
+	.map_size = sizeof empty_mo,
+	.name = "C.UTF-8"
+};
+
+const struct __locale_struct __c_locale = { 0 };
+const struct __locale_struct __c_dot_utf8_locale = {
+	.cat[LC_CTYPE] = &__c_dot_utf8
+};
diff --git a/kernel/liteos_m/kal/posix/musl_src/locale/langinfo.c b/kernel/liteos_m/kal/posix/musl_src/locale/langinfo.c
new file mode 100644
index 0000000..7953c38
--- /dev/null
+++ b/kernel/liteos_m/kal/posix/musl_src/locale/langinfo.c
@@ -0,0 +1,73 @@
+#include <locale.h>
+#include <langinfo.h>
+#include "locale_impl.h"
+
+static const char c_time[] =
+	"Sun\0" "Mon\0" "Tue\0" "Wed\0" "Thu\0" "Fri\0" "Sat\0"
+	"Sunday\0" "Monday\0" "Tuesday\0" "Wednesday\0"
+	"Thursday\0" "Friday\0" "Saturday\0"
+	"Jan\0" "Feb\0" "Mar\0" "Apr\0" "May\0" "Jun\0"
+	"Jul\0" "Aug\0" "Sep\0" "Oct\0" "Nov\0" "Dec\0"
+	"January\0"   "February\0" "March\0"    "April\0"
+	"May\0"       "June\0"     "July\0"     "August\0"
+	"September\0" "October\0"  "November\0" "December\0"
+	"AM\0" "PM\0"
+	"%a %b %e %T %Y\0"
+	"%m/%d/%y\0"
+	"%H:%M:%S\0"
+	"%I:%M:%S %p\0"
+	"\0"
+	"\0"
+	"%m/%d/%y\0"
+	"0123456789\0"
+	"%a %b %e %T %Y\0"
+	"%H:%M:%S";
+
+static const char c_messages[] = "^[yY]\0" "^[nN]\0" "yes\0" "no";
+static const char c_numeric[] = ".\0" "";
+
+char *__nl_langinfo_l(nl_item item, locale_t loc)
+{
+	int cat = item >> 16;
+	int idx = item & 65535;
+	const char *str;
+
+	if (item == CODESET) return loc->cat[LC_CTYPE] ? "UTF-8" : "ASCII";
+
+	/* _NL_LOCALE_NAME extension */
+	if (idx == 65535 && cat < LC_ALL)
+		return loc->cat[cat] ? (char *)loc->cat[cat]->name : "C";
+
+	switch (cat) {
+	case LC_NUMERIC:
+		if (idx > 1) return "";
+		str = c_numeric;
+		break;
+	case LC_TIME:
+		if (idx > 0x31) return "";
+		str = c_time;
+		break;
+	case LC_MONETARY:
+		if (idx > 0) return "";
+		str = "";
+		break;
+	case LC_MESSAGES:
+		if (idx > 3) return "";
+		str = c_messages;
+		break;
+	default:
+		return "";
+	}
+
+	for (; idx; idx--, str++) for (; *str; str++);
+	if (cat != LC_NUMERIC && *str) str = LCTRANS(str, cat, loc);
+	return (char *)str;
+}
+
+char *__nl_langinfo(nl_item item)
+{
+	return __nl_langinfo_l(item, CURRENT_LOCALE);
+}
+
+weak_alias(__nl_langinfo, nl_langinfo);
+weak_alias(__nl_langinfo_l, nl_langinfo_l);
diff --git a/kernel/liteos_m/kal/posix/musl_src/network/h_errno.c b/kernel/liteos_m/kal/posix/musl_src/network/h_errno.c
new file mode 100644
index 0000000..8c7082c
--- /dev/null
+++ b/kernel/liteos_m/kal/posix/musl_src/network/h_errno.c
@@ -0,0 +1,9 @@
+#include <netdb.h>
+
+#undef h_errno
+int h_errno;
+
+int *__h_errno_location(void)
+{
+    return &h_errno;
+}
diff --git a/kernel/liteos_m/kal/posix/musl_src/stdio/__fdopen.c b/kernel/liteos_m/kal/posix/musl_src/stdio/__fdopen.c
index e89f930..229a3a3 100644
--- a/kernel/liteos_m/kal/posix/musl_src/stdio/__fdopen.c
+++ b/kernel/liteos_m/kal/posix/musl_src/stdio/__fdopen.c
@@ -1,62 +1,62 @@
-#include "stdio_impl.h"
-#include <stdlib.h>
-#include <sys/ioctl.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <string.h>
-#include <pthread.h>
-
-FILE *__fdopen(int fd, const char *mode)
-{
-	FILE *f;
-	struct winsize wsz;
-	pthread_mutex_t filelockinit = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
-
-	/* Check for valid initial mode character */
-	if (!strchr("rwa", *mode)) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	/* Allocate FILE+buffer or fail */
-	if (!(f=malloc(sizeof *f + UNGET + BUFSIZ + sizeof(pthread_mutex_t)))) return 0;
-
-	/* Zero-fill only the struct, not the buffer */
-	memset(f, 0, sizeof *f);
-
-	/* Impose mode restrictions */
-	if (!strchr(mode, '+')) f->flags = (*mode == 'r') ? F_NOWR : F_NORD;
-
-	/* Apply close-on-exec flag */
-	if (strchr(mode, 'e')) fcntl(fd, F_SETFD, FD_CLOEXEC);
-
-	/* Set append mode on fd if opened for append */
-	if (*mode == 'a') {
-		int flags = fcntl(fd, F_GETFL);
-		if (!(flags & O_APPEND))
-			fcntl(fd, F_SETFL, flags | O_APPEND);
-		f->flags |= F_APP;
-	}
-
-	f->fd = fd;
-	f->buf = (unsigned char *)f + sizeof *f + UNGET;
-	f->buf_size = BUFSIZ;
-	f->lock = (pthread_mutex_t *)((unsigned char *)f + sizeof *f + UNGET + BUFSIZ);
-	memcpy(f->lock, &filelockinit, sizeof(pthread_mutex_t));
-
-	/* Activate line buffered mode for terminals */
-	f->lbf = EOF;
-	if (!(f->flags & F_NOWR) && !ioctl(fd, TIOCGWINSZ, &wsz))
-		f->lbf = '\n';
-
-	/* Initialize op ptrs. No problem if some are unneeded. */
-	f->read = __stdio_read;
-	f->write = __stdio_write;
-	f->seek = __stdio_seek;
-	f->close = __stdio_close;
-
-	/* Add new FILE to open file list */
-	return __ofl_add(f);
-}
-
-weak_alias(__fdopen, fdopen);
+#include "stdio_impl.h"
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <pthread.h>
+
+FILE *__fdopen(int fd, const char *mode)
+{
+	FILE *f;
+	struct winsize wsz;
+	pthread_mutex_t filelockinit = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
+
+	/* Check for valid initial mode character */
+	if (!strchr("rwa", *mode)) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	/* Allocate FILE+buffer or fail */
+	if (!(f=malloc(sizeof *f + UNGET + BUFSIZ + sizeof(pthread_mutex_t)))) return 0;
+
+	/* Zero-fill only the struct, not the buffer */
+	memset(f, 0, sizeof *f);
+
+	/* Impose mode restrictions */
+	if (!strchr(mode, '+')) f->flags = (*mode == 'r') ? F_NOWR : F_NORD;
+
+	/* Apply close-on-exec flag */
+	if (strchr(mode, 'e')) fcntl(fd, F_SETFD, FD_CLOEXEC);
+
+	/* Set append mode on fd if opened for append */
+	if (*mode == 'a') {
+		int flags = fcntl(fd, F_GETFL);
+		if (!(flags & O_APPEND))
+			fcntl(fd, F_SETFL, flags | O_APPEND);
+		f->flags |= F_APP;
+	}
+
+	f->fd = fd;
+	f->buf = (unsigned char *)f + sizeof *f + UNGET;
+	f->buf_size = BUFSIZ;
+	f->lock = (pthread_mutex_t *)((unsigned char *)f + sizeof *f + UNGET + BUFSIZ);
+	memcpy(f->lock, &filelockinit, sizeof(pthread_mutex_t));
+
+	/* Activate line buffered mode for terminals */
+	f->lbf = EOF;
+	if (!(f->flags & F_NOWR) && !ioctl(fd, TIOCGWINSZ, &wsz))
+		f->lbf = '\n';
+
+	/* Initialize op ptrs. No problem if some are unneeded. */
+	f->read = __stdio_read;
+	f->write = __stdio_write;
+	f->seek = __stdio_seek;
+	f->close = __stdio_close;
+
+	/* Add new FILE to open file list */
+	return __ofl_add(f);
+}
+
+weak_alias(__fdopen, fdopen);
diff --git a/kernel/liteos_m/kal/posix/musl_src/stdio/__fmodeflags.c b/kernel/liteos_m/kal/posix/musl_src/stdio/__fmodeflags.c
index 3c2370a..da9f23b 100644
--- a/kernel/liteos_m/kal/posix/musl_src/stdio/__fmodeflags.c
+++ b/kernel/liteos_m/kal/posix/musl_src/stdio/__fmodeflags.c
@@ -1,16 +1,16 @@
-#include <fcntl.h>
-#include <string.h>
-
-int __fmodeflags(const char *mode)
-{
-	int flags;
-	if (strchr(mode, '+')) flags = O_RDWR;
-	else if (*mode == 'r') flags = O_RDONLY;
-	else flags = O_WRONLY;
-	if (strchr(mode, 'x')) flags |= O_EXCL;
-	if (strchr(mode, 'e')) flags |= O_CLOEXEC;
-	if (*mode != 'r') flags |= O_CREAT;
-	if (*mode == 'w') flags |= O_TRUNC;
-	if (*mode == 'a') flags |= O_APPEND;
-	return flags;
-}
+#include <fcntl.h>
+#include <string.h>
+
+int __fmodeflags(const char *mode)
+{
+	int flags;
+	if (strchr(mode, '+')) flags = O_RDWR;
+	else if (*mode == 'r') flags = O_RDONLY;
+	else flags = O_WRONLY;
+	if (strchr(mode, 'x')) flags |= O_EXCL;
+	if (strchr(mode, 'e')) flags |= O_CLOEXEC;
+	if (*mode != 'r') flags |= O_CREAT;
+	if (*mode == 'w') flags |= O_TRUNC;
+	if (*mode == 'a') flags |= O_APPEND;
+	return flags;
+}
diff --git a/kernel/liteos_m/kal/posix/musl_src/stdio/__lockfile.c b/kernel/liteos_m/kal/posix/musl_src/stdio/__lockfile.c
index 1399f96..69cc42b 100644
--- a/kernel/liteos_m/kal/posix/musl_src/stdio/__lockfile.c
+++ b/kernel/liteos_m/kal/posix/musl_src/stdio/__lockfile.c
@@ -1,12 +1,12 @@
-#include "stdio_impl.h"
-#include "pthread.h"
-
-int __lockfile(FILE *f)
-{
-	return pthread_mutex_lock((pthread_mutex_t *)f->lock);
-}
-
-int __unlockfile(FILE *f)
-{
-	return pthread_mutex_unlock((pthread_mutex_t *)f->lock);
-}
+#include "stdio_impl.h"
+#include "pthread.h"
+
+int __lockfile(FILE *f)
+{
+	return pthread_mutex_lock((pthread_mutex_t *)f->lock);
+}
+
+int __unlockfile(FILE *f)
+{
+	return pthread_mutex_unlock((pthread_mutex_t *)f->lock);
+}
diff --git a/kernel/liteos_m/kal/posix/musl_src/stdio/__stdio_close.c b/kernel/liteos_m/kal/posix/musl_src/stdio/__stdio_close.c
index c97688b..e0c230f 100644
--- a/kernel/liteos_m/kal/posix/musl_src/stdio/__stdio_close.c
+++ b/kernel/liteos_m/kal/posix/musl_src/stdio/__stdio_close.c
@@ -1,7 +1,7 @@
-#include "stdio_impl.h"
-#include <unistd.h>
-
-int __stdio_close(FILE *f)
-{
-	return close(f->fd);
+#include "stdio_impl.h"
+#include <unistd.h>
+
+int __stdio_close(FILE *f)
+{
+	return close(f->fd);
 }
\ No newline at end of file
diff --git a/kernel/liteos_m/kal/posix/musl_src/stdio/__stdio_read.c b/kernel/liteos_m/kal/posix/musl_src/stdio/__stdio_read.c
index fcacffe..a0e9de2 100644
--- a/kernel/liteos_m/kal/posix/musl_src/stdio/__stdio_read.c
+++ b/kernel/liteos_m/kal/posix/musl_src/stdio/__stdio_read.c
@@ -1,25 +1,25 @@
-#include "stdio_impl.h"
-#include <sys/uio.h>
-#include <unistd.h>
-
-size_t __stdio_read(FILE *f, unsigned char *buf, size_t len)
-{
-	struct iovec iov[2] = {
-		{ .iov_base = buf, .iov_len = len - !!f->buf_size },
-		{ .iov_base = f->buf, .iov_len = f->buf_size }
-	};
-	ssize_t cnt;
-
-	cnt = read(f->fd, iov[0].iov_base, iov[0].iov_len);
-	if (iov[1].iov_len - iov[0].iov_len > 0) cnt += read(f->fd, iov[1].iov_base, iov[1].iov_len - iov[0].iov_len);
-	if (cnt <= 0) {
-		f->flags |= cnt ? F_ERR : F_EOF;
-		return 0;
-	}
-	if (cnt <= iov[0].iov_len) return cnt;
-	cnt -= iov[0].iov_len;
-	f->rpos = f->buf;
-	f->rend = f->buf + cnt;
-	if (f->buf_size) buf[len-1] = *f->rpos++;
-	return len;
+#include "stdio_impl.h"
+#include <sys/uio.h>
+#include <unistd.h>
+
+size_t __stdio_read(FILE *f, unsigned char *buf, size_t len)
+{
+	struct iovec iov[2] = {
+		{ .iov_base = buf, .iov_len = len - !!f->buf_size },
+		{ .iov_base = f->buf, .iov_len = f->buf_size }
+	};
+	ssize_t cnt;
+
+	cnt = read(f->fd, iov[0].iov_base, iov[0].iov_len);
+	if (iov[1].iov_len - iov[0].iov_len > 0) cnt += read(f->fd, iov[1].iov_base, iov[1].iov_len - iov[0].iov_len);
+	if (cnt <= 0) {
+		f->flags |= cnt ? F_ERR : F_EOF;
+		return 0;
+	}
+	if (cnt <= iov[0].iov_len) return cnt;
+	cnt -= iov[0].iov_len;
+	f->rpos = f->buf;
+	f->rend = f->buf + cnt;
+	if (f->buf_size) buf[len-1] = *f->rpos++;
+	return len;
 }
\ No newline at end of file
diff --git a/kernel/liteos_m/kal/posix/musl_src/stdio/__stdio_seek.c b/kernel/liteos_m/kal/posix/musl_src/stdio/__stdio_seek.c
index 5706025..fcecd4f 100644
--- a/kernel/liteos_m/kal/posix/musl_src/stdio/__stdio_seek.c
+++ b/kernel/liteos_m/kal/posix/musl_src/stdio/__stdio_seek.c
@@ -1,53 +1,53 @@
-#include "stdio_impl.h"
-#include <unistd.h>
-
-#if 0
-static off64_t __stdio_lseek64(int fd, int offsetHigh, int offsetLow, off64_t *result, int whence)
-{
-    off64_t ret;
-    struct file *filep = NULL;
-    off64_t offset = ((off64_t)offsetHigh << 32) + (uint)offsetLow; /* 32: offsetHigh is high 32 bits */
-
-    /* Get the file structure corresponding to the file descriptor. */
-    ret = fs_getfilep(fd, &filep);
-    if (ret < 0) {
-        /* The errno value has already been set */
-        return (off64_t)-get_errno();
-    }
-
-    /* libc seekdir function should set the whence to SEEK_SET, so we can discard
-     * the whence argument here */
-    if (filep->f_oflags & O_DIRECTORY) {
-        /* defensive coding */
-        if (filep->f_dir == NULL) {
-            return (off64_t)-EINVAL;
-        }
-        if (offsetLow == 0) {
-            rewinddir(filep->f_dir);
-        } else {
-            seekdir(filep->f_dir, offsetLow);
-        }
-        ret = telldir(filep->f_dir);
-        if (ret < 0) {
-            return (off64_t)-get_errno();
-        }
-        goto out;
-    }
-
-    /* Then let file_seek do the real work */
-    ret = file_seek64(filep, offset, whence);
-    if (ret < 0) {
-        return (off64_t)-get_errno();
-    }
-
-out:
-    *result = ret;
-
-    return 0;
-}
-#endif
-off_t __stdio_seek(FILE *f, off_t off, int whence)
-{
-	off_t result = 0;
- 	return lseek(f->fd, (unsigned int)off, whence) ? -1 : result;
-}
+#include "stdio_impl.h"
+#include <unistd.h>
+
+#if 0
+static off64_t __stdio_lseek64(int fd, int offsetHigh, int offsetLow, off64_t *result, int whence)
+{
+    off64_t ret;
+    struct file *filep = NULL;
+    off64_t offset = ((off64_t)offsetHigh << 32) + (uint)offsetLow; /* 32: offsetHigh is high 32 bits */
+
+    /* Get the file structure corresponding to the file descriptor. */
+    ret = fs_getfilep(fd, &filep);
+    if (ret < 0) {
+        /* The errno value has already been set */
+        return (off64_t)-get_errno();
+    }
+
+    /* libc seekdir function should set the whence to SEEK_SET, so we can discard
+     * the whence argument here */
+    if (filep->f_oflags & O_DIRECTORY) {
+        /* defensive coding */
+        if (filep->f_dir == NULL) {
+            return (off64_t)-EINVAL;
+        }
+        if (offsetLow == 0) {
+            rewinddir(filep->f_dir);
+        } else {
+            seekdir(filep->f_dir, offsetLow);
+        }
+        ret = telldir(filep->f_dir);
+        if (ret < 0) {
+            return (off64_t)-get_errno();
+        }
+        goto out;
+    }
+
+    /* Then let file_seek do the real work */
+    ret = file_seek64(filep, offset, whence);
+    if (ret < 0) {
+        return (off64_t)-get_errno();
+    }
+
+out:
+    *result = ret;
+
+    return 0;
+}
+#endif
+off_t __stdio_seek(FILE *f, off_t off, int whence)
+{
+	off_t result = 0;
+ 	return lseek(f->fd, (unsigned int)off, whence) ? -1 : result;
+}
diff --git a/kernel/liteos_m/kal/posix/musl_src/stdio/__stdio_write.c b/kernel/liteos_m/kal/posix/musl_src/stdio/__stdio_write.c
index cf9c1d3..9f81519 100644
--- a/kernel/liteos_m/kal/posix/musl_src/stdio/__stdio_write.c
+++ b/kernel/liteos_m/kal/posix/musl_src/stdio/__stdio_write.c
@@ -1,35 +1,35 @@
-#include "stdio_impl.h"
-#include <sys/uio.h>
-
-size_t __stdio_write(FILE *f, const unsigned char *buf, size_t len)
-{
-	struct iovec iovs[2] = {
-		{ .iov_base = f->wbase, .iov_len = f->wpos-f->wbase },
-		{ .iov_base = (void *)buf, .iov_len = len }
-	};
-	struct iovec *iov = iovs;
-	size_t rem = iov[0].iov_len + iov[1].iov_len;
-	int iovcnt = 2;
-	ssize_t cnt;
-	for (;;) {
-        cnt = write(f->fd, iov[0].iov_base, iov[0].iov_len);
-		if (0 != iov[1].iov_len)  cnt += write(f->fd, iov[1].iov_base, iov[1].iov_len);
-		if (cnt == rem) {
-			f->wend = f->buf + f->buf_size;
-			f->wpos = f->wbase = f->buf;
-			return len;
-		}
-		if (cnt < 0) {
-			f->wpos = f->wbase = f->wend = 0;
-			f->flags |= F_ERR;
-			return iovcnt == 2 ? 0 : len-iov[0].iov_len;
-		}
-		rem -= cnt;
-		if (cnt > iov[0].iov_len) {
-			cnt -= iov[0].iov_len;
-			iov++; iovcnt--;
-		}
-		iov[0].iov_base = (char *)iov[0].iov_base + cnt;
-		iov[0].iov_len -= cnt;
-	}
+#include "stdio_impl.h"
+#include <sys/uio.h>
+
+size_t __stdio_write(FILE *f, const unsigned char *buf, size_t len)
+{
+	struct iovec iovs[2] = {
+		{ .iov_base = f->wbase, .iov_len = f->wpos-f->wbase },
+		{ .iov_base = (void *)buf, .iov_len = len }
+	};
+	struct iovec *iov = iovs;
+	size_t rem = iov[0].iov_len + iov[1].iov_len;
+	int iovcnt = 2;
+	ssize_t cnt;
+	for (;;) {
+        cnt = write(f->fd, iov[0].iov_base, iov[0].iov_len);
+		if (0 != iov[1].iov_len)  cnt += write(f->fd, iov[1].iov_base, iov[1].iov_len);
+		if (cnt == rem) {
+			f->wend = f->buf + f->buf_size;
+			f->wpos = f->wbase = f->buf;
+			return len;
+		}
+		if (cnt < 0) {
+			f->wpos = f->wbase = f->wend = 0;
+			f->flags |= F_ERR;
+			return iovcnt == 2 ? 0 : len-iov[0].iov_len;
+		}
+		rem -= cnt;
+		if (cnt > iov[0].iov_len) {
+			cnt -= iov[0].iov_len;
+			iov++; iovcnt--;
+		}
+		iov[0].iov_base = (char *)iov[0].iov_base + cnt;
+		iov[0].iov_len -= cnt;
+	}
 }
\ No newline at end of file
diff --git a/kernel/liteos_m/kal/posix/musl_src/stdio/fclose.c b/kernel/liteos_m/kal/posix/musl_src/stdio/fclose.c
index bd6a890..f4005d5 100644
--- a/kernel/liteos_m/kal/posix/musl_src/stdio/fclose.c
+++ b/kernel/liteos_m/kal/posix/musl_src/stdio/fclose.c
@@ -1,36 +1,36 @@
-#include "stdio_impl.h"
-#include <stdlib.h>
-
-static void dummy(FILE *f) { }
-weak_alias(dummy, __unlist_locked_file);
-
-int fclose(FILE *f)
-{
-	int r;
-	
-	FLOCK(f);
-	r = fflush(f);
-	r |= f->close(f);
-	FUNLOCK(f);
-
-	/* Past this point, f is closed and any further explict access
-	 * to it is undefined. However, it still exists as an entry in
-	 * the open file list and possibly in the thread's locked files
-	 * list, if it was closed while explicitly locked. Functions
-	 * which process these lists must tolerate dead FILE objects
-	 * (which necessarily have inactive buffer pointers) without
-	 * producing any side effects. */
-
-	if (f->flags & F_PERM) return r;
-
-	FILE **head = __ofl_lock();
-	if (f->prev) f->prev->next = f->next;
-	if (f->next) f->next->prev = f->prev;
-	if (*head == f) *head = f->next;
-	__ofl_unlock();
-
-	free(f->getln_buf);
-	free(f);
-
-	return r;
-}
+#include "stdio_impl.h"
+#include <stdlib.h>
+
+static void dummy(FILE *f) { }
+weak_alias(dummy, __unlist_locked_file);
+
+int fclose(FILE *f)
+{
+	int r;
+	
+	FLOCK(f);
+	r = fflush(f);
+	r |= f->close(f);
+	FUNLOCK(f);
+
+	/* Past this point, f is closed and any further explict access
+	 * to it is undefined. However, it still exists as an entry in
+	 * the open file list and possibly in the thread's locked files
+	 * list, if it was closed while explicitly locked. Functions
+	 * which process these lists must tolerate dead FILE objects
+	 * (which necessarily have inactive buffer pointers) without
+	 * producing any side effects. */
+
+	if (f->flags & F_PERM) return r;
+
+	FILE **head = __ofl_lock();
+	if (f->prev) f->prev->next = f->next;
+	if (f->next) f->next->prev = f->prev;
+	if (*head == f) *head = f->next;
+	__ofl_unlock();
+
+	free(f->getln_buf);
+	free(f);
+
+	return r;
+}
diff --git a/kernel/liteos_m/kal/posix/musl_src/stdio/fflush.c b/kernel/liteos_m/kal/posix/musl_src/stdio/fflush.c
index 71606ac..b0a48e3 100644
--- a/kernel/liteos_m/kal/posix/musl_src/stdio/fflush.c
+++ b/kernel/liteos_m/kal/posix/musl_src/stdio/fflush.c
@@ -1,47 +1,47 @@
-#include "stdio_impl.h"
-
-/* stdout.c will override this if linked */
-static FILE *volatile dummy = 0;
-weak_alias(dummy, __stdout_used);
-weak_alias(dummy, __stderr_used);
-
-int fflush(FILE *f)
-{
-	if (!f) {
-		int r = 0;
-		if (__stdout_used) r |= fflush(__stdout_used);
-		if (__stderr_used) r |= fflush(__stderr_used);
-
-		for (f=*__ofl_lock(); f; f=f->next) {
-			FLOCK(f);
-			if (f->wpos != f->wbase) r |= fflush(f);
-			FUNLOCK(f);
-		}
-		__ofl_unlock();
-
-		return r;
-	}
-
-	FLOCK(f);
-
-	/* If writing, flush output */
-	if (f->wpos != f->wbase) {
-		f->write(f, 0, 0);
-		if (!f->wpos) {
-			FUNLOCK(f);
-			return EOF;
-		}
-	}
-
-	/* If reading, sync position, per POSIX */
-	if (f->rpos != f->rend) lseek(f->fd, f->rpos-f->rend, SEEK_CUR);
-
-	/* Clear read and write modes */
-	f->wpos = f->wbase = f->wend = 0;
-	f->rpos = f->rend = 0;
-
-	FUNLOCK(f);
-	return 0;
-}
-
-weak_alias(fflush, fflush_unlocked);
+#include "stdio_impl.h"
+
+/* stdout.c will override this if linked */
+static FILE *volatile dummy = 0;
+weak_alias(dummy, __stdout_used);
+weak_alias(dummy, __stderr_used);
+
+int fflush(FILE *f)
+{
+	if (!f) {
+		int r = 0;
+		if (__stdout_used) r |= fflush(__stdout_used);
+		if (__stderr_used) r |= fflush(__stderr_used);
+
+		for (f=*__ofl_lock(); f; f=f->next) {
+			FLOCK(f);
+			if (f->wpos != f->wbase) r |= fflush(f);
+			FUNLOCK(f);
+		}
+		__ofl_unlock();
+
+		return r;
+	}
+
+	FLOCK(f);
+
+	/* If writing, flush output */
+	if (f->wpos != f->wbase) {
+		f->write(f, 0, 0);
+		if (!f->wpos) {
+			FUNLOCK(f);
+			return EOF;
+		}
+	}
+
+	/* If reading, sync position, per POSIX */
+	if (f->rpos != f->rend) lseek(f->fd, f->rpos-f->rend, SEEK_CUR);
+
+	/* Clear read and write modes */
+	f->wpos = f->wbase = f->wend = 0;
+	f->rpos = f->rend = 0;
+
+	FUNLOCK(f);
+	return 0;
+}
+
+weak_alias(fflush, fflush_unlocked);
diff --git a/kernel/liteos_m/kal/posix/musl_src/stdio/fopen.c b/kernel/liteos_m/kal/posix/musl_src/stdio/fopen.c
index 7dddf93..e29336f 100644
--- a/kernel/liteos_m/kal/posix/musl_src/stdio/fopen.c
+++ b/kernel/liteos_m/kal/posix/musl_src/stdio/fopen.c
@@ -1,42 +1,42 @@
-#include "stdio_impl.h"
-#include <unistd.h>
-#include <fcntl.h>
-#include <string.h>
-#include <errno.h>
-#include <limits.h>
-
-FILE *fopen(const char *restrict filename, const char *restrict mode)
-{
-	FILE *f;
-	int fd;
-	int flags;
-
-	/* Check for valid initial mode character */
-	if (!strchr("rwa", *mode)) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	/* Compute the flags to pass to open() */
-	flags = __fmodeflags(mode);
-
-	fd = open(filename, flags, 0666);
-	if (fd < 0) return 0;
-	if (flags & O_CLOEXEC)
-		fcntl(fd, F_SETFD, FD_CLOEXEC);
-
-#if !defined(__LP64__)
-	if (fd > SHRT_MAX) {
-		errno = EMFILE;
-		return 0;
-	}
-#endif
-
-	f = __fdopen(fd, mode);
-	if (f) return f;
-
-	close(fd);
-	return 0;
-}
-
-weak_alias(fopen, fopen64);
+#include "stdio_impl.h"
+#include <unistd.h>
+#include <fcntl.h>
+#include <string.h>
+#include <errno.h>
+#include <limits.h>
+
+FILE *fopen(const char *restrict filename, const char *restrict mode)
+{
+	FILE *f;
+	int fd;
+	int flags;
+
+	/* Check for valid initial mode character */
+	if (!strchr("rwa", *mode)) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	/* Compute the flags to pass to open() */
+	flags = __fmodeflags(mode);
+
+	fd = open(filename, flags, 0666);
+	if (fd < 0) return 0;
+	if (flags & O_CLOEXEC)
+		fcntl(fd, F_SETFD, FD_CLOEXEC);
+
+#if !defined(__LP64__)
+	if (fd > SHRT_MAX) {
+		errno = EMFILE;
+		return 0;
+	}
+#endif
+
+	f = __fdopen(fd, mode);
+	if (f) return f;
+
+	close(fd);
+	return 0;
+}
+
+weak_alias(fopen, fopen64);
diff --git a/kernel/liteos_m/kal/posix/musl_src/stdio/fseek.c b/kernel/liteos_m/kal/posix/musl_src/stdio/fseek.c
index 2fc16d8..8f7d090 100644
--- a/kernel/liteos_m/kal/posix/musl_src/stdio/fseek.c
+++ b/kernel/liteos_m/kal/posix/musl_src/stdio/fseek.c
@@ -1,41 +1,41 @@
-#include "stdio_impl.h"
-
-int __fseeko_unlocked(FILE *f, off_t off, int whence)
-{
-	/* Adjust relative offset for unread data in buffer, if any. */
-	if (whence == SEEK_CUR && f->rend) off -= f->rend - f->rpos;
-
-	/* Flush write buffer, and report error on failure. */
-	if (f->wpos != f->wbase) {
-		f->write(f, 0, 0);
-		if (!f->wpos) return -1;
-	}
-
-	/* Leave writing mode */
-	f->wpos = f->wbase = f->wend = 0;
-
-	/* Perform the underlying seek. */
-	if (lseek(f->fd, (unsigned int)off, whence) < 0) return -1;
-
-	/* If seek succeeded, file is seekable and we discard read buffer. */
-	f->rpos = f->rend = 0;
-	f->flags &= ~F_EOF;
-	
-	return 0;
-}
-
-int __fseeko(FILE *f, off_t off, int whence)
-{
-	int result;
-	FLOCK(f);
-	result = __fseeko_unlocked(f, off, whence);
-	FUNLOCK(f);
-	return result;
-}
-
-int fseek(FILE *f, long off, int whence)
-{
-	return __fseeko(f, off, whence);
-}
-
-weak_alias(__fseeko, fseeko);
+#include "stdio_impl.h"
+
+int __fseeko_unlocked(FILE *f, off_t off, int whence)
+{
+	/* Adjust relative offset for unread data in buffer, if any. */
+	if (whence == SEEK_CUR && f->rend) off -= f->rend - f->rpos;
+
+	/* Flush write buffer, and report error on failure. */
+	if (f->wpos != f->wbase) {
+		f->write(f, 0, 0);
+		if (!f->wpos) return -1;
+	}
+
+	/* Leave writing mode */
+	f->wpos = f->wbase = f->wend = 0;
+
+	/* Perform the underlying seek. */
+	if (lseek(f->fd, (unsigned int)off, whence) < 0) return -1;
+
+	/* If seek succeeded, file is seekable and we discard read buffer. */
+	f->rpos = f->rend = 0;
+	f->flags &= ~F_EOF;
+	
+	return 0;
+}
+
+int __fseeko(FILE *f, off_t off, int whence)
+{
+	int result;
+	FLOCK(f);
+	result = __fseeko_unlocked(f, off, whence);
+	FUNLOCK(f);
+	return result;
+}
+
+int fseek(FILE *f, long off, int whence)
+{
+	return __fseeko(f, off, whence);
+}
+
+weak_alias(__fseeko, fseeko);
diff --git a/kernel/liteos_m/kal/posix/musl_src/stdio/ftell.c b/kernel/liteos_m/kal/posix/musl_src/stdio/ftell.c
index d15cc66..af971a7 100644
--- a/kernel/liteos_m/kal/posix/musl_src/stdio/ftell.c
+++ b/kernel/liteos_m/kal/posix/musl_src/stdio/ftell.c
@@ -1,39 +1,39 @@
-#include "stdio_impl.h"
-#include <limits.h>
-#include <errno.h>
-
-off_t __ftello_unlocked(FILE *f)
-{
-	off_t pos = lseek(f->fd, 0,
-		(f->flags & F_APP) && f->wpos != f->wbase
-		? SEEK_END : SEEK_CUR);
-	if (pos < 0) return pos;
-
-	/* Adjust for data in buffer. */
-	if (f->rend)
-		pos += f->rpos - f->rend;
-	else if (f->wbase)
-		pos += f->wpos - f->wbase;
-	return pos;
-}
-
-off_t __ftello(FILE *f)
-{
-	off_t pos;
-	FLOCK(f);
-	pos = __ftello_unlocked(f);
-	FUNLOCK(f);
-	return pos;
-}
-
-long ftell(FILE *f)
-{
-	off_t pos = __ftello(f);
-	if (pos > LONG_MAX) {
-		errno = EOVERFLOW;
-		return -1;
-	}
-	return pos;
-}
-
-weak_alias(__ftello, ftello);
+#include "stdio_impl.h"
+#include <limits.h>
+#include <errno.h>
+
+off_t __ftello_unlocked(FILE *f)
+{
+	off_t pos = lseek(f->fd, 0,
+		(f->flags & F_APP) && f->wpos != f->wbase
+		? SEEK_END : SEEK_CUR);
+	if (pos < 0) return pos;
+
+	/* Adjust for data in buffer. */
+	if (f->rend)
+		pos += f->rpos - f->rend;
+	else if (f->wbase)
+		pos += f->wpos - f->wbase;
+	return pos;
+}
+
+off_t __ftello(FILE *f)
+{
+	off_t pos;
+	FLOCK(f);
+	pos = __ftello_unlocked(f);
+	FUNLOCK(f);
+	return pos;
+}
+
+long ftell(FILE *f)
+{
+	off_t pos = __ftello(f);
+	if (pos > LONG_MAX) {
+		errno = EOVERFLOW;
+		return -1;
+	}
+	return pos;
+}
+
+weak_alias(__ftello, ftello);
diff --git a/kernel/liteos_m/kal/posix/musl_src/time/__month_to_secs.c b/kernel/liteos_m/kal/posix/musl_src/time/__month_to_secs.c
new file mode 100644
index 0000000..43248fb
--- /dev/null
+++ b/kernel/liteos_m/kal/posix/musl_src/time/__month_to_secs.c
@@ -0,0 +1,10 @@
+int __month_to_secs(int month, int is_leap)
+{
+	static const int secs_through_month[] = {
+		0, 31*86400, 59*86400, 90*86400,
+		120*86400, 151*86400, 181*86400, 212*86400,
+		243*86400, 273*86400, 304*86400, 334*86400 };
+	int t = secs_through_month[month];
+	if (is_leap && month >= 2) t+=86400;
+	return t;
+}
diff --git a/kernel/liteos_m/kal/posix/musl_src/time/__tm_to_secs.c b/kernel/liteos_m/kal/posix/musl_src/time/__tm_to_secs.c
new file mode 100644
index 0000000..c29fa98
--- /dev/null
+++ b/kernel/liteos_m/kal/posix/musl_src/time/__tm_to_secs.c
@@ -0,0 +1,24 @@
+#include "time_impl.h"
+
+long long __tm_to_secs(const struct tm *tm)
+{
+	int is_leap;
+	long long year = tm->tm_year;
+	int month = tm->tm_mon;
+	if (month >= 12 || month < 0) {
+		int adj = month / 12;
+		month %= 12;
+		if (month < 0) {
+			adj--;
+			month += 12;
+		}
+		year += adj;
+	}
+	long long t = __year_to_secs(year, &is_leap);
+	t += __month_to_secs(month, is_leap);
+	t += 86400LL * (tm->tm_mday-1);
+	t += 3600LL * tm->tm_hour;
+	t += 60LL * tm->tm_min;
+	t += tm->tm_sec;
+	return t;
+}
diff --git a/kernel/liteos_m/kal/posix/musl_src/time/__tz.c b/kernel/liteos_m/kal/posix/musl_src/time/__tz.c
new file mode 100644
index 0000000..49c2f4b
--- /dev/null
+++ b/kernel/liteos_m/kal/posix/musl_src/time/__tz.c
@@ -0,0 +1,234 @@
+#include "time_impl.h"
+#include <stdint.h>
+#include <limits.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include "libc.h"
+#include <pthread.h>
+
+long  __timezone = 0;
+int   __daylight = 0;
+char *__tzname[2] = { 0, 0 };
+
+weak_alias(__timezone, timezone);
+weak_alias(__daylight, daylight);
+weak_alias(__tzname, tzname);
+
+#ifndef PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
+#define  PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP PTHREAD_MUTEX_INITIALIZER
+#endif
+
+static pthread_mutex_t locallock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
+
+static int LOCK(void)
+{
+	return pthread_mutex_lock(&locallock);
+}
+
+static void UNLOCK(void)
+{
+	(void)pthread_mutex_unlock(&locallock);
+}
+
+
+const char __utc[] = "UTC";
+
+static int dst_off;
+static int r0[5], r1[5];
+
+static const unsigned char *zi, *trans, *index_local, *types, *abbrevs, *abbrevs_end;
+
+#define VEC(...) ((const unsigned char[]){__VA_ARGS__})
+
+static uint32_t zi_read32(const unsigned char *z)
+{
+	return (unsigned)z[0]<<24 | z[1]<<16 | z[2]<<8 | z[3];
+}
+
+static void do_tzset(void)
+{
+}
+
+/* Search zoneinfo rules to find the one that applies to the given time,
+ * and determine alternate opposite-DST-status rule that may be needed. */
+
+static size_t scan_trans(long long t, int local, size_t *alt)
+{
+	int scale = 3 - (trans == zi+44);
+	uint64_t x;
+	int off = 0;
+
+	size_t a = 0, n = (index_local-trans)>>scale, m;
+
+	if (!n) {
+		if (alt) *alt = 0;
+		return 0;
+	}
+
+	/* Binary search for 'most-recent rule before t'. */
+	while (n > 1) {
+		m = a + n/2;
+		x = zi_read32(trans + (m<<scale));
+		if (scale == 3) x = x<<32 | zi_read32(trans + (m<<scale) + 4);
+		else x = (int32_t)x;
+		if (local) off = (int32_t)zi_read32(types + 6 * index_local[m-1]);
+		if (t - off < (int64_t)x) {
+			n /= 2;
+		} else {
+			a = m;
+			n -= n/2;
+		}
+	}
+
+	/* First and last entry are special. First means to use lowest-index_local
+	 * non-DST type. Last means to apply POSIX-style rule if available. */
+	n = (index_local-trans)>>scale;
+	if (a == n-1) return -1;
+	if (a == 0) {
+		x = zi_read32(trans + (a<<scale));
+		if (scale == 3) x = x<<32 | zi_read32(trans + (a<<scale) + 4);
+		else x = (int32_t)x;
+		if (local) off = (int32_t)zi_read32(types + 6 * index_local[a-1]);
+		if (t - off < (int64_t)x) {
+			for (a=0; a<(abbrevs-types)/6; a++) {
+				if (types[6*a+4] != types[4]) break;
+			}
+			if (a == (abbrevs-types)/6) a = 0;
+			if (types[6*a+4]) {
+				*alt = a;
+				return 0;
+			} else {
+				*alt = 0;
+				return a;
+			}
+		}
+	}
+
+	/* Try to find a neighboring opposite-DST-status rule. */
+	if (alt) {
+		if (a && types[6*index_local[a-1]+4] != types[6*index_local[a]+4])
+			*alt = index_local[a-1];
+		else if (a+1<n && types[6*index_local[a+1]+4] != types[6*index_local[a]+4])
+			*alt = index_local[a+1];
+		else
+			*alt = index_local[a];
+	}
+
+	return index_local[a];
+}
+
+static int days_in_month(int m, int is_leap)
+{
+	if (m==2) return 28+is_leap;
+	else return 30+((0xad5>>(m-1))&1);
+}
+
+/* Convert a POSIX DST rule plus year to seconds since epoch. */
+
+static long long rule_to_secs(const int *rule, int year)
+{
+	int is_leap;
+	long long t = __year_to_secs(year, &is_leap);
+	int x, m, n, d;
+	if (rule[0]!='M') {
+		x = rule[1];
+		if (rule[0]=='J' && (x < 60 || !is_leap)) x--;
+		t += 86400 * x;
+	} else {
+		m = rule[1];
+		n = rule[2];
+		d = rule[3];
+		t += __month_to_secs(m-1, is_leap);
+		int wday = (int)((t + 4*86400) % (7*86400)) / 86400;
+		int days = d - wday;
+		if (days < 0) days += 7;
+		if (n == 5 && days+28 >= days_in_month(m, is_leap)) n = 4;
+		t += 86400 * (days + 7*(n-1));
+	}
+	t += rule[4];
+	return t;
+}
+
+/* Determine the time zone in effect for a given time in seconds since the
+ * epoch. It can be given in local or universal time. The results will
+ * indicate whether DST is in effect at the queried time, and will give both
+ * the GMT offset for the active zone/DST rule and the opposite DST. This
+ * enables a caller to efficiently adjust for the case where an explicit
+ * DST specification mismatches what would be in effect at the time. */
+
+void __secs_to_zone(long long t, int local, int *isdst, long *offset, long *oppoff, const char **zonename)
+{
+	LOCK();
+
+	do_tzset();
+
+	if (zi) {
+		size_t alt, i = scan_trans(t, local, &alt);
+		if (i != -1) {
+			*isdst = types[6*i+4];
+			*offset = (int32_t)zi_read32(types+6*i);
+			*zonename = (const char *)abbrevs + types[6*i+5];
+			if (oppoff) *oppoff = (int32_t)zi_read32(types+6*alt);
+			UNLOCK();
+			return;
+		}
+	}
+
+	if (!__daylight) goto std;
+
+	/* FIXME: may be broken if DST changes right at year boundary?
+	 * Also, this could be more efficient.*/
+	long long y = t / 31556952 + 70;
+	while (__year_to_secs(y, 0) > t) y--;
+	while (__year_to_secs(y+1, 0) < t) y++;
+
+	long long t0 = rule_to_secs(r0, y);
+	long long t1 = rule_to_secs(r1, y);
+
+	if (!local) {
+		t0 += __timezone;
+		t1 += dst_off;
+	}
+	if (t0 < t1) {
+		if (t >= t0 && t < t1) goto dst;
+		goto std;
+	} else {
+		if (t >= t1 && t < t0) goto std;
+		goto dst;
+	}
+std:
+	*isdst = 0;
+	*offset = -__timezone;
+	if (oppoff) *oppoff = -dst_off;
+	*zonename = __tzname[0];
+	UNLOCK();
+	return;
+dst:
+	*isdst = 1;
+	*offset = -dst_off;
+	if (oppoff) *oppoff = -__timezone;
+	*zonename = __tzname[1];
+	UNLOCK();
+}
+
+static void __tzset(void)
+{
+	LOCK();
+	do_tzset();
+	UNLOCK();
+}
+
+weak_alias(__tzset, tzset);
+
+const char *__tm_to_tzname(const struct tm *tm)
+{
+	const void *p = tm->__tm_zone;
+	LOCK();
+	do_tzset();
+	if (p != __utc && p != __tzname[0] && p != __tzname[1] &&
+	    (!zi || (uintptr_t)p-(uintptr_t)abbrevs >= abbrevs_end - abbrevs))
+		p = "";
+	UNLOCK();
+	return p;
+}
diff --git a/kernel/liteos_m/kal/posix/musl_src/time/__year_to_secs.c b/kernel/liteos_m/kal/posix/musl_src/time/__year_to_secs.c
new file mode 100644
index 0000000..2824ec6
--- /dev/null
+++ b/kernel/liteos_m/kal/posix/musl_src/time/__year_to_secs.c
@@ -0,0 +1,47 @@
+long long __year_to_secs(long long year, int *is_leap)
+{
+	if (year-2ULL <= 136) {
+		int y = year;
+		int leaps = (y-68)>>2;
+		if (!((y-68)&3)) {
+			leaps--;
+			if (is_leap) *is_leap = 1;
+		} else if (is_leap) *is_leap = 0;
+		return 31536000*(y-70) + 86400*leaps;
+	}
+
+	int cycles, centuries, leaps, rem;
+
+	if (!is_leap) is_leap = &(int){0};
+	cycles = (year-100) / 400;
+	rem = (year-100) % 400;
+	if (rem < 0) {
+		cycles--;
+		rem += 400;
+	}
+	if (!rem) {
+		*is_leap = 1;
+		centuries = 0;
+		leaps = 0;
+	} else {
+		if (rem >= 200) {
+			if (rem >= 300) centuries = 3, rem -= 300;
+			else centuries = 2, rem -= 200;
+		} else {
+			if (rem >= 100) centuries = 1, rem -= 100;
+			else centuries = 0;
+		}
+		if (!rem) {
+			*is_leap = 0;
+			leaps = 0;
+		} else {
+			leaps = rem / 4U;
+			rem %= 4U;
+			*is_leap = !rem;
+		}
+	}
+
+	leaps += 97*cycles + 24*centuries - *is_leap;
+
+	return (year-100) * 31536000LL + leaps * 86400LL + 946684800 + 86400;
+}
diff --git a/kernel/liteos_m/kal/posix/musl_src/time/strftime.c b/kernel/liteos_m/kal/posix/musl_src/time/strftime.c
index c8fd32d..cc53d53 100644
--- a/kernel/liteos_m/kal/posix/musl_src/time/strftime.c
+++ b/kernel/liteos_m/kal/posix/musl_src/time/strftime.c
@@ -8,8 +8,6 @@
 #include "locale_impl.h"
 #include "time_impl.h"
 
-#define CURRENT_LOCALE NULL
-
 static int is_leap(int y)
 {
 	/* Avoid overflow */
@@ -181,8 +179,12 @@ const char *__strftime_fmt_1(char (*s)[100], size_t *l, int f, const struct tm *
 			tm->__tm_gmtoff/3600*100 + tm->__tm_gmtoff%3600/60);
 		return *s;
 	case 'Z':
-		// unsupport tz
-		return 0;
+		if (tm->tm_isdst < 0) {
+			*l = 0;
+			return "";
+		}
+		fmt = __tm_to_tzname(tm);
+		goto string;
 	case '%':
 		*l = 1;
 		return "%";
@@ -198,14 +200,12 @@ number:
 	}
 	return *s;
 nl_strcat:
-	// unsuport loc
-	return 0;
+	fmt = __nl_langinfo_l(item, loc);
 string:
 	*l = strlen(fmt);
 	return fmt;
 nl_strftime:
-	// unsuport loc
-	return 0;
+	fmt = __nl_langinfo_l(item, loc);
 recu_strftime:
 	*l = __strftime_l(*s, sizeof *s, fmt, tm, loc);
 	if (!*l) return 0;
@@ -275,7 +275,7 @@ size_t __strftime_l(char *restrict s, size_t n, const char *restrict f, const st
 
 size_t strftime(char *restrict s, size_t n, const char *restrict f, const struct tm *restrict tm)
 {
-	return __strftime_l(s, n, f, tm, NULL);
+	return __strftime_l(s, n, f, tm, CURRENT_LOCALE);
 }
 
 weak_alias(__strftime_l, strftime_l);
diff --git a/kernel/liteos_m/kal/posix/musl_src/time/time_impl.h b/kernel/liteos_m/kal/posix/musl_src/time/time_impl.h
index c3c136d..cd94543 100644
--- a/kernel/liteos_m/kal/posix/musl_src/time/time_impl.h
+++ b/kernel/liteos_m/kal/posix/musl_src/time/time_impl.h
@@ -1,5 +1,5 @@
 #include <time.h>
-#include "features.h"
+#include "../include/features.h"
 
 hidden int __days_in_month(int, int);
 hidden int __month_to_secs(int, int);
diff --git a/kernel/liteos_m/kal/posix/src/malloc.c b/kernel/liteos_m/kal/posix/src/malloc.c
index 8b9a26f..434cba0 100644
--- a/kernel/liteos_m/kal/posix/src/malloc.c
+++ b/kernel/liteos_m/kal/posix/src/malloc.c
@@ -27,93 +27,83 @@
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "securec.h"
-#include "los_config.h"
-#include "los_memory.h"
-
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cpluscplus */
-#endif /* __cpluscplus */
-
-void *calloc(size_t nitems, size_t size)
-{
-    size_t real_size;
-    void *ptr = NULL;
-
-    if (nitems == 0 || size == 0) {
-        return NULL;
-    }
-
-    real_size = (size_t)(nitems * size);
-    ptr = LOS_MemAlloc(OS_SYS_MEM_ADDR, real_size);
-    if (ptr != NULL) {
-        (void)memset_s(ptr, real_size, 0, real_size);
-    }
-    return ptr;
-}
-
-void free(void *ptr)
-{
-    if (ptr == NULL) {
-        return;
-    }
-
-    LOS_MemFree(OS_SYS_MEM_ADDR, ptr);
-}
-
-void *malloc(size_t size)
-{
-    if (size == 0) {
-        return NULL;
-    }
-
-    return LOS_MemAlloc(OS_SYS_MEM_ADDR, size);
-}
-
-void *zalloc(size_t size)
-{
-    void *ptr = NULL;
-
-    if (size == 0) {
-        return NULL;
-    }
-
-    ptr = LOS_MemAlloc(OS_SYS_MEM_ADDR, size);
-    if (ptr != NULL) {
-        (void)memset_s(ptr, size, 0, size);
-    }
-    return ptr;
-}
-
-void *memalign(size_t boundary, size_t size)
-{
-    if (size == 0) {
-        return NULL;
-    }
-
-    return LOS_MemAllocAlign(OS_SYS_MEM_ADDR, size, boundary);
-}
-
-void *realloc(void *ptr, size_t size)
-{
-    if (ptr == NULL) {
-        return malloc(size);
-    }
-
-    if (size == 0) {
-        free(ptr);
-        return NULL;
-    }
-
-    return LOS_MemRealloc(OS_SYS_MEM_ADDR, ptr, size);
-}
-
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cpluscplus */
-#endif /* __cpluscplus */
+ */
+
+#include "securec.h"
+#include "los_config.h"
+#include "los_memory.h"
+
+
+void *calloc(size_t nitems, size_t size)
+{
+    size_t real_size;
+    void *ptr = NULL;
+
+    if (nitems == 0 || size == 0) {
+        return NULL;
+    }
+
+    real_size = (size_t)(nitems * size);
+    ptr = LOS_MemAlloc(OS_SYS_MEM_ADDR, real_size);
+    if (ptr != NULL) {
+        (void)memset_s(ptr, real_size, 0, real_size);
+    }
+    return ptr;
+}
+
+void free(void *ptr)
+{
+    if (ptr == NULL) {
+        return;
+    }
+
+    LOS_MemFree(OS_SYS_MEM_ADDR, ptr);
+}
+
+void *malloc(size_t size)
+{
+    if (size == 0) {
+        return NULL;
+    }
+
+    return LOS_MemAlloc(OS_SYS_MEM_ADDR, size);
+}
+
+void *zalloc(size_t size)
+{
+    void *ptr = NULL;
+
+    if (size == 0) {
+        return NULL;
+    }
+
+    ptr = LOS_MemAlloc(OS_SYS_MEM_ADDR, size);
+    if (ptr != NULL) {
+        (void)memset_s(ptr, size, 0, size);
+    }
+    return ptr;
+}
+
+void *memalign(size_t boundary, size_t size)
+{
+    if (size == 0) {
+        return NULL;
+    }
+
+    return LOS_MemAllocAlign(OS_SYS_MEM_ADDR, size, boundary);
+}
+
+void *realloc(void *ptr, size_t size)
+{
+    if (ptr == NULL) {
+        return malloc(size);
+    }
+
+    if (size == 0) {
+        free(ptr);
+        return NULL;
+    }
+
+    return LOS_MemRealloc(OS_SYS_MEM_ADDR, ptr, size);
+}
+
diff --git a/kernel/liteos_m/kal/posix/src/mqueue.c b/kernel/liteos_m/kal/posix/src/mqueue.c
index 48b6667..b572882 100644
--- a/kernel/liteos_m/kal/posix/src/mqueue.c
+++ b/kernel/liteos_m/kal/posix/src/mqueue.c
@@ -428,6 +428,16 @@ int mq_getsetattr(mqd_t mqd, const struct mq_attr *new, struct mq_attr *old)
     return OsMqSetAttr(mqd, new, old);
 }
 
+int mq_getattr(mqd_t mqd, struct mq_attr *attr)
+{
+    return mq_getsetattr(mqd, 0, attr);
+}
+
+int mq_setattr(mqd_t mqd, const struct mq_attr *new, struct mq_attr *old)
+{
+    return mq_getsetattr(mqd, new, old);
+}
+
 int mq_unlink(const char *mqName)
 {
     INT32 ret = 0;
diff --git a/kernel/liteos_m/kal/posix/src/mqueue_impl.h b/kernel/liteos_m/kal/posix/src/mqueue_impl.h
index 3f824fd..d0131a3 100644
--- a/kernel/liteos_m/kal/posix/src/mqueue_impl.h
+++ b/kernel/liteos_m/kal/posix/src/mqueue_impl.h
@@ -106,7 +106,7 @@
 #define GET_QUEUE_LIST(ptr) LOS_DL_LIST_ENTRY(ptr, LosQueueCB, readWriteList[OS_QUEUE_WRITE])
 
 #define STATIC static
-#define INLNIE inline
+#define INLINE inline
 
 typedef union send_receive_t {
     unsigned oth : 3;
diff --git a/kernel/liteos_m/kal/posix/src/pthread.c b/kernel/liteos_m/kal/posix/src/pthread.c
index a7e8893..cd5d870 100644
--- a/kernel/liteos_m/kal/posix/src/pthread.c
+++ b/kernel/liteos_m/kal/posix/src/pthread.c
@@ -97,7 +97,7 @@ int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
     taskInitParam.pfnTaskEntry = PthreadEntry;
     taskInitParam.uwArg   = (UINT32)(UINTPTR)pthreadData;
 
-    if (LOS_TaskCreate(&taskID, &taskInitParam) != LOS_OK) {
+    if (LOS_TaskCreateOnly(&taskID, &taskInitParam) != LOS_OK) {
         free(pthreadData);
         return EINVAL;
     }
@@ -105,6 +105,8 @@ int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
     /* set pthread default name */
     (void)sprintf_s(taskInitParam.pcName, PTHREAD_NAMELEN, "pthread%u", taskID);
 
+    (void)LOS_TaskResume(taskID);
+
     *thread = (pthread_t)taskID;
     return 0;
 }
diff --git a/kernel/liteos_m/kal/posix/src/pthread_cond.c b/kernel/liteos_m/kal/posix/src/pthread_cond.c
index 9c89a68..9f8cec9 100644
--- a/kernel/liteos_m/kal/posix/src/pthread_cond.c
+++ b/kernel/liteos_m/kal/posix/src/pthread_cond.c
@@ -47,7 +47,7 @@ typedef struct {
     UINT32 clearEvent;
 } EventCond;
 
-#define INLNIE inline
+#define INLINE inline
 
 #define BROADCAST_EVENT     1
 #define COND_COUNTER_STEP   0x0004U
diff --git a/kernel/liteos_m/kal/posix/src/pthread_mutex.c b/kernel/liteos_m/kal/posix/src/pthread_mutex.c
old mode 100755
new mode 100644
index 1b71d9a..fdd81ec
--- a/kernel/liteos_m/kal/posix/src/pthread_mutex.c
+++ b/kernel/liteos_m/kal/posix/src/pthread_mutex.c
@@ -35,11 +35,6 @@
 #include "los_mux.h"
 #include "errno.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
 #define OS_SYS_NS_PER_MSECOND 1000000
 #define OS_SYS_NS_PER_SECOND  1000000000
@@ -172,8 +167,3 @@ int pthread_mutex_unlock(pthread_mutex_t *mutex)
     return MapError(ret);
 }
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/kal/posix/src/semaphore.c b/kernel/liteos_m/kal/posix/src/semaphore.c
index 2c9535f..349a8fe 100644
--- a/kernel/liteos_m/kal/posix/src/semaphore.c
+++ b/kernel/liteos_m/kal/posix/src/semaphore.c
@@ -157,7 +157,6 @@ int sem_timedwait(sem_t *sem, const struct timespec *timeout)
 {
     UINT32 ret;
     long long tickCnt;
-    struct timespec tsNow = { 0 };
 
     if ((sem == NULL) || (sem->s_magic != _SEM_MAGIC)) {
         errno = EINVAL;
diff --git a/kernel/liteos_m/kal/posix/src/time.c b/kernel/liteos_m/kal/posix/src/time.c
old mode 100755
new mode 100644
index e11c01f..a08dc8e
--- a/kernel/liteos_m/kal/posix/src/time.c
+++ b/kernel/liteos_m/kal/posix/src/time.c
@@ -40,7 +40,7 @@
 #include "los_debug.h"
 #include "los_task.h"
 #include "los_swtmr.h"
-#include "los_timer.h"
+#include "los_tick.h"
 #include "los_context.h"
 
 /* accumulative time delta from discontinuous modify */
@@ -55,16 +55,15 @@ STATIC const UINT16 g_daysInMonth[2][13] = {
 
 STATIC const UINT8 g_montbl[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
 
-static UINT64 g_rtcTimeBase = 0;
-static UINT64 g_systickBase = 0;
-
 /*
- * Time zone information, stored in minutes,
+ * Time zone information, stored in seconds,
  * negative values indicate the east of UTC,
  * positive values indicate the west of UTC.
  */
-static INT32 g_rtcTimeZone = -480;
-static struct tm g_tm = {0};
+long timezone = -8 * 60 * 60; // defaults to CST: 8 hours east of the Prime Meridian
+
+/* internal shared struct tm object for localtime and gmtime */
+static struct tm g_tm;
 
 int nanosleep(const struct timespec *rqtp, struct timespec *rmtp)
 {
@@ -146,7 +145,7 @@ int timer_settime(timer_t timerID, int flags,
                   const struct itimerspec *restrict value,
                   struct itimerspec *restrict oldValue)
 {
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     UINT32 swtmrID = (UINT32)(UINTPTR)timerID;
     SWTMR_CTRL_S *swtmr = NULL;
     UINT32 interval, expiry, ret;
@@ -245,20 +244,17 @@ int timer_getoverrun(timer_t timerID)
 
 STATIC VOID OsGetHwTime(struct timespec *hwTime)
 {
-    UINT64 nowNsec;
-    UINT32 countHigh = 0;
-    UINT32 countLow = 0;
-    HalGetCpuCycle(&countHigh, &countLow);
-    nowNsec = (((UINT64)countHigh * OS_SYS_NS_PER_SECOND / OS_SYS_CLOCK) << 32) +
-              ((((UINT64)countHigh * OS_SYS_NS_PER_SECOND % OS_SYS_CLOCK) << 32) / OS_SYS_CLOCK) +
-              ((UINT64)countLow * OS_SYS_NS_PER_SECOND / OS_SYS_CLOCK);
+    UINT64 cycle = LOS_SysCycleGet();
+    UINT64 nowNsec = (cycle / OS_SYS_CLOCK) * OS_SYS_NS_PER_SECOND +
+                     (cycle % OS_SYS_CLOCK) * OS_SYS_NS_PER_SECOND / OS_SYS_CLOCK;
+
     hwTime->tv_sec = nowNsec / OS_SYS_NS_PER_SECOND;
     hwTime->tv_nsec = nowNsec % OS_SYS_NS_PER_SECOND;
 }
 
 STATIC VOID OsGetRealTime(struct timespec *realTime)
 {
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     struct timespec hwTime = {0};
     OsGetHwTime(&hwTime);
     intSave = LOS_IntLock();
@@ -270,7 +266,7 @@ STATIC VOID OsGetRealTime(struct timespec *realTime)
 
 STATIC VOID OsSetRealTime(const struct timespec *realTime)
 {
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     struct timespec hwTime = {0};
     OsGetHwTime(&hwTime);
     intSave = LOS_IntLock();
@@ -405,33 +401,28 @@ int clock_nanosleep(clockid_t clk, int flags, const struct timespec *req, struct
 
 clock_t clock(void)
 {
-    return HalGetExpandTick();
+    clock_t clk;
+    struct timespec hwTime;
+    OsGetHwTime(&hwTime);
+
+    clk = hwTime.tv_sec * CLOCKS_PER_SEC;
+    clk += hwTime.tv_nsec  / (OS_SYS_NS_PER_SECOND / CLOCKS_PER_SEC);
+
+    return clk;
 }
 
 time_t time(time_t *timer)
 {
-    UINT64 usec = 0;
-    time_t sec;
-    INT32 rtcRet;
-
-    rtcRet = HalGetRtcTime(&usec);
-    if (rtcRet != 0) {
-        UINT64 currentTime;
-        UINT64 tickDelta;
-        UINT64 currentTick = HalGetExpandTick();
-        if ((g_systickBase != 0) && (currentTick > g_systickBase)) {
-            tickDelta = currentTick - g_systickBase;
-        }
-        currentTime = g_rtcTimeBase + tickDelta;
-        sec = currentTime / OS_SYS_MS_PER_SECOND;
-    } else {
-        sec = usec / OS_SYS_US_PER_SECOND;
+    struct timespec ts;
+
+    if (-1 == clock_gettime(CLOCK_REALTIME, &ts)) {
+        return (time_t)-1;
     }
 
     if (timer != NULL) {
-        *timer = sec;
+        *timer = ts.tv_sec;
     }
-    return sec;
+    return ts.tv_sec;
 }
 
 /*
@@ -494,23 +485,23 @@ static INT32 ConvertSecs2Utc(time_t t, INT32 offset, struct tm *tp)
     days -= daysInMonth[month];
     tp->tm_mon = month;
     tp->tm_mday = days + 1;
+    tp->__tm_gmtoff = offset;
+    tp->__tm_zone = NULL;
+    tp->tm_isdst = 0;
     return 1;
 }
 
-struct tm *gmtime_r(const time_t *timer, struct tm *tp)
+struct tm *gmtime_r(const time_t *timep, struct tm *result)
 {
-    time_t t64;
-    UINT32 intSave;
-    if ((timer == NULL) || (tp == NULL)) {
+    if ((timep == NULL) || (result == NULL)) {
+        errno = EFAULT;
         return NULL;
     }
-    intSave = LOS_IntLock();
-    t64 = *timer;
-    if (!ConvertSecs2Utc(t64, 0, tp)) {
-        tp = NULL;
+    if (!ConvertSecs2Utc(*timep, 0, result)) {
+        errno = EINVAL;
+        return NULL;
     }
-    (void)LOS_IntRestore(intSave);
-    return tp;
+    return result;
 }
 
 struct tm *gmtime(const time_t *timer)
@@ -518,22 +509,17 @@ struct tm *gmtime(const time_t *timer)
     return gmtime_r(timer, &g_tm);
 }
 
-struct tm *localtime_r(const time_t *timer, struct tm *tp)
+struct tm *localtime_r(const time_t *timep, struct tm *result)
 {
-    UINT32 intSave;
-    time_t t64;
-    INT32 offset;
-    if ((timer == NULL) || (tp == NULL)) {
+    if ((timep == NULL) || (result == NULL)) {
+        errno = EFAULT;
         return NULL;
     }
-    intSave = LOS_IntLock();
-    t64 = *timer;
-    offset = -(g_rtcTimeZone * SECS_PER_MIN);
-    if (!ConvertSecs2Utc(t64, offset, tp)) {
-        tp = NULL;
+    if (!ConvertSecs2Utc(*timep, -timezone, result)) {
+        errno = EINVAL;
+        return NULL;
     }
-    (void)LOS_IntRestore(intSave);
-    return tp;
+    return result;
 }
 
 struct tm *localtime(const time_t *timer)
@@ -569,87 +555,108 @@ static time_t ConvertUtc2Secs(struct tm *tm)
     }
 
     seconds += (tm->tm_mday - 1) * SECS_PER_DAY;
-
     seconds += tm->tm_hour * SECS_PER_HOUR + tm->tm_min * SECS_PER_MIN + tm->tm_sec;
 
+    seconds -= tm->__tm_gmtoff; // sub time zone to get UTC time
     return seconds;
 }
 
 time_t mktime(struct tm *tmptr)
 {
-    struct tm tempTime;
     time_t timeInSeconds;
     if (tmptr == NULL) {
-        return 0;
-    }
-    if (tmptr->tm_year < (EPOCH_YEAR - TM_YEAR_BASE)) {
-        return 0;
-    }
-    tempTime = *tmptr;
-    timeInSeconds = ConvertUtc2Secs(&tempTime);
-    timeInSeconds += g_rtcTimeZone * SECS_PER_MIN;
+        errno = EFAULT;
+        return (time_t)-1;
+    }
+
+    /* tm_isdst is not supported and is ignored */
+    if (tmptr->tm_year < (EPOCH_YEAR - TM_YEAR_BASE) ||
+            tmptr->__tm_gmtoff > (-TIME_ZONE_MIN * SECS_PER_MIN) ||
+            tmptr->__tm_gmtoff < (-TIME_ZONE_MAX * SECS_PER_MIN) ||
+            tmptr->tm_sec > 60 || tmptr->tm_sec < 0 ||      /* Seconds [0-60] */
+            tmptr->tm_min > 59 || tmptr->tm_min < 0 ||      /* Minutes [0-59] */
+            tmptr->tm_hour > 23 || tmptr->tm_hour < 0 ||    /* Hours [0-23] */
+            tmptr->tm_mday > 31 || tmptr->tm_mday < 1 ||    /* Day of the month [1-31] */
+            tmptr->tm_mon > 11 || tmptr->tm_mon < 0) {      /* Month [0-11] */
+        errno = EOVERFLOW;
+        return (time_t)-1;
+    }
+    timeInSeconds = ConvertUtc2Secs(tmptr);
+    /* normalize tm_wday and tm_yday */
+    ConvertSecs2Utc(timeInSeconds, tmptr->__tm_gmtoff, tmptr);
     return timeInSeconds;
 }
 
 int gettimeofday(struct timeval *tv, void *ptz)
 {
-    INT32 rtcRet;
-    INT32 timeZone = 0;
-    UINT64 usec = 0;
-    UINT64 currentTime;
-    UINT64 tickDelta = 0;
-    UINT64 currentTick;
-
+    struct timespec ts;
     struct timezone *tz = (struct timezone *)ptz;
-    if ((tv == NULL) && (tz == NULL)) {
-        return -1;
-    }
+
     if (tv != NULL) {
-        rtcRet = HalGetRtcTime(&usec);
-        if (rtcRet != 0) {
-            currentTick = HalGetExpandTick();
-            if ((g_systickBase != 0) && (currentTick > g_systickBase)) {
-                tickDelta = currentTick - g_systickBase;
-            }
-            currentTime = g_rtcTimeBase + tickDelta;
-            tv->tv_sec = currentTime / OS_SYS_MS_PER_SECOND;
-            tv->tv_usec = (currentTime % OS_SYS_MS_PER_SECOND) * OS_SYS_MS_PER_SECOND;
-        } else {
-            tv->tv_sec = usec / OS_SYS_US_PER_SECOND;
-            tv->tv_usec = usec % OS_SYS_US_PER_SECOND;
+        if (-1 == clock_gettime(CLOCK_REALTIME, &ts)) {
+            return -1;
         }
+        tv->tv_sec = ts.tv_sec;
+        tv->tv_usec = ts.tv_nsec / OS_SYS_NS_PER_US;
     }
-    HalGetRtcTimeZone(&timeZone);
     if (tz != NULL) {
-        tz->tz_minuteswest = timeZone;
+        tz->tz_minuteswest = timezone / SECS_PER_MIN;
+        tz->tz_dsttime = 0;
     }
     return 0;
 }
 
 int settimeofday(const struct timeval *tv, const struct timezone *tz)
 {
-    UINT64 usec;
-    if ((tv == NULL) || (tz == NULL)) {
+    struct timespec ts;
+    INT32 rtcTimeZone = timezone;
+
+    if (tv == NULL) {
+        errno = EFAULT;
         return -1;
     }
-    g_rtcTimeBase = tv->tv_sec * OS_SYS_MS_PER_SECOND + tv->tv_usec / OS_SYS_MS_PER_SECOND;
-    g_systickBase = HalGetExpandTick();
-    if ((tz->tz_minuteswest > TIME_ZONE_MIN) &&
-        (tz->tz_minuteswest < TIME_ZONE_MAX)) {
-        g_rtcTimeZone = tz->tz_minuteswest;
+    if (tz != NULL) {
+        if ((tz->tz_minuteswest >= TIME_ZONE_MIN) &&
+            (tz->tz_minuteswest <= TIME_ZONE_MAX)) {
+            rtcTimeZone = tz->tz_minuteswest * SECS_PER_MIN;
+        } else {
+            errno = EINVAL;
+            return -1;
+        }
     }
-    usec = tv->tv_sec * OS_SYS_US_PER_SECOND + tv->tv_usec;
-    HalSetRtcTime(g_rtcTimeBase, &usec);
-    HalSetRtcTimeZone(g_rtcTimeZone);
+
+    if (tv->tv_usec >= OS_SYS_US_PER_SECOND) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    ts.tv_sec = tv->tv_sec;
+    ts.tv_nsec = tv->tv_usec * OS_SYS_NS_PER_US;
+    if (-1 == clock_settime(CLOCK_REALTIME, &ts)) {
+        return -1;
+    }
+
+    timezone = rtcTimeZone;
+
     return 0;
 }
 
 int usleep(unsigned useconds)
 {
     struct timespec specTime = { 0 };
-    UINT64 nanoseconds = useconds * OS_SYS_NS_PER_US;
+    UINT64 nanoseconds = (UINT64)useconds * OS_SYS_NS_PER_US;
+
+    specTime.tv_sec = (time_t)(nanoseconds / OS_SYS_NS_PER_SECOND);
+    specTime.tv_nsec = (long)(nanoseconds % OS_SYS_NS_PER_SECOND);
+    return nanosleep(&specTime, NULL);
+}
+
+unsigned sleep(unsigned seconds)
+{
+    struct timespec specTime = { 0 };
+    UINT64 nanoseconds = (UINT64)seconds * OS_SYS_NS_PER_SECOND;
 
     specTime.tv_sec = (time_t)(nanoseconds / OS_SYS_NS_PER_SECOND);
     specTime.tv_nsec = (long)(nanoseconds % OS_SYS_NS_PER_SECOND);
     return nanosleep(&specTime, NULL);
-}
\ No newline at end of file
+}
diff --git a/kernel/liteos_m/kal/posix/src/time_internal.h b/kernel/liteos_m/kal/posix/src/time_internal.h
index e7181d1..a8fc596 100644
--- a/kernel/liteos_m/kal/posix/src/time_internal.h
+++ b/kernel/liteos_m/kal/posix/src/time_internal.h
@@ -61,8 +61,8 @@
 #define DAYS_PER_NORMAL_YEAR 365
 #define DAYS_PER_LEAP_YEAR   366
 #define BEGIN_WEEKDAY        4
-#define TIME_ZONE_MAX        720 /* 12 * 60 */
-#define TIME_ZONE_MIN        (-840) /* -14 * 60 */
+#define TIME_ZONE_MAX        720 /* UTC-12:00 , the last time zone */
+#define TIME_ZONE_MIN        (-840) /* UTC+14:00 , the first time zone */
 
 /*
  * Nonzero if YEAR is a leap year (every 4 years,
@@ -72,14 +72,6 @@
 #define IS_LEAP_YEAR(year) \
     (((year) % 4 == 0) && (((year) % 100 != 0) || ((year) % 400 == 0)))
 #endif
-/* The lowest two bytes indicate minutes of the time zone */
-#ifndef OFFSET_TO_MINUTE
-#define OFFSET_TO_MINUTE(time) (((time) < 0) ? (-(time)) : (time))
-#endif
-/* The highest 31 bytes, 1 indicates eastern time zone? indicates western time zone */
-#ifndef TIME_ZONE_SIGN
-#define TIME_ZONE_SIGN(time) ((time) >> 31)
-#endif
 
 #define DIV(a, b) (((a) / (b)) - ((a) % (b) < 0))
 #define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))
diff --git a/kernel/liteos_m/kernel/BUILD.gn b/kernel/liteos_m/kernel/BUILD.gn
index 1853f63..742da8b 100644
--- a/kernel/liteos_m/kernel/BUILD.gn
+++ b/kernel/liteos_m/kernel/BUILD.gn
@@ -37,6 +37,8 @@ static_library("kernel") {
     "src/los_swtmr.c",
     "src/los_task.c",
     "src/los_tick.c",
+    "src/los_sched.c",
+    "src/los_sortlink.c",
     "src/mm/los_membox.c",
     "src/mm/los_memory.c",
   ]
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/BUILD.gn b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/BUILD.gn
new file mode 100644
index 0000000..ccda24e
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/BUILD.gn
@@ -0,0 +1,45 @@
+# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021, Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("arch") {
+  sources = [
+    "los_context.c",
+    "los_dispatch.S",
+    "los_exc.S",
+    "los_interrupt.c",
+    "los_timer.c",
+  ]
+
+  include_dirs = [
+    "../../../../../kernel/arch/include",
+    "../../../../../kernel/include",
+    "../../../../../utils",
+    "//third_party/bounds_checking_function/include",
+  ]
+}
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_atomic.h b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_atomic.h
new file mode 100644
index 0000000..fceaca6
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_atomic.h
@@ -0,0 +1,158 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_ARCH_ATOMIC_H
+#define _LOS_ARCH_ATOMIC_H
+
+#include "los_compiler.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+/**
+ * @ingroup  los_arch_atomic
+ * @brief Atomic exchange for 32-bit variable.
+ *
+ * @par Description:
+ * This API is used to implement the atomic exchange for 32-bit variable and return the previous value of the atomic variable.
+ * @attention
+ * <ul>The pointer v must not be NULL.</ul>
+ *
+ * @param  v       [IN] The variable pointer.
+ * @param  val       [IN] The exchange value.
+ *
+ * @retval #INT32       The previous value of the atomic variable
+ * @par Dependency:
+ * <ul><li>los_arch_atomic.h: the header file that contains the API declaration.</li></ul>
+ * @see
+ */
+STATIC INLINE INT32 HalAtomicXchg32bits(volatile INT32 *v, INT32 val)
+{
+    INT32 prevVal = 0;
+    UINT32 status = 0;
+
+    do {
+        __asm__ __volatile__("ldrex   %0, [%3]\n"
+                             "strex   %1, %4, [%3]"
+                             : "=&r"(prevVal), "=&r"(status), "+m"(*v)
+                             : "r"(v), "r"(val)
+                             : "cc");
+    } while (__builtin_expect(status != 0, 0));
+
+    return prevVal;
+}
+
+/**
+ * @ingroup  los_arch_atomic
+ * @brief Atomic auto-decrement.
+ *
+ * @par Description:
+ * This API is used to implementating the atomic auto-decrement and return the result of auto-decrement.
+ * @attention
+ * <ul>
+ * <li>The pointer v must not be NULL.</li>
+ * <li>The value which v point to must not be INT_MIN to avoid overflow after reducing 1.</li>
+ * </ul>
+ *
+ * @param  v      [IN] The addSelf variable pointer.
+ *
+ * @retval #INT32  The return value of variable auto-decrement.
+ * @par Dependency:
+ * <ul><li>los_arch_atomic.h: the header file that contains the API declaration.</li></ul>
+ * @see
+ */
+STATIC INLINE INT32 HalAtomicDecRet(volatile INT32 *v)
+{
+    INT32 val = 0;
+    UINT32 status = 0;
+
+    do {
+        __asm__ __volatile__("ldrex   %0, [%3]\n"
+                             "sub   %0, %0, #1\n"
+                             "strex   %1, %0, [%3]"
+                             : "=&r"(val), "=&r"(status), "+m"(*v)
+                             : "r"(v)
+                             : "cc");
+    } while (__builtin_expect(status != 0, 0));
+
+    return val;
+}
+
+/**
+ * @ingroup  los_arch_atomic
+ * @brief Atomic exchange for 32-bit variable with compare.
+ *
+ * @par Description:
+ * This API is used to implement the atomic exchange for 32-bit variable, if the value of variable is equal to oldVal.
+ * @attention
+ * <ul>The pointer v must not be NULL.</ul>
+ *
+ * @param  v       [IN] The variable pointer.
+ * @param  val     [IN] The new value.
+ * @param  oldVal      [IN] The old value.
+ *
+ * @retval TRUE  The previous value of the atomic variable is not equal to oldVal.
+ * @retval FALSE The previous value of the atomic variable is equal to oldVal.
+ * @par Dependency:
+ * <ul><li>los_arch_atomic.h: the header file that contains the API declaration.</li></ul>
+ * @see
+ */
+STATIC INLINE BOOL HalAtomicCmpXchg32bits(volatile INT32 *v, INT32 val, INT32 oldVal)
+{
+    INT32 prevVal = 0;
+    UINT32 status = 0;
+
+    do {
+        __asm__ __volatile__("1: ldrex %0, %2\n"
+                             "    mov %1, #0\n"
+                             "    cmp %0, %3\n"
+                             "    bne 2f\n"
+                             "    strex %1, %4, %2\n"
+                             "2:"
+                             : "=&r"(prevVal), "=&r"(status), "+Q"(*v)
+                             : "r"(oldVal), "r"(val)
+                             : "cc");
+    } while (__builtin_expect(status != 0, 0));
+
+    return prevVal != oldVal;
+}
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _LOS_ARCH_ATOMIC_H */
+
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_context.h b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_context.h
new file mode 100644
index 0000000..e8ee901
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_context.h
@@ -0,0 +1,177 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_ARCH_CONTEXT_H
+#define _LOS_ARCH_CONTEXT_H
+
+#include "los_config.h"
+#include "los_compiler.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#define PSR_T_ARM      0x00000000U
+#define PSR_T_THUMB    0x00000020U
+#define PSR_MODE_SVC   0x00000013U
+#define PSR_MODE_SYS   0x0000001FU
+
+#define PSR_MODE_SVC_THUMB  (PSR_MODE_SVC | PSR_T_THUMB)
+#define PSR_MODE_SVC_ARM    (PSR_MODE_SVC | PSR_T_ARM)
+
+#define PSR_MODE_SYS_THUMB  (PSR_MODE_SYS | PSR_T_THUMB)
+#define PSR_MODE_SYS_ARM    (PSR_MODE_SYS | PSR_T_ARM)
+
+typedef struct TagTskContext {
+    UINT32 uwPSR;
+    UINT32 uwR0;
+    UINT32 uwR1;
+    UINT32 uwR2;
+    UINT32 uwR3;
+    UINT32 uwR4;
+    UINT32 uwR5;
+    UINT32 uwR6;
+    UINT32 uwR7;
+    UINT32 uwR8;
+    UINT32 uwR9;
+    UINT32 uwR10;
+    UINT32 uwR11;
+    UINT32 uwR12;
+    UINT32 uwLR;
+    UINT32 uwPC;
+} TaskContext;
+
+/**
+ * @ingroup  los_config
+ * @brief: Task start running function.
+ *
+ * @par Description:
+ * This API is used to start a task.
+ *
+ * @attention:
+ * <ul><li>None.</li></ul>
+ *
+ * @param: None.
+ *
+ * @retval None.
+ *
+ * @par Dependency:
+ * <ul><li>los_config.h: the header file that contains the API declaration.</li></ul>
+ * @see None.
+ */
+extern VOID HalStartToRun(VOID);
+
+/**
+ * @ingroup los_arch_context
+ * @brief Wait for interrupt.
+ *
+ * @par Description:
+ * <ul>
+ * <li>This API is used to suspend execution until interrupt or a debug request occurs.</li>
+ * </ul>
+ * @attention None.
+ *
+ * @param None.
+ *
+ * @retval: None.
+ *
+ * @par Dependency:
+ * los_arch_context.h: the header file that contains the API declaration.
+ * @see None.
+ */
+extern VOID wfi(VOID);
+
+/**
+ * @ingroup los_arch_context
+ * @brief: mem fence function.
+ *
+ * @par Description:
+ * This API is used to fence for memory.
+ *
+ * @attention:
+ * <ul><li>None.</li></ul>
+ *
+ * @param: None.
+ *
+ * @retval:None.
+ * @par Dependency:
+ * <ul><li>los_arch_context.h: the header file that contains the API declaration.</li></ul>
+ * @see None.
+ */
+extern VOID dmb(VOID);
+
+/**
+ * @ingroup los_arch_context
+ * @brief: mem fence function.
+ *
+ * @par Description:
+ * This API is same as dmb, it just for adaptation.
+ *
+ * @attention:
+ * <ul><li>None.</li></ul>
+ *
+ * @param: None.
+ *
+ * @retval:None.
+ * @par Dependency:
+ * <ul><li>los_arch_context.h: the header file that contains the API declaration.</li></ul>
+ * @see None.
+ */
+extern VOID dsb(VOID);
+
+/**
+ * @ingroup los_arch_context
+ * @brief: instruction fence function.
+ *
+ * @par Description:
+ * This API is used to fence for instruction.
+ *
+ * @attention:
+ * <ul><li>None.</li></ul>
+ *
+ * @param: None.
+ *
+ * @retval:None.
+ * @par Dependency:
+ * <ul><li>los_arch_context.h: the header file that contains the API declaration.</li></ul>
+ * @see None.
+ */
+extern VOID isb(VOID);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _LOS_ARCH_CONTEXT_H */
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_interrupt.h b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_interrupt.h
new file mode 100644
index 0000000..117410e
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_interrupt.h
@@ -0,0 +1,655 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_ARCH_INTERRUPT_H
+#define _LOS_ARCH_INTERRUPT_H
+
+#include "los_config.h"
+#include "los_compiler.h"
+#include "los_interrupt.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Maximum number of used hardware interrupts.
+ */
+#ifndef OS_HWI_MAX_NUM
+#define OS_HWI_MAX_NUM                        LOSCFG_PLATFORM_HWI_LIMIT
+#endif
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Highest priority of a hardware interrupt.
+ */
+#ifndef OS_HWI_PRIO_HIGHEST
+#define OS_HWI_PRIO_HIGHEST                   0
+#endif
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Lowest priority of a hardware interrupt.
+ */
+#ifndef OS_HWI_PRIO_LOWEST
+#define OS_HWI_PRIO_LOWEST                    7
+#endif
+
+
+/* *
+ * @ingroup  los_arch_interrupt
+ * Define the type of a hardware interrupt vector table function.
+ */
+typedef VOID (**HWI_VECTOR_FUNC)(void);
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Count of interrupts.
+ */
+extern UINT32 g_intCount;
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Count of M-Core system interrupt vector.
+ */
+#define OS_SYS_VECTOR_CNT                     16
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Count of M-Core interrupt vector.
+ */
+#define OS_VECTOR_CNT                         (OS_SYS_VECTOR_CNT + OS_HWI_MAX_NUM)
+
+/* *
+ * @ingroup los_arch_interrupt
+ * AIRCR register priority group parameter .
+ */
+#define OS_NVIC_AIRCR_PRIGROUP                7
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Boot interrupt vector table.
+ */
+extern UINT32 _BootVectors[];
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Hardware interrupt error code: Invalid interrupt number.
+ *
+ * Value: 0x02000900
+ *
+ * Solution: Ensure that the interrupt number is valid. The value range of the interrupt number applicable for a Cortex-A7 platform is [OS_USER_HWI_MIN,OS_USER_HWI_MAX].
+ */
+#define OS_ERRNO_HWI_NUM_INVALID              LOS_ERRNO_OS_ERROR(LOS_MOD_HWI, 0x00)
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Hardware interrupt error code: Null hardware interrupt handling function.
+ *
+ * Value: 0x02000901
+ *
+ * Solution: Pass in a valid non-null hardware interrupt handling function.
+ */
+#define OS_ERRNO_HWI_PROC_FUNC_NULL           LOS_ERRNO_OS_ERROR(LOS_MOD_HWI, 0x01)
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Hardware interrupt error code: Insufficient interrupt resources for hardware interrupt creation.
+ *
+ * Value: 0x02000902
+ *
+ * Solution: Increase the configured maximum number of supported hardware interrupts.
+ */
+#define OS_ERRNO_HWI_CB_UNAVAILABLE           LOS_ERRNO_OS_ERROR(LOS_MOD_HWI, 0x02)
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Hardware interrupt error code: Insufficient memory for hardware interrupt initialization.
+ *
+ * Value: 0x02000903
+ *
+ * Solution: Expand the configured memory.
+ */
+#define OS_ERRNO_HWI_NO_MEMORY                LOS_ERRNO_OS_ERROR(LOS_MOD_HWI, 0x03)
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Hardware interrupt error code: The interrupt has already been created.
+ *
+ * Value: 0x02000904
+ *
+ * Solution: Check whether the interrupt specified by the passed-in interrupt number has already been created.
+ */
+#define OS_ERRNO_HWI_ALREADY_CREATED          LOS_ERRNO_OS_ERROR(LOS_MOD_HWI, 0x04)
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Hardware interrupt error code: Invalid interrupt priority.
+ *
+ * Value: 0x02000905
+ *
+ * Solution: Ensure that the interrupt priority is valid. The value range of the interrupt priority applicable for a Cortex-A7 platform is [0,15].
+ */
+#define OS_ERRNO_HWI_PRIO_INVALID             LOS_ERRNO_OS_ERROR(LOS_MOD_HWI, 0x05)
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Hardware interrupt error code: Incorrect interrupt creation mode.
+ *
+ * Value: 0x02000906
+ *
+ * Solution: The interrupt creation mode can be only set to OS_HWI_MODE_COMM or OS_HWI_MODE_FAST of which the value can be 0 or 1.
+ */
+#define OS_ERRNO_HWI_MODE_INVALID             LOS_ERRNO_OS_ERROR(LOS_MOD_HWI, 0x06)
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Hardware interrupt error code: The interrupt has already been created as a fast interrupt.
+ *
+ * Value: 0x02000907
+ *
+ * Solution: Check whether the interrupt specified by the passed-in interrupt number has already been created.
+ */
+#define OS_ERRNO_HWI_FASTMODE_ALREADY_CREATED LOS_ERRNO_OS_ERROR(LOS_MOD_HWI, 0x07)
+
+/* *
+ * @ingroup los_arch_interrupt
+ * SysTick control and status register.
+ */
+#define OS_SYSTICK_CONTROL_REG                0xE000E010
+
+/* *
+ * @ingroup los_hw
+ * SysTick current value register.
+ */
+#define OS_SYSTICK_CURRENT_REG                0xE000E018
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Interrupt Priority-Level Registers.
+ */
+#define OS_NVIC_PRI_BASE                      0xE000E400
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Interrupt enable register for 0-31.
+ */
+#define OS_NVIC_SETENA_BASE                   0xE000E100
+
+/* *
+ * @ingroup los_arch_interrupt
+ * interrupt pending register.
+ */
+#define OS_NVIC_SETPEND_BASE                  0xE000E200
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Interrupt active register.
+ */
+#define OS_NVIC_INT_ACT_BASE                  0xE000E300
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Interrupt disable register for 0-31.
+ */
+#define OS_NVIC_CLRENA_BASE                   0xE000E180
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Interrupt control and status register.
+ */
+#define OS_NVIC_INT_CTRL                      0xE000ED04
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Vector table offset register.
+ */
+#define OS_NVIC_VTOR                          0xE000ED08
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Application interrupt and reset control register
+ */
+#define OS_NVIC_AIRCR                         0xE000ED0C
+
+/* *
+ * @ingroup los_arch_interrupt
+ * System exception priority register.
+ */
+#define OS_NVIC_EXCPRI_BASE                   0xE000ED18
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Interrupt No. 1 :reset.
+ */
+#define OS_EXC_RESET                          1
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Interrupt No. 2 :Non-Maskable Interrupt.
+ */
+#define OS_EXC_NMI                            2
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Interrupt No. 3 :(hard)fault.
+ */
+#define OS_EXC_HARD_FAULT                     3
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Interrupt No. 4 :MemManage fault.
+ */
+#define OS_EXC_MPU_FAULT                      4
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Interrupt No. 5 :Bus fault.
+ */
+#define OS_EXC_BUS_FAULT                      5
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Interrupt No. 6 :Usage fault.
+ */
+#define OS_EXC_USAGE_FAULT                    6
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Interrupt No. 11 :SVCall.
+ */
+#define OS_EXC_SVC_CALL                       11
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Interrupt No. 12 :Debug monitor.
+ */
+#define OS_EXC_DBG_MONITOR                    12
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Interrupt No. 14 :PendSV.
+ */
+#define OS_EXC_PEND_SV                        14
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Interrupt No. 15 :SysTick.
+ */
+#define OS_EXC_SYS_TICK                       15
+
+#if (OS_HWI_WITH_ARG == 1)
+/* *
+ * @ingroup los_arch_interrupt
+ * Set interrupt vector table.
+ */
+extern VOID OsSetVector(UINT32 num, HWI_PROC_FUNC vector, VOID *arg);
+#else
+/* *
+ * @ingroup los_arch_interrupt
+ * Set interrupt vector table.
+ */
+extern VOID OsSetVector(UINT32 num, HWI_PROC_FUNC vector);
+#endif
+
+/* *
+ * @ingroup  los_arch_interrupt
+ * @brief: Get an interrupt number.
+ *
+ * @par Description:
+ * This API is used to get the current interrupt number.
+ *
+ * @attention:
+ * <ul><li>None.</li></ul>
+ *
+ * @param: None.
+ *
+ * @retval: Interrupt Indexes number.
+ * @par Dependency:
+ * <ul><li>los_arch_interrupt.h: the header file that contains the API declaration.</li></ul>
+ * @see None.
+ */
+extern UINT32 HalIntNumGet(VOID);
+
+/* *
+ * @ingroup  los_arch_interrupt
+ * @brief: Default vector handling function.
+ *
+ * @par Description:
+ * This API is used to configure interrupt for null function.
+ *
+ * @attention:
+ * <ul><li>None.</li></ul>
+ *
+ * @param:None.
+ *
+ * @retval:None.
+ * @par Dependency:
+ * <ul><li>los_arch_interrupt.h: the header file that contains the API declaration.</li
+></ul>
+ * @see None.
+ */
+extern VOID HalHwiDefaultHandler(VOID);
+
+/* *
+ * @ingroup  los_arch_interrupt
+ * @brief: Reset the vector table.
+ *
+ * @par Description:
+ * This API is used to reset the vector table.
+ *
+ * @attention:
+ * <ul><li>None.</li></ul>
+ *
+ * @param:None.
+ *
+ * @retval:None.
+ * @par Dependency:
+ * <ul><li>los_arch_interrupt.h: the header file that contains the API declaration.</li></ul>
+ * @see None.
+ */
+extern VOID Reset_Handler(VOID);
+
+/* *
+ * @ingroup  los_arch_interrupt
+ * @brief: Pended System Call.
+ *
+ * @par Description:
+ * PendSV can be pended and is useful for an OS to pend an exception
+ * so that an action can be performed after other important tasks are completed.
+ *
+ * @attention:
+ * <ul><li>None.</li></ul>
+ *
+ * @param:None.
+ *
+ * @retval:None.
+ * @par Dependency:
+ * <ul><li>los_arch_interrupt.h: the header file that contains the API declaration.</li></ul>
+ * @see None.
+ */
+extern VOID HalPendSV(VOID);
+
+
+#define OS_EXC_IN_INIT                      0
+#define OS_EXC_IN_TASK                      1
+#define OS_EXC_IN_HWI                       2
+
+#define OS_EXC_MAX_BUF_LEN                  25
+#define OS_EXC_MAX_NEST_DEPTH               1
+
+#define OS_NVIC_SHCSR                       0xE000ED24
+#define OS_NVIC_CCR                         0xE000ED14
+
+#define OS_NVIC_INT_ENABLE_SIZE             0x20
+#define OS_NVIC_INT_PRI_SIZE                0xF0
+#define OS_NVIC_EXCPRI_SIZE                 0xC
+#define OS_NVIC_INT_CTRL_SIZE               4
+#define OS_NVIC_SHCSR_SIZE                  4
+
+#define OS_NVIC_INT_PEND_SIZE               OS_NVIC_INT_ACT_SIZE
+#define OS_NVIC_INT_ACT_SIZE                OS_NVIC_INT_ENABLE_SIZE
+
+#define OS_EXC_FLAG_NO_FLOAT                0x10000000
+#define OS_EXC_FLAG_FAULTADDR_VALID         0x01
+#define OS_EXC_FLAG_IN_HWI                  0x02
+
+#define OS_EXC_IMPRECISE_ACCESS_ADDR        0xABABABAB
+
+#define OS_EXC_EVENT                        0x00000001
+
+/**
+ * @ingroup los_exc
+ * the struct of register files
+ *
+ * description: the register files that saved when exception triggered
+ *
+ * notes:the following register with prefix 'uw'  correspond to the registers in the cpu  data sheet.
+ */
+typedef struct TagExcContext {
+    UINT32 uwPSR;
+    UINT32 uwR0;
+    UINT32 uwR1;
+    UINT32 uwR2;
+    UINT32 uwR3;
+    UINT32 uwR4;
+    UINT32 uwR5;
+    UINT32 uwR6;
+    UINT32 uwR7;
+    UINT32 uwR8;
+    UINT32 uwR9;
+    UINT32 uwR10;
+    UINT32 uwR11;
+    UINT32 uwR12;
+    UINT32 uwLR;
+    UINT32 uwPC;
+} EXC_CONTEXT_S;
+
+typedef VOID (*EXC_PROC_FUNC)(UINT32, EXC_CONTEXT_S *);
+VOID HalExcHandleEntry(UINT32 excType, UINT32 faultAddr, UINT32 pid, EXC_CONTEXT_S *excBufAddr);
+
+/**
+ * @ingroup  los_arch_interrupt
+ * @brief: Exception initialization.
+ *
+ * @par Description:
+ * This API is used to configure the exception function vector table.
+ *
+ * @attention:
+ * <ul><li>None.</li></ul>
+ *
+ * @param uwArraySize [IN] Memory size of exception.
+ *
+ * @retval: None
+ * @par Dependency:
+ * <ul><li>los_arch_interrupt.h: the header file that contains the API declaration.</li></ul>
+ * @see None.
+ */
+VOID OsExcInit(VOID);
+
+VOID HalExcNMI(VOID);
+VOID HalExcHardFault(VOID);
+VOID HalExcMemFault(VOID);
+VOID HalExcBusFault(VOID);
+VOID HalExcUsageFault(VOID);
+VOID HalExcSvcCall(VOID);
+VOID HalHwiInit();
+
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: An error occurred while the bus status register was being pushed.
+ */
+#define OS_EXC_BF_STKERR           1
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: An error occurred while the bus status register was out of the stack.
+ */
+#define OS_EXC_BF_UNSTKERR         2
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: Bus status register imprecise data access violation.
+ */
+#define OS_EXC_BF_IMPRECISERR      3
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: Bus status register exact data access violation.
+ */
+#define OS_EXC_BF_PRECISERR        4
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: Bus status register access violation while pointing.
+ */
+#define OS_EXC_BF_IBUSERR          5
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: An error occurred while the memory management status register was being pushed.
+ */
+#define OS_EXC_MF_MSTKERR          6
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: An error occurred while the memory management status register was out of the stack.
+ */
+#define OS_EXC_MF_MUNSTKERR        7
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: Memory management status register data access violation.
+ */
+#define OS_EXC_MF_DACCVIOL         8
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: Memory management status register access violation.
+ */
+#define OS_EXC_MF_IACCVIOL         9
+
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: Incorrect usage indicating that the divisor is zero during the division operation.
+ */
+#define OS_EXC_UF_DIVBYZERO        10
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: Usage error, error caused by unaligned access.
+ */
+#define OS_EXC_UF_UNALIGNED        11
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: Incorrect usage attempting to execute coprocessor related instruction.
+ */
+#define OS_EXC_UF_NOCP             12
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: Usage error attempting to load EXC_RETURN to PC illegally on exception return.
+ */
+#define OS_EXC_UF_INVPC            13
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: Incorrect usage, attempting to cut to ARM state.
+ */
+#define OS_EXC_UF_INVSTATE         14
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: Incorrect usage. Executed instruction whose code is undefined.
+ */
+#define OS_EXC_UF_UNDEFINSTR       15
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: NMI
+ */
+
+#define OS_EXC_CAUSE_NMI           16
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: hard fault
+ */
+#define OS_EXC_CAUSE_HARDFAULT     17
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: The task handler exits.
+ */
+#define OS_EXC_CAUSE_TASK_EXIT     18
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: A fatal error.
+ */
+#define OS_EXC_CAUSE_FATAL_ERR     19
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: Hard Fault caused by a debug event.
+ */
+#define OS_EXC_CAUSE_DEBUGEVT      20
+
+/**
+ * @ingroup los_exc
+ * Cortex-M exception types: A hard fault that occurs when a quantity is oriented.
+ */
+#define OS_EXC_CAUSE_VECTBL        21
+
+/**
+ * @ingroup los_exc
+ * Exception information structure
+ *
+ * Description: Exception information saved when an exception is triggered on the Cortex-M4 platform.
+ *
+ */
+typedef struct TagExcInfo {
+    /**< Exception occurrence phase: 0 means that an exception occurs in initialization, 1 means that an exception occurs in a task, and 2 means that an exception occurs in an interrupt */
+    UINT16 phase;
+    /**< Exception type. When exceptions occur, check the numbers 1 - 19 listed above */
+    UINT16 type;
+    /**< If the exact address access error indicates the wrong access address when the exception occurred */
+    UINT32 faultAddr;
+    /**< An exception occurs in an interrupt, indicating the interrupt number. An exception occurs in the task, indicating the task ID, or 0xFFFFFFFF if it occurs during initialization */
+    UINT32 thrdPid;
+    /**< Number of nested exceptions. Currently only registered hook functions are supported when an exception is entered for the first time */
+    UINT16 nestCnt;
+    /**< reserve */
+    UINT16 reserved;
+    /**< Hardware context at the time an exception to the automatic stack floating-point register occurs */
+    EXC_CONTEXT_S *context;
+} ExcInfo;
+
+extern UINT32 g_curNestCount;
+extern UINT32 g_intCount;
+extern UINT8 g_uwExcTbl[32];
+extern ExcInfo g_excInfo;
+
+#define MAX_INT_INFO_SIZE       (8 + 0x164)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _LOS_ARCH_INTERRUPT_H */
diff --git a/kernel/liteos_m/kal/kal.c b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_timer.h
old mode 100755
new mode 100644
similarity index 63%
rename from kernel/liteos_m/kal/kal.c
rename to kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_timer.h
index 4e8e5b1..97ec28d
--- a/kernel/liteos_m/kal/kal.c
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_timer.h
@@ -1,72 +1,53 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "kal.h"
-#include "los_interrupt.h"
-#include "los_swtmr.h"
-
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cpluscplus */
-#endif /* __cpluscplus */
-
-#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
-osTimerId_t osTimerExtNew(osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr,
-    osTimerRouses_t ucRouses, osTimerAlign_t ucSensitive)
-{
-    UNUSED(attr);
-    UINT32 usSwTmrID;
-    UINT8 mode;
-
-    if ((OS_INT_ACTIVE) || (NULL == func) || ((osTimerOnce != type) && (osTimerPeriodic != type))) {
-        return (osTimerId_t)NULL;
-    }
-
-    if (osTimerOnce == type) {
-        mode = LOS_SWTMR_MODE_NO_SELFDELETE;
-    } else {
-        mode = LOS_SWTMR_MODE_PERIOD;
-    }
-    if (LOS_OK != LOS_SwtmrCreate(1, mode, (SWTMR_PROC_FUNC)func, &usSwTmrID,
-        (UINT32)(UINTPTR)argument, ucRouses, ucSensitive)) {
-        return (osTimerId_t)NULL;
-    }
-
-    return (osTimerId_t)OS_SWT_FROM_SID(usSwTmrID);
-}
-#endif
-
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cpluscplus */
-#endif /* __cpluscplus */
\ No newline at end of file
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_ARCH_TIMER_H
+#define _LOS_ARCH_TIMER_H
+
+#include "los_config.h"
+#include "los_compiler.h"
+#include "los_context.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+UINT32 HalTickStart(OS_TICK_HANDLER handler);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _LOS_ARCH_TIMER_H */
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_context.c b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_context.c
new file mode 100644
index 0000000..b4d771e
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_context.c
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "los_context.h"
+#include "los_arch_context.h"
+#include "los_arch_interrupt.h"
+#include "los_task.h"
+#include "los_sched.h"
+#include "los_interrupt.h"
+#include "los_arch_timer.h"
+#include "securec.h"
+
+UINT32 g_sysNeedSched = 0;
+extern unsigned int g_intSave;
+
+/* ****************************************************************************
+ Function    : HalArchInit
+ Description : arch init function
+ Input       : None
+ Output      : None
+ Return      : None
+ **************************************************************************** */
+LITE_OS_SEC_TEXT_INIT VOID HalArchInit(VOID)
+{
+    HalHwiInit();
+}
+
+/* ****************************************************************************
+ Function    : HalSysExit
+ Description : Task exit function
+ Input       : None
+ Output      : None
+ Return      : None
+ **************************************************************************** */
+LITE_OS_SEC_TEXT_MINOR VOID HalSysExit(VOID)
+{
+    LOS_IntLock();
+    while (1) {
+		;
+    }
+}
+
+/* ****************************************************************************
+ Function    : HalTskStackInit
+ Description : Task stack initialization function
+ Input       : taskID     --- TaskID
+               stackSize  --- Total size of the stack
+               topStack    --- Top of task's stack
+ Output      : None
+ Return      : Context pointer
+ **************************************************************************** */
+LITE_OS_SEC_TEXT_INIT VOID *HalTskStackInit(UINT32 taskID, UINT32 stack_size, VOID *topStack)
+{
+    TaskContext *context = NULL;
+    errno_t result;
+
+    /* initialize the task stack, write magic num to stack top */
+    result = memset_s(topStack, stack_size, (INT32)(OS_TASK_STACK_INIT & 0xFF), stack_size);
+    if (result != EOK) {
+        printf("memset_s is failed:%s[%d]\r\n", __FUNCTION__, __LINE__);
+    }
+    *((UINT32 *)(topStack)) = OS_TASK_MAGIC_WORD;
+
+    context = (TaskContext *)(((UINTPTR)topStack + stack_size) - sizeof(TaskContext));
+
+    context->uwR0 = taskID;
+    context->uwR1 = 0x01010101L;
+    context->uwR2 = 0x02020202L;
+    context->uwR3 = 0x03030303L;
+    context->uwR4 = 0x04040404L;
+    context->uwR5 = 0x05050505L;
+    context->uwR6 = 0x06060606L;
+    context->uwR7 = 0x07070707L;
+    context->uwR8 = 0x08080808L;
+    context->uwR9 = 0x09090909L;
+    context->uwR10 = 0x10101010L;
+    context->uwR11 = 0x11111111L;
+    context->uwR12 = 0x12121212L;
+    context->uwLR = (UINT32)(UINTPTR)HalSysExit;
+    context->uwPC = (UINT32)(UINTPTR)OsTaskEntry;
+	
+	if ((UINTPTR)OsTaskEntry & 0x01)
+	   context->uwPSR = PSR_MODE_SVC_THUMB;
+	else
+	   context->uwPSR = PSR_MODE_SVC_ARM;
+
+    return (VOID *)context;
+}
+
+LITE_OS_SEC_TEXT_INIT UINT32 HalStartSchedule(OS_TICK_HANDLER handler)
+{
+    (VOID)LOS_IntLock();
+    UINT32 ret = HalTickStart(handler);
+    if (ret != LOS_OK) {
+        return ret;
+    }
+    OsSchedStart();
+    HalStartToRun();
+
+    return LOS_OK; /* never return */
+}
+
+LITE_OS_SEC_TEXT_INIT VOID dmb(VOID)
+{
+    __asm__ __volatile__("" : : : "memory");
+}
+
+LITE_OS_SEC_TEXT_INIT VOID dsb(VOID)
+{
+    __asm__ __volatile__("mcr p15, 0, %0, c7, c10, 4" : : "r"(0) : "memory");
+}
+
+LITE_OS_SEC_TEXT_INIT VOID isb(VOID)
+{
+    __asm__ __volatile__("" : : : "memory");
+}
+
+LITE_OS_SEC_TEXT_INIT VOID wfi(VOID)
+{
+    __asm__ __volatile__("mcr p15, 0, %0, c7, c0, 4" : : "r"(0) : "memory");
+}
+// eof
+
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_dispatch.S b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_dispatch.S
new file mode 100644
index 0000000..80f387a
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_dispatch.S
@@ -0,0 +1,243 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+	.equ    ARM_PSR_THUMB,     0x20
+	.equ    ARM_PSR_INT_DIS,   0xC0
+	.equ    ARM_PSR_FIQ_DIS,   0x40
+	.equ    ARM_PSR_IRQ_DIS,   0x80
+	.equ    ARM_PSR_MODE_MASK, 0x1F
+	.equ    ARM_PSR_MODE_USR,  0x10
+	.equ    ARM_PSR_MODE_FIQ,  0x11
+	.equ    ARM_PSR_MODE_IRQ,  0x12
+	.equ    ARM_PSR_MODE_SVC,  0x13
+	.equ    ARM_PSR_MODE_ABT,  0x17
+	.equ    ARM_PSR_MODE_UND,  0x1B
+	.equ    ARM_PSR_MODE_SYS,  0x1F
+
+	.global _arm_exception_irq_handler
+	.global _arm_exception_fiq_handler
+	.global HalTaskSchedule
+	.global HalStartToRun
+	.global HalFiqBreakinIrqGet
+	.global HalFiqBreakinIrqSet
+	.global HalFiqBreakinIrqClear
+
+	.extern g_sysNeedSched
+	.extern g_intCount
+	.extern g_fiqBreakIrqFlag
+
+.code 32
+.text
+
+HalStartToRun:
+    MSR     CPSR_c, #(ARM_PSR_INT_DIS | ARM_PSR_FIQ_DIS | ARM_PSR_MODE_SVC)
+
+    LDR     R1, =g_losTask
+    LDR     R0, [R1, #4]
+    LDR     SP, [R0]
+
+    LDMFD   SP!, {R0}
+    MSR     SPSR_cxsf, R0
+
+    LDMFD   SP!, {R0-R12, LR, PC}^
+			
+	.globl HalTaskSchedule
+	.type HalTaskSchedule, %function
+HalTaskSchedule:
+    STMFD   SP!, {LR}
+    STMFD   SP!, {LR}
+    STMFD   SP!, {R0-R12}
+
+    MRS     R0, CPSR
+    MRS     R1, CPSR
+    ORR     R1, #(ARM_PSR_IRQ_DIS | ARM_PSR_FIQ_DIS)
+    MSR     CPSR, R1
+
+    TST     LR, #1
+    ORRNE   R0, R0, #ARM_PSR_THUMB
+    STMFD   SP!, {R0}
+
+    LDR     R1, =g_fiqBreakIrqFlag
+    LDR     R1, [R1]
+    CMP     R1, #1
+    BEQ     InterruptContextLoad
+
+    LDR     R1, =g_sysNeedSched
+    MOV     R2, #1
+    STR     R2, [R1]
+
+    LDR     R0, =g_intCount
+    LDR     R0, [R0]
+    CMP     R0, #0
+    BNE     TaskContextLoad
+    STR     R0, [R1]
+
+    BLX     OsSchedTaskSwitch
+    CMP     R0, #0
+    BNE     NewTaskContextSwitch
+    B       TaskContextLoad
+
+_arm_exception_fiq_handler:
+
+	STMFD SP!,{R0}
+
+	MRS R0, spsr
+	AND R0, R0, #ARM_PSR_MODE_MASK
+	CMP R0, #ARM_PSR_MODE_IRQ
+	BEQ _fiq_break_irq
+
+	LDMIA SP!, {R0}
+
+	LDR     SP, =__fiq_stack_top
+
+	SUB     LR, LR, #4
+	STMFD   SP!, {R0-R2}
+
+	MOV     R0, SP
+	MRS     R1, SPSR
+	MOV     R2, LR
+
+	MSR     CPSR_c, #(ARM_PSR_IRQ_DIS | ARM_PSR_FIQ_DIS | ARM_PSR_MODE_SVC)
+	STMFD   SP!, {R2}
+	STMFD   SP!, {LR}
+	STMFD   SP!, {R3-R12}
+	LDMIA   R0!, {R5-R7}
+	STMFD   SP!, {R5-R7}
+	STMFD   SP!, {R1}
+
+	LDR     R2, =g_losTask
+	LDR     R3, [R2]
+	STR     SP, [R3]
+
+	LDR     SP, =__svc_stack_top
+
+	BLX     HalInterrupt_fiq
+
+	LDR     R0, =g_losTaskLock
+	LDR     R0, [R0]
+	CMP     R0, #0
+	BNE     NoTaskContextSwitch
+
+	LDR     R0, =g_sysNeedSched
+	LDR     R0, [R0]
+	CMP     R0, #0
+	BNE     NeedTaskSwitch
+	B       NoTaskContextSwitch
+	
+_fiq_break_irq:		
+	LDMIA SP!, {R0}
+	STMFD	SP!, {r0-r7,LR}
+	NOP
+	NOP
+
+	BLX     HalFiqBreakinIrqSet
+	BLX     HalInterrupt_fiq
+	BLX     HalFiqBreakinIrqClear
+	
+	LDMIA	SP!, {r0-r7,LR}
+	NOP
+	NOP
+
+	SUBS    pc, LR, #0x4
+
+_arm_exception_irq_handler:
+	LDR     SP, =__irq_stack_top
+
+	SUB     LR, LR, #4
+	STMFD   SP!, {R0-R2}
+
+	MOV     R0, SP
+	MRS     R1, SPSR
+	MOV     R2, LR
+
+	MSR     CPSR_c, #(ARM_PSR_IRQ_DIS | ARM_PSR_FIQ_DIS | ARM_PSR_MODE_SVC)
+	STMFD   SP!, {R2}
+	STMFD   SP!, {LR}
+	STMFD   SP!, {R3-R12}
+	LDMFD   R0!, {R5-R7}
+	STMFD   SP!, {R5-R7}
+	STMFD   SP!, {R1}
+
+	LDR     R2, =g_losTask
+	LDR     R3, [R2]
+	STR     SP, [R3]
+
+	LDR     SP, =__svc_stack_top
+
+	BLX     HalInterrupt_irq
+
+	LDR     R0, =g_losTaskLock
+	LDR     R0, [R0]
+	CMP     R0, #0
+	BNE     NoTaskContextSwitch
+
+	LDR     R0, =g_sysNeedSched
+	LDR     R0, [R0]
+	CMP     R0, #0
+	BNE     NeedTaskSwitch
+	B       NoTaskContextSwitch
+
+NeedTaskSwitch:
+	LDR     R0, =g_sysNeedSched
+	MOV     R1, #0
+	STR     R1, [R0]
+	BLX     OsSchedTaskSwitch
+	CMP     R0, #0
+	BEQ     NoTaskContextSwitch
+	LDR     R0, =g_losTask
+	LDR     R1, [R0, #4]
+	STR     R1, [R0]
+	LDR     SP, [R1]
+	B       TaskContextLoad
+
+NewTaskContextSwitch:
+	LDR     R0, =g_losTask
+	LDR     R1, [R0]
+	STR     SP, [R1]
+
+	LDR     R1, [R0, #4]
+	STR     R1, [R0]
+	LDR     SP, [R1]
+	B       TaskContextLoad
+
+NoTaskContextSwitch:
+	LDR     R1, =g_losTask
+	LDR     R1, [R1]
+	LDR     SP, [R1]
+
+TaskContextLoad:
+	LDMFD   SP!, {R0}
+	MSR     SPSR_cxsf, R0
+	LDMFD   SP!, {R0-R12, LR, PC}^
+
+InterruptContextLoad:
+	LDMFD   SP!, {R0}
+	LDMFD   SP!, {R0-R12, LR, PC}
+
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/include/netdb.h b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_exc.S
similarity index 88%
rename from kernel/liteos_m/components/net/lwip-2.1/porting/include/netdb.h
rename to kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_exc.S
index 5043cf0..8492d18 100644
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/include/netdb.h
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_exc.S
@@ -1,39 +1,35 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __LITEOS_NETDB_PORTING_H__
-#define __LITEOS_NETDB_PORTING_H__
-
-#include "lwip/netdb.h"
-
-struct hostent *gethostbyname(const char *name);
-
-#endif // __LITEOS_NETDB_PORTING_H__
\ No newline at end of file
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+	.global  _arm_exception_swi_handler
+
+_arm_exception_swi_handler:
+    B .
+
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_interrupt.c b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_interrupt.c
new file mode 100644
index 0000000..87eec20
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_interrupt.c
@@ -0,0 +1,380 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "los_interrupt.h"
+#include <stdarg.h>
+#include "securec.h"
+#include "los_context.h"
+#include "los_arch_interrupt.h"
+#include "los_debug.h"
+#include "los_hook.h"
+#include "los_task.h"
+#include "los_sched.h"
+#include "los_memory.h"
+#include "los_membox.h"
+#include "los_reg.h"
+#include "intc_pub.h"
+
+UINT32 g_intCount = 0;
+ExcInfo g_excInfo = {0};
+UINT32 g_fiqBreakIrqFlag = 0;
+
+extern void intc_irq(void);
+extern void intc_fiq(void);
+
+LITE_OS_SEC_TEXT_MINOR UINT32 HalFiqBreakinIrqGet(VOID)
+{
+    return g_fiqBreakIrqFlag;
+}
+
+LITE_OS_SEC_TEXT_MINOR VOID HalFiqBreakinIrqSet(VOID)
+{
+    g_fiqBreakIrqFlag = 1;
+}
+
+LITE_OS_SEC_TEXT_MINOR VOID HalFiqBreakinIrqClear(VOID)
+{
+    g_fiqBreakIrqFlag = 0;
+}
+
+/* ****************************************************************************
+ Function    : HalIntNumGet
+ Description : Get an interrupt number
+ Input       : None
+ Output      : None
+ Return      : Interrupt Indexes number
+ **************************************************************************** */
+LITE_OS_SEC_TEXT_MINOR UINT32 HalIntNumGet(VOID)
+{
+    return 0;
+}
+
+inline UINT32 HalIsIntActive(VOID)
+{
+    return (g_intCount > 0);
+}
+/* ****************************************************************************
+ Function    : HalHwiDefaultHandler
+ Description : default handler of the hardware interrupt
+ Input       : None
+ Output      : None
+ Return      : None
+ **************************************************************************** */
+/*lint -e529*/
+LITE_OS_SEC_TEXT_MINOR VOID HalHwiDefaultHandler(VOID)
+{
+    UINT32 irqNum = HalIntNumGet();
+    PRINT_ERR("%s irqnum:%d\n", __FUNCTION__, irqNum);
+	
+    while (1) 
+	{
+		;
+	}
+
+	(void)irqNum;
+}
+
+VOID HalIrqMask(UINT32 vector)
+{
+    return;
+}
+
+VOID HalIrqUnmask(UINT32 vector)
+{
+    return;
+}
+
+
+/* ****************************************************************************
+ Function    : HalInterrupt_irq
+ Description : Hardware interrupt entry function
+ Input       : None
+ Output      : None
+ Return      : None
+ **************************************************************************** */
+LITE_OS_SEC_TEXT VOID HalInterrupt_irq(VOID)
+{
+    UINT32 intSave = 0;
+
+    intSave = LOS_IntLock();
+    g_intCount++;
+    LOS_IntRestore(intSave);
+
+#if (LOSCFG_BASE_CORE_SCHED_SLEEP == 1)
+    OsSchedUpdateSleepTime();
+#endif
+
+    /* Interrupt handling function. */
+    intc_irq();
+
+    intSave = LOS_IntLock();
+    g_intCount--;
+    LOS_IntRestore(intSave);
+}
+
+
+/* ****************************************************************************
+ Function    : HalInterrupt_fiq
+ Description : Hardware interrupt entry function
+ Input       : None
+ Output      : None
+ Return      : None
+ **************************************************************************** */
+LITE_OS_SEC_TEXT VOID HalInterrupt_fiq(VOID)
+{
+    UINT32 intSave = 0;
+
+    intSave = LOS_IntLock();
+    g_intCount++;
+    LOS_IntRestore(intSave);
+
+#if (LOSCFG_BASE_CORE_SCHED_SLEEP == 1)
+    OsSchedUpdateSleepTime();
+#endif
+
+    /* Interrupt handling function. */
+    intc_fiq();
+
+    intSave = LOS_IntLock();
+    g_intCount--;
+    LOS_IntRestore(intSave);
+}
+
+/* ****************************************************************************
+ Function    : HalHwiCreate
+ Description : create hardware interrupt
+ Input       : hwiNum   --- hwi num to create
+               hwiPrio  --- priority of the hwi
+               mode     --- unused
+               handler --- hwi handler
+               arg      --- param of the hwi handler
+ Output      : None
+ Return      : LOS_OK on success or error code on failure
+ **************************************************************************** */
+LITE_OS_SEC_TEXT_INIT UINT32 HalHwiCreate(HWI_HANDLE_T hwiNum,
+                                          HWI_PRIOR_T hwiPrio,
+                                          HWI_MODE_T mode,
+                                          HWI_PROC_FUNC handler,
+                                          HWI_ARG_T arg)
+{
+	bk_printf("HalHwiCreate TODO\r\n");
+	intc_service_register((UINT8)hwiNum, (UINT8)hwiPrio, (FUNCPTR)handler);
+    return LOS_OK;
+}
+
+/* ****************************************************************************
+ Function    : HalHwiDelete
+ Description : Delete hardware interrupt
+ Input       : hwiNum   --- hwi num to delete
+ Output      : None
+ Return      : LOS_OK on success or error code on failure
+ **************************************************************************** */
+LITE_OS_SEC_TEXT_INIT UINT32 HalHwiDelete(HWI_HANDLE_T hwiNum)
+{
+	bk_printf("HalHwiDelete TODO\r\n");
+	intc_service_unregister((UINT8)hwiNum);
+    return LOS_OK;
+}
+
+LITE_OS_SEC_TEXT_INIT UINT32 HalHwiTrigger(HWI_HANDLE_T hwiNum)
+{
+	bk_printf("HalHwiTrigger TODO\r\n");
+	intc_service_trigger((UINT8)hwiNum);
+    return LOS_OK;
+}
+
+#if (LOSCFG_KERNEL_PRINTF != 0)
+STATIC VOID OsExcTypeInfo(const ExcInfo *excInfo)
+{
+    CHAR *phaseStr[] = {"exc in init", "exc in task", "exc in hwi"};
+
+    PRINTK("Type      = %d\n", excInfo->type);
+    PRINTK("ThrdPid   = %d\n", excInfo->thrdPid);
+    PRINTK("Phase     = %s\n", phaseStr[excInfo->phase]);
+    PRINTK("FaultAddr = 0x%x\n", excInfo->faultAddr);
+}
+
+STATIC VOID OsExcCurTaskInfo(const ExcInfo *excInfo)
+{
+    PRINTK("Current task info:\n");
+    if (excInfo->phase == OS_EXC_IN_TASK) {
+        LosTaskCB *taskCB = OS_TCB_FROM_TID(LOS_CurTaskIDGet());
+        PRINTK("Task name = %s\n", taskCB->taskName);
+        PRINTK("Task ID   = %d\n", taskCB->taskID);
+        PRINTK("Task SP   = 0x%x\n", taskCB->stackPointer);
+        PRINTK("Task ST   = 0x%x\n", taskCB->topOfStack);
+        PRINTK("Task SS   = 0x%x\n", taskCB->stackSize);
+    } else if (excInfo->phase == OS_EXC_IN_HWI) {
+        PRINTK("Exception occur in interrupt phase!\n");
+    } else {
+        PRINTK("Exception occur in system init phase!\n");
+    }
+}
+
+STATIC VOID OsExcRegInfo(const ExcInfo *excInfo)
+{
+    PRINTK("Exception reg dump:\n");
+    PRINTK("PC        = 0x%x\n", excInfo->context->uwPC);
+    PRINTK("LR        = 0x%x\n", excInfo->context->uwLR);
+    PRINTK("R0        = 0x%x\n", excInfo->context->uwR0);
+    PRINTK("R1        = 0x%x\n", excInfo->context->uwR1);
+    PRINTK("R2        = 0x%x\n", excInfo->context->uwR2);
+    PRINTK("R3        = 0x%x\n", excInfo->context->uwR3);
+    PRINTK("R4        = 0x%x\n", excInfo->context->uwR4);
+    PRINTK("R5        = 0x%x\n", excInfo->context->uwR5);
+    PRINTK("R6        = 0x%x\n", excInfo->context->uwR6);
+    PRINTK("R7        = 0x%x\n", excInfo->context->uwR7);
+    PRINTK("R8        = 0x%x\n", excInfo->context->uwR8);
+    PRINTK("R9        = 0x%x\n", excInfo->context->uwR9);
+    PRINTK("R10       = 0x%x\n", excInfo->context->uwR10);
+    PRINTK("R11       = 0x%x\n", excInfo->context->uwR11);
+    PRINTK("R12       = 0x%x\n", excInfo->context->uwR12);
+    PRINTK("xPSR      = 0x%x\n", excInfo->context->uwPSR);
+}
+
+STATIC VOID OsExcBackTraceInfo(const ExcInfo *excInfo)
+{
+    UINTPTR LR[LOSCFG_BACKTRACE_DEPTH] = {0};
+    UINT32 index;
+
+    OsBackTraceHookCall(LR, LOSCFG_BACKTRACE_DEPTH, 0, 0);
+
+    PRINTK("----- backtrace start -----\n");
+    for (index = 0; index < LOSCFG_BACKTRACE_DEPTH; index++) {
+        if (LR[index] == 0) {
+            break;
+        }
+        PRINTK("backtrace %d -- lr = 0x%x\n", index, LR[index]);
+    }
+    PRINTK("----- backtrace end -----\n");
+}
+
+STATIC VOID OsExcMemPoolCheckInfo(VOID)
+{
+    PRINTK("\r\nmemory pools check:\n");
+#if (LOSCFG_PLATFORM_EXC == 1)
+    MemInfoCB memExcInfo[OS_SYS_MEM_NUM];
+    UINT32 errCnt;
+    UINT32 i;
+
+    (VOID)memset_s(memExcInfo, sizeof(memExcInfo), 0, sizeof(memExcInfo));
+
+    errCnt = OsMemExcInfoGet(OS_SYS_MEM_NUM, memExcInfo);
+    if (errCnt < OS_SYS_MEM_NUM) {
+        errCnt += OsMemboxExcInfoGet(OS_SYS_MEM_NUM - errCnt, memExcInfo + errCnt);
+    }
+
+    if (errCnt == 0) {
+        PRINTK("all memory pool check passed!\n");
+        return;
+    }
+
+    for (i = 0; i < errCnt; i++) {
+        PRINTK("pool num    = %d\n", i);
+        PRINTK("pool type   = %d\n", memExcInfo[i].type);
+        PRINTK("pool addr   = 0x%x\n", memExcInfo[i].startAddr);
+        PRINTK("pool size   = 0x%x\n", memExcInfo[i].size);
+        PRINTK("pool free   = 0x%x\n", memExcInfo[i].free);
+        PRINTK("pool blkNum = %d\n", memExcInfo[i].blockSize);
+        PRINTK("pool error node addr  = 0x%x\n", memExcInfo[i].errorAddr);
+        PRINTK("pool error node len   = 0x%x\n", memExcInfo[i].errorLen);
+        PRINTK("pool error node owner = %d\n", memExcInfo[i].errorOwner);
+    }
+#endif
+    UINT32 ret = LOS_MemIntegrityCheck(LOSCFG_SYS_HEAP_ADDR);
+    if (ret == LOS_OK) {
+        PRINTK("system heap memcheck over, all passed!\n");
+    }
+
+    PRINTK("memory pool check end!\n");
+}
+#endif
+
+STATIC VOID OsExcInfoDisplay(const ExcInfo *excInfo)
+{
+#if (LOSCFG_KERNEL_PRINTF != 0)
+    PRINTK("*************Exception Information**************\n");
+    OsExcTypeInfo(excInfo);
+    OsExcCurTaskInfo(excInfo);
+    OsExcRegInfo(excInfo);
+    OsExcBackTraceInfo(excInfo);
+    OsGetAllTskInfo();
+    OsExcMemPoolCheckInfo();
+#endif
+}
+
+LITE_OS_SEC_TEXT_INIT VOID HalExcHandleEntry(UINT32 excType, UINT32 faultAddr, UINT32 pid, EXC_CONTEXT_S *excBufAddr)
+{
+    UINT16 tmpFlag = (excType >> 16) & OS_NULL_SHORT; /* 16: Get Exception Type */
+    g_intCount++;
+    g_excInfo.nestCnt++;
+
+    g_excInfo.type = excType & OS_NULL_SHORT;
+
+    if (tmpFlag & OS_EXC_FLAG_FAULTADDR_VALID) {
+        g_excInfo.faultAddr = faultAddr;
+    } else {
+        g_excInfo.faultAddr = OS_EXC_IMPRECISE_ACCESS_ADDR;
+    }
+    if (g_losTask.runTask != NULL) {
+        if (tmpFlag & OS_EXC_FLAG_IN_HWI) {
+            g_excInfo.phase = OS_EXC_IN_HWI;
+            g_excInfo.thrdPid = pid;
+        } else {
+            g_excInfo.phase = OS_EXC_IN_TASK;
+            g_excInfo.thrdPid = g_losTask.runTask->taskID;
+        }
+    } else {
+        g_excInfo.phase = OS_EXC_IN_INIT;
+        g_excInfo.thrdPid = OS_NULL_INT;
+    }
+    if (excType & OS_EXC_FLAG_NO_FLOAT) {
+        g_excInfo.context = (EXC_CONTEXT_S *)((CHAR *)excBufAddr - LOS_OFF_SET_OF(EXC_CONTEXT_S, uwR4));
+    } else {
+        g_excInfo.context = excBufAddr;
+    }
+
+    OsDoExcHook(EXC_INTERRUPT);
+    OsExcInfoDisplay(&g_excInfo);
+    HalSysExit();
+}
+
+/* ****************************************************************************
+ Function    : HalHwiInit
+ Description : initialization of the hardware interrupt
+ Input       : None
+ Output      : None
+ Return      : None
+ **************************************************************************** */
+LITE_OS_SEC_TEXT_INIT VOID HalHwiInit(VOID)
+{
+    return;
+}
+
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_timer.c b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_timer.c
new file mode 100644
index 0000000..bb2db84
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_timer.c
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "los_config.h"
+#include "los_sched.h"
+#include "los_arch_context.h"
+
+VOID HalEnterSleep(LOS_SysSleepEnum sleep)
+{
+#if (LOSCFG_BASE_CORE_SCHED_SLEEP == 1)
+    if (sleep == OS_SYS_DEEP_SLEEP) {
+        OsSchedToSleep();
+    }
+#endif
+
+    dsb();
+    wfi();
+    isb();
+}
+// eof
+
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/reset_vector.S b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/reset_vector.S
new file mode 100644
index 0000000..427cf63
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/reset_vector.S
@@ -0,0 +1,148 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+    .equ CPSR_IRQ_DISABLE, 0x80U
+    .equ CPSR_FIQ_DISABLE, 0x40U
+    .equ CPSR_THUMB_ENABLE, 0x20U
+    .equ CPSR_USER_MODE, 0x10U
+    .equ CPSR_FIQ_MODE, 0x11U
+    .equ CPSR_IRQ_MODE, 0x12U
+    .equ CPSR_SVC_MODE, 0x13U
+    .equ CPSR_ABT_MODE, 0x17U
+    .equ CPSR_UNDEF_MODE, 0x1BU
+    .equ EXC_STACK_INIT, 0xCACACACA
+    .equ EXC_MAGIC_WORD, 0xCCCCCCCC
+
+    .global __exc_stack_top
+    .global __irq_stack_top
+    .global __fiq_stack_top
+    .global __svc_stack_top
+    .global __abt_stack_top
+    .global __undef_stack_top
+    .global __exc_stack
+    .global __irq_stack
+    .global __fiq_stack
+    .global __svc_stack
+    .global __abt_stack
+    .global __undef_stack
+    .global main
+
+    .extern _osExceptFiqHdl
+    .extern _osExceptAddrAbortHdl
+    .extern _osExceptDataAbortHdl
+    .extern _osExceptPrefetchAbortHdl
+    .extern _osExceptSwiHdl
+    .extern _osExceptUndefInstrHdl
+    .extern _osExceptIrqHdl
+    .extern _bss_start
+    .extern _bss_end
+
+    .section ".vectors", "ax"
+    .global _vector_start
+
+_vector_start:
+    B     _reset_vector
+    B     _osExceptUndefInstrHdl
+    B     _osExceptSwiHdl
+    B     _osExceptPrefetchAbortHdl
+    B     _osExceptDataAbortHdl
+    B     _osExceptAddrAbortHdl
+    B     _osExceptIrqHdl
+    B     _osExceptFiqHdl
+
+
+    .globl  _reset_vector
+    .section ".boot", "ax"
+
+_reset_vector:
+    MOV    R0, #(CPSR_IRQ_DISABLE | CPSR_FIQ_DISABLE | CPSR_IRQ_MODE)
+    MSR    CPSR, R0
+    LDR    SP, =__irq_stack_top
+
+    MOV    R0, #(CPSR_IRQ_DISABLE | CPSR_FIQ_DISABLE | CPSR_UNDEF_MODE)
+    MSR    CPSR, R0
+    LDR    SP, =__undef_stack_top
+
+    MOV    R0, #(CPSR_IRQ_DISABLE | CPSR_FIQ_DISABLE | CPSR_ABT_MODE)
+    MSR    CPSR, R0
+    LDR    SP, =__abt_stack_top
+
+    MOV    R0, #(CPSR_IRQ_DISABLE | CPSR_FIQ_DISABLE | CPSR_FIQ_MODE)
+    MSR    CPSR, R0
+    LDR    SP, =__fiq_stack_top
+
+    MOV    R0, #(CPSR_IRQ_DISABLE | CPSR_FIQ_DISABLE | CPSR_SVC_MODE)
+    MSR    CPSR, R0
+    MSR    SPSR, R0
+    LDR    SP, =__svc_stack_top
+
+    BL     bss_init
+
+    B      main
+    B      .
+
+bss_init:
+    LDR     R0, =_bss_start
+    LDR     R1, =_bss_end
+
+    MOV R3, R1
+    MOV R4, R0
+    MOV R2, #0
+1: CMP R4, R3
+    STRLO R2, [R4], #4
+    BLO 1b
+    BX LR
+
+    .section ".bss", "wa", %nobits
+    .align 3
+__undef_stack:
+    .space  32
+__undef_stack_top:
+
+__abt_stack:
+    .space  32
+__abt_stack_top:
+
+__irq_stack:
+    .space  64
+__irq_stack_top:
+
+__fiq_stack:
+    .space  64
+__fiq_stack_top:
+
+__svc_stack:
+    .space  4096
+__svc_stack_top:
+
+__exc_stack:
+    .space  512
+__exc_stack_top:
diff --git a/kernel/liteos_m/kernel/arch/include/los_arch.h b/kernel/liteos_m/kernel/arch/include/los_arch.h
old mode 100755
new mode 100644
index 7ba4f7a..af75363
--- a/kernel/liteos_m/kernel/arch/include/los_arch.h
+++ b/kernel/liteos_m/kernel/arch/include/los_arch.h
@@ -38,16 +38,16 @@
 #ifdef __cplusplus
 #if __cplusplus
 extern "C" {
-#endif /* __cpluscplus */
-#endif /* __cpluscplus */
+#endif /* __cplusplus */
+#endif /* __cplusplus */
 
 VOID HalArchInit(VOID);
 
 #ifdef __cplusplus
 #if __cplusplus
 }
-#endif /* __cpluscplus */
-#endif /* __cpluscplus */
+#endif /* __cplusplus */
+#endif /* __cplusplus */
 
 #endif /* _LOS_ARCH_H */
 
diff --git a/kernel/liteos_m/kernel/arch/include/los_atomic.h b/kernel/liteos_m/kernel/arch/include/los_atomic.h
index 1fc1491..b0dae42 100644
--- a/kernel/liteos_m/kernel/arch/include/los_atomic.h
+++ b/kernel/liteos_m/kernel/arch/include/los_atomic.h
@@ -29,8 +29,8 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef LOS_ATOMIC_H
-#define LOS_ATOMIC_H
+#ifndef _LOS_ATOMIC_H
+#define _LOS_ATOMIC_H
 
 #include "los_compiler.h"
 
@@ -47,5 +47,5 @@ extern "C" {
 #endif /* __cplusplus */
 #endif /* __cplusplus */
 
-#endif /* LOS_ATOMIC_H */
+#endif /* _LOS_ATOMIC_H */
 
diff --git a/kernel/liteos_m/kernel/arch/include/los_context.h b/kernel/liteos_m/kernel/arch/include/los_context.h
index 058d710..caec14f 100644
--- a/kernel/liteos_m/kernel/arch/include/los_context.h
+++ b/kernel/liteos_m/kernel/arch/include/los_context.h
@@ -30,12 +30,12 @@
  */
 
 /**
- * @defgroup los_hw hardware
+ * @defgroup los_context hardware
  * @ingroup kernel
  */
 
-#ifndef _LOS_HW_H
-#define _LOS_HW_H
+#ifndef _LOS_CONTEXT_H
+#define _LOS_CONTEXT_H
 
 #include "los_compiler.h"
 
@@ -45,8 +45,8 @@ extern "C" {
 #endif /* __cplusplus */
 #endif /* __cplusplus */
 
-/* *
- * @ingroup  los_hw
+/**
+ * @ingroup  los_context
  * @brief: Task stack initialization.
  *
  * @par Description:
@@ -61,12 +61,13 @@ extern "C" {
  *
  * @retval: context Type#TaskContext *.
  * @par Dependency:
- * <ul><li>los_hw.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_context.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
-extern VOID *HalTskStackInit(UINT32 taskID, UINT32 stackSize, VOID *topStack);
+extern VOID *HalTskStackInit(UINT32 taskID, UINT32 stack_size, VOID *topStack);
+
 /**
- * @ingroup  los_hw
+ * @ingroup  los_context
  * @brief: Function to sys exit.
  *
  * @par Description:
@@ -79,12 +80,12 @@ extern VOID *HalTskStackInit(UINT32 taskID, UINT32 stackSize, VOID *topStack);
  *
  * @retval: None.
  * @par Dependency:
- * <ul><li>los_hw.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_context.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
-LITE_OS_SEC_TEXT_MINOR VOID HalSysExit(VOID);
+LITE_OS_SEC_TEXT_MINOR NORETURN VOID HalSysExit(VOID);
 
-/* *
+/**
  * @ingroup  los_context
  * @brief: Task scheduling Function.
  *
@@ -106,22 +107,19 @@ extern VOID HalTaskSchedule(VOID);
 typedef VOID (*OS_TICK_HANDLER)(VOID);
 UINT32 HalStartSchedule(OS_TICK_HANDLER handler);
 
-UINTPTR HalIntLock(VOID);
+UINT32 HalIntLock(VOID);
 #define LOS_IntLock HalIntLock
 
-VOID HalIntRestore(UINTPTR intSave);
+VOID HalIntRestore(UINT32 intSave);
 #define LOS_IntRestore HalIntRestore
 
-UINTPTR HalIntUnLock(VOID);
+UINT32 HalIntUnLock(VOID);
 #define LOS_IntUnLock HalIntUnLock
 
-
-
 #ifdef __cplusplus
 #if __cplusplus
 }
 #endif /* __cplusplus */
 #endif /* __cplusplus */
 
-#endif /* _LOS_HW_H */
-
+#endif /* _LOS_CONTEXT_H */
diff --git a/kernel/liteos_m/kernel/arch/include/los_interrupt.h b/kernel/liteos_m/kernel/arch/include/los_interrupt.h
old mode 100755
new mode 100644
index fb13b5d..ddaf4a7
--- a/kernel/liteos_m/kernel/arch/include/los_interrupt.h
+++ b/kernel/liteos_m/kernel/arch/include/los_interrupt.h
@@ -41,7 +41,7 @@ extern "C" {
 #endif /* __cplusplus */
 
 /* *
- * @ingroup los_config
+ * @ingroup los_interrupt
  * Configuration item for interrupt with argument
  */
 #ifndef OS_HWI_WITH_ARG
@@ -62,12 +62,17 @@ typedef VOID (*HWI_PROC_FUNC)(VOID *parm);
 typedef VOID (*HWI_PROC_FUNC)(void);
 #endif
 
-UINT32 HalIsIntAcvive(VOID);
-#define OS_INT_ACTIVE    (HalIsIntAcvive())
+/* stack protector */
+extern UINT32 __stack_chk_guard;
+
+extern VOID __stack_chk_fail(VOID);
+
+UINT32 HalIsIntActive(VOID);
+#define OS_INT_ACTIVE    (HalIsIntActive())
 #define OS_INT_INACTIVE  (!(OS_INT_ACTIVE))
 
-/* *
- * @ingroup  los_hwi
+/**
+ * @ingroup  los_interrupt
  * @brief Delete hardware interrupt.
  *
  * @par Description:
@@ -86,13 +91,14 @@ UINT32 HalIsIntAcvive(VOID);
  * @retval #OS_ERRNO_HWI_NUM_INVALID              0x02000900: Invalid interrupt number.
  * @retval #LOS_OK                                0         : The interrupt is successfully delete.
  * @par Dependency:
- * <ul><li>los_hwi.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_interrupt.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 HalHwiDelete(HWI_HANDLE_T hwiNum);
+extern UINT32 HalHwiTrigger(HWI_HANDLE_T hwiNum);
 
-/* *
- * @ingroup  los_hwi
+/**
+ * @ingroup  los_interrupt
  * @brief Create a hardware interrupt.
  *
  * @par Description:
@@ -118,7 +124,7 @@ extern UINT32 HalHwiDelete(HWI_HANDLE_T hwiNum);
  * @retval #OS_ERRNO_HWI_ALREADY_CREATED              0x02000904: The interrupt handler being created has already been created.
  * @retval #LOS_OK                                    0         : The interrupt is successfully created.
  * @par Dependency:
- * <ul><li>los_hwi.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_interrupt.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 HalHwiCreate(HWI_HANDLE_T hwiNum,
@@ -134,4 +140,3 @@ extern UINT32 HalHwiCreate(HWI_HANDLE_T hwiNum,
 #endif /* __cplusplus */
 
 #endif /* _LOS_INTERRUPT_H */
-
diff --git a/kernel/liteos_m/kernel/arch/include/los_mpu.h b/kernel/liteos_m/kernel/arch/include/los_mpu.h
old mode 100755
new mode 100644
index 17f1cc7..82a565f
--- a/kernel/liteos_m/kernel/arch/include/los_mpu.h
+++ b/kernel/liteos_m/kernel/arch/include/los_mpu.h
@@ -83,6 +83,7 @@ VOID HalMpuEnable(UINT32 defaultRegionEnable);
 VOID HalMpuDisable();
 UINT32 HalMpuSetRegion(UINT32 regionId, MPU_CFG_PARA *para);
 UINT32 HalMpuDisableRegion(UINT32 regionId);
+INT32 HalMpuUnusedRegionGet(VOID);
 
 #ifdef __cplusplus
 #if __cplusplus
diff --git a/kernel/liteos_m/kernel/arch/include/los_timer.h b/kernel/liteos_m/kernel/arch/include/los_timer.h
old mode 100755
new mode 100644
index e216c3f..52d2502
--- a/kernel/liteos_m/kernel/arch/include/los_timer.h
+++ b/kernel/liteos_m/kernel/arch/include/los_timer.h
@@ -29,8 +29,8 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef LOS_TIMER_H
-#define LOS_TIMER_H
+#ifndef _LOS_TIMER_H
+#define _LOS_TIMER_H
 
 #include "los_compiler.h"
 
@@ -67,42 +67,30 @@ VOID HalClearSysSleepFlag(VOID);
 
 VOID HalEnterSleep(LOS_SysSleepEnum sleep);
 
-VOID HalDelay(UINT32 ticks);
-
-UINT64 HalGetExpandTick(VOID);
-
-INT32 HalGetRtcTime(UINT64 *usec);
-
-INT32 HalGetRtcTimeZone(INT32 *timeZone);
-
-INT32 HalSetRtcTime(UINT64 utcTime, UINT64 *usec);
-
-INT32 HalSetRtcTimeZone(INT32 timeZone);
-
- /**
+/**
  * @ingroup los_timer
- * @brief Configure Tick Interrupt Start.
+ * @brief Get systick cycle.
  *
  * @par Description:
- * This API is used to configure Tick Interrupt Start while macro LOSCFG_BASE_CORE_TICK_HW_TIME is No.
+ * This API is used to get systick cycle and return current tick period.
  *
  * @attention
  * <ul>
  * <li>None.</li>
  * </ul>
  *
- * @param: None.
+ * @param: period [OUT] current tick period.
  *
- * @retval #LOS_OK                               0:configure Tick Interrupt success.
- * @retval #LOS_ERRNO_TICK_CFG_INVALID           0x02000400:configure Tick Interrupt failed.
+ * @retval current tick count.
  *
  * @par Dependency:
- * <ul><li>los_config.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_timer.h: the header file that contains the API declaration.</li></ul>
  * @see
  */
+UINT64 HalGetTickCycle(UINT32 *period);
 
 /**
- * @ingroup los_hwi
+ * @ingroup los_timer
  * @brief reconfig systick, and clear SysTick_IRQn.
  *
  * @par Description:
@@ -114,103 +102,14 @@ INT32 HalSetRtcTimeZone(INT32 timeZone);
  * <li>None.</li>
  * </ul>
  *
- * @param  cyclesPerTick  [IN] Cycles Per Tick
+ * @param  nextResponseTime  [IN] tick period
  *
  * @retval None.
  * @par Dependency:
- * <ul><li>los_hwi.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_timer.h: the header file that contains the API declaration.</li></ul>
  * @see None
  */
-extern VOID HalSysTickReload(UINT32 cyclesPerTick);
-
-/**
- * @ingroup los_hwi
- * @brief Get System cycle count.
- *
- * @par Description:
- * <ul>
- * <li>This API is used to Get System cycle count.</li>
- * </ul>
- * @attention
- * <ul>
- * <li>None.</li>
- * </ul>
- *
- * @param  None.
- *
- * @retval: The value of the system cycle count.
- * @par Dependency:
- * <ul><li>los_hwi.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_IntRestore
- */
-extern UINT32 HalSysTickCurrCycleGet(VOID);
-
-
-/* *
- * @ingroup los_hwi
- * @brief Get value from xPSR register.
- *
- * @par Description:
- * <ul>
- * <li>This API is used to Get value from xPSR register.</li>
- * </ul>
- * @attention
- * <ul>
- * <li>None.</li>
- * </ul>
- *
- * @param  cntHi  [IN] CpuTick High 4 byte
- * @param  cntLo  [IN] CpuTick Low 4 byte
- *
- * @retval None.
- * @par Dependency:
- * <ul><li>los_hwi.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_IntRestore
- */
-extern VOID HalGetCpuCycle(UINT32 *cntHi, UINT32 *cntLo);
-
-
-
-extern VOID HalGetSystickCycle(UINT32 *puwCntHi, UINT32 *puwCntLo);
-
-/**
- * @ingroup  los_tickless
- * @brief enable the tickless mode.
- *
- * @par Description:
- * This API is used to enable the tickless mode. System can change from periodic clock mode to dynamic clock mode.
- *
- * @attention
- * <ul>
- * </ul>
- *
- * @param  None.
- *
- * @retval None.
- * @par Dependency:
- * <ul><li>los_tickless.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_TicklessDisable
- */
-extern VOID HalTicklessEnable(VOID);
-/**
- * @ingroup  los_tickless
- * @brief disable the tickless mode.
- *
- * @par Description:
- * This API is used to diable the tickless mode. System will not change from periodic clock mode to dynamic clock mode.
- *
- * @attention
- * <ul>
- * </ul>
- *
- * @param  None.
- *
- * @retval None.
- * @par Dependency:
- * <ul><li>los_tickless.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_TicklessEnable
- */
-extern VOID HalTicklessDisable(VOID);
+extern VOID HalSysTickReload(UINT64 nextResponseTime);
 
 #ifdef __cplusplus
 #if __cplusplus
@@ -218,4 +117,4 @@ extern VOID HalTicklessDisable(VOID);
 #endif /* __cplusplus */
 #endif /* __cplusplus */
 
-#endif
\ No newline at end of file
+#endif /* _LOS_TIMER_H */
diff --git a/kernel/liteos_m/kernel/include/los_config.h b/kernel/liteos_m/kernel/include/los_config.h
old mode 100755
new mode 100644
index 04290cd..50d7d14
--- a/kernel/liteos_m/kernel/include/los_config.h
+++ b/kernel/liteos_m/kernel/include/los_config.h
@@ -49,6 +49,26 @@ extern "C" {
 /* =============================================================================
                                         System clock module configuration
 ============================================================================= */
+
+#ifndef LOS_BEKEN
+#define LOS_BEKEN              1
+#endif
+
+#if LOS_BEKEN
+#include "sys_config.h"
+
+#if (CFG_SOC_NAME == SOC_BK7231N)
+#define LOSCFG_SYS_HEAP_ADDR_END      (void*)(0x00400000 + 192 * 1024)
+#elif (CFG_SOC_NAME == SOC_BK7236) // TBD: mem size for bk7236
+#define LOSCFG_SYS_HEAP_ADDR_END      (void*)(0x00400000 + 192 * 1024)
+#elif (CFG_SOC_NAME == SOC_BK7271)
+#define LOSCFG_SYS_HEAP_ADDR_END      (void*)(0x00400000 + 512 * 1024)
+#else
+#define LOSCFG_SYS_HEAP_ADDR_END      (void*)(0x00400000 + 256 * 1024)
+#endif // CFG_SOC_NAME
+
+#endif // LOS_BEKEN
+
 /**
  * @ingroup los_config
  * System clock (unit: HZ)
@@ -103,6 +123,22 @@ extern "C" {
 #define LOSCFG_BASE_CORE_TICK_HW_TIME                       0
 #endif
 
+/**
+ * @ingroup los_config
+ * System timer is a 64/128 bit timer
+ */
+#ifndef LOSCFG_BASE_CORE_TICK_WTIMER
+#define LOSCFG_BASE_CORE_TICK_WTIMER                        0
+#endif
+
+/**
+ * @ingroup los_config
+ * System timer count maximum
+ */
+#ifndef LOSCFG_BASE_CORE_TICK_RESPONSE_MAX
+#define LOSCFG_BASE_CORE_TICK_RESPONSE_MAX                       0
+#endif
+
 /* =============================================================================
                                         Hardware interrupt module configuration
 ============================================================================= */
@@ -166,7 +202,7 @@ extern "C" {
  * Maximum supported number of tasks except the idle task rather than the number of usable tasks
  */
 #ifndef LOSCFG_BASE_CORE_TSK_LIMIT
-#define LOSCFG_BASE_CORE_TSK_LIMIT                          5
+#define LOSCFG_BASE_CORE_TSK_LIMIT                          16
 #endif
 
 /**
@@ -190,7 +226,7 @@ extern "C" {
  * Configuration item for task Robin tailoring
  */
 #ifndef LOSCFG_BASE_CORE_TIMESLICE
-#define LOSCFG_BASE_CORE_TIMESLICE                          1
+#define LOSCFG_BASE_CORE_TIMESLICE                         1
 #endif
 
 /**
@@ -198,7 +234,7 @@ extern "C" {
  * Longest execution time of tasks with the same priorities
  */
 #ifndef LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT
-#define LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT                  10
+#define LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT                  20000 /* 20ms */
 #endif
 
 /**
@@ -268,6 +304,14 @@ extern "C" {
 #define LOSCFG_BASE_IPC_SEM_LIMIT                           6
 #endif
 
+/**
+ * @ingroup los_config
+ * Maximum number of semaphores.
+ */
+#ifndef OS_SEM_COUNTING_MAX_COUNT
+#define OS_SEM_COUNTING_MAX_COUNT                           0xFFFF
+#endif
+
 /* =============================================================================
                                        Mutex module configuration
 ============================================================================= */
@@ -303,7 +347,7 @@ extern "C" {
  * Maximum supported number of queues rather than the number of usable queues
  */
 #ifndef LOSCFG_BASE_IPC_QUEUE_LIMIT
-#define LOSCFG_BASE_IPC_QUEUE_LIMIT                         6
+#define LOSCFG_BASE_IPC_QUEUE_LIMIT                         32
 #endif
 
 
@@ -559,6 +603,14 @@ extern UINT8 *m_aucSysMem0;
 #define LOSCFG_KERNEL_TRACE                                 0
 #endif
 
+/**
+ * @ingroup los_config
+ * Configuration trace tool
+ */
+#ifndef LOSCFG_DEBUG_HOOK
+#define LOSCFG_DEBUG_HOOK                                   0
+#endif
+
 /* =============================================================================
                                        printf configuration
 ============================================================================= */
@@ -579,6 +631,7 @@ extern UINT8 *m_aucSysMem0;
  * 0: Close stack analysis module.
  * 1: Call stack analysis for cortex-m series.
  * 2: Call stack analysis for risc-v.
+ * 3: Call stack analysis for arm9
  * others: Not currently supported.
  */
 #ifndef LOSCFG_BACKTRACE_TYPE
@@ -593,6 +646,39 @@ extern UINT8 *m_aucSysMem0;
 #define LOSCFG_BACKTRACE_DEPTH                               15
 #endif
 
+/**
+ * @ingroup los_config
+ * When the tick timer is a non-64/128-bit timer, it has ultra-low power compensation.
+ */
+#ifndef LOSCFG_BASE_CORE_SCHED_SLEEP
+#define LOSCFG_BASE_CORE_SCHED_SLEEP                         0
+#endif
+
+/**
+ * @ingroup los_config
+ * Configuration trustzone secure heap size.
+ */
+#ifndef LOSCFG_SECURE_HEAP_SIZE
+#define LOSCFG_SECURE_HEAP_SIZE                              2048
+#endif
+
+/**
+ * @ingroup los_config
+ * Configuration trustzone secure stack default size.
+ * The secure stack must be allocated before the task calls non-secure callble functions.
+ */
+#ifndef LOSCFG_SECURE_STACK_DEFAULT_SIZE
+#define LOSCFG_SECURE_STACK_DEFAULT_SIZE                     512
+#endif
+
+/**
+ * @ingroup los_config
+ * Suppport arm and thumb instruction.
+ */
+#ifndef LOSCFG_INTERWORK_THUMB
+#define LOSCFG_INTERWORK_THUMB                               0
+#endif
+
 #ifdef __cplusplus
 #if __cplusplus
 }
diff --git a/kernel/liteos_m/kernel/include/los_event.h b/kernel/liteos_m/kernel/include/los_event.h
index 933215a..4df94aa 100644
--- a/kernel/liteos_m/kernel/include/los_event.h
+++ b/kernel/liteos_m/kernel/include/los_event.h
@@ -147,13 +147,13 @@ extern "C" {
 
 /**
  * @ingroup los_event
- * Event reading error code: should not be distory.
+ * Event reading error code: should not be destroyed.
  *
  * Value: 0x02001c08
  *
  * Solution: Check whether the event list is not empty.
  */
-#define LOS_ERRNO_EVENT_SHOULD_NOT_DESTORY LOS_ERRNO_OS_ERROR(LOS_MOD_EVENT, 0x08)
+#define LOS_ERRNO_EVENT_SHOULD_NOT_DESTROYED LOS_ERRNO_OS_ERROR(LOS_MOD_EVENT, 0x08)
 
 /**
  * @ingroup los_event
@@ -274,7 +274,7 @@ extern UINT32 LOS_EventWrite(PEVENT_CB_S eventCB, UINT32 events);
 
 /**
  * @ingroup los_event
- * @brief Clear the event occurring in a specified task.
+ * @brief Clear the event of the eventCB by a specified eventMask.
  *
  * @par Description:
  * <ul>
@@ -287,7 +287,7 @@ extern UINT32 LOS_EventWrite(PEVENT_CB_S eventCB, UINT32 events);
  * </ul>
  *
  * @param eventCB     [IN/OUT] Pointer to the event control block to be cleared.
- * @param events      [IN]     Mask of the event to be cleared.
+ * @param eventMask   [IN]     Mask of the event to be cleared.
  *
  * @retval #LOS_ERRNO_EVENT_PTR_NULL  Null pointer.
  * @retval #LOS_OK                    The event is successfully cleared.
@@ -295,15 +295,15 @@ extern UINT32 LOS_EventWrite(PEVENT_CB_S eventCB, UINT32 events);
  * <ul><li>los_event.h: the header file that contains the API declaration.</li></ul>
  * @see LOS_EventPoll | LOS_EventRead | LOS_EventWrite
  */
-extern UINT32 LOS_EventClear(PEVENT_CB_S eventCB, UINT32 events);
+extern UINT32 LOS_EventClear(PEVENT_CB_S eventCB, UINT32 eventMask);
 
 /**
  * @ingroup los_event
- * @brief Destroy a event.
+ * @brief Destroy an event.
  *
  * @par Description:
  * <ul>
- * <li>This API is used to Destroy a event.</li>
+ * <li>This API is used to Destroy an event.</li>
  * </ul>
  * @attention
  * <ul>
diff --git a/kernel/liteos_m/kernel/include/los_membox.h b/kernel/liteos_m/kernel/include/los_membox.h
old mode 100755
new mode 100644
index cc65225..9093aca
--- a/kernel/liteos_m/kernel/include/los_membox.h
+++ b/kernel/liteos_m/kernel/include/los_membox.h
@@ -82,14 +82,14 @@ UINT32 OsMemboxExcInfoGet(UINT32 memNumMax, MemInfoCB *memExcInfo);
  * @ingroup los_membox
  * Memory pool alignment
  */
-#define LOS_MEMBOX_ALLIGNED(memAddr) (((UINTPTR)(memAddr) + sizeof(UINTPTR) - 1) & (~(sizeof(UINTPTR) - 1)))
+#define LOS_MEMBOX_ALIGNED(memAddr) (((UINTPTR)(memAddr) + sizeof(UINTPTR) - 1) & (~(sizeof(UINTPTR) - 1)))
 
 /**
  * @ingroup los_membox
  * Memory pool size
  */
 #define LOS_MEMBOX_SIZE(blkSize, blkNum) \
-    (sizeof(LOS_MEMBOX_INFO) + (LOS_MEMBOX_ALLIGNED((blkSize) + OS_MEMBOX_NODE_HEAD_SIZE) * (blkNum)))
+    (sizeof(LOS_MEMBOX_INFO) + (LOS_MEMBOX_ALIGNED((blkSize) + OS_MEMBOX_NODE_HEAD_SIZE) * (blkNum)))
 
 /**
  * @ingroup los_membox
diff --git a/kernel/liteos_m/kernel/include/los_memory.h b/kernel/liteos_m/kernel/include/los_memory.h
old mode 100755
new mode 100644
diff --git a/kernel/liteos_m/kernel/include/los_mux.h b/kernel/liteos_m/kernel/include/los_mux.h
index 8e5a129..334c876 100644
--- a/kernel/liteos_m/kernel/include/los_mux.h
+++ b/kernel/liteos_m/kernel/include/los_mux.h
@@ -330,7 +330,7 @@ extern LosMuxCB *g_allMux;
  *
  * @retval UINT32     Initialization result.
  * @par Dependency:
- * <ul><li>los_mux_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_mux.h: the header file that contains the API declaration.</li></ul>
  * @see LOS_MuxDelete
  */
 extern UINT32 OsMuxInit(VOID);
diff --git a/kernel/liteos_m/kernel/include/los_queue.h b/kernel/liteos_m/kernel/include/los_queue.h
index 68c1cc5..a034086 100644
--- a/kernel/liteos_m/kernel/include/los_queue.h
+++ b/kernel/liteos_m/kernel/include/los_queue.h
@@ -355,7 +355,7 @@ typedef struct tagQueueInfo {
  * This API is used to create a message queue.
  * @attention
  * <ul>
- * <li>Threre are LOSCFG_BASE_IPC_QUEUE_LIMIT queues available, change it's value when necessory.</li>
+ * <li>There are LOSCFG_BASE_IPC_QUEUE_LIMIT queues available, change it's value when necessary.</li>
  * </ul>
  * @param queueName        [IN]    Message queue name. Reserved parameter, not used for now.
  * @param len              [IN]    Queue length. The value range is [1,0xffff].
@@ -827,7 +827,7 @@ extern LosQueueCB *g_allQueue;
  * @retval   #NULL                    The memory allocation is failed.
  * @retval   #mem                     The address of alloc memory.
  * @par Dependency:
- * <ul><li>los_queue_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_queue.h: the header file that contains the API declaration.</li></ul>
  * @see OsQueueMailFree
  */
 extern VOID *OsQueueMailAlloc(UINT32 queueID, VOID *mailPool, UINT32 timeOut);
@@ -853,7 +853,7 @@ extern VOID *OsQueueMailAlloc(UINT32 queueID, VOID *mailPool, UINT32 timeOut);
  * @retval   #OS_ERRNO_QUEUE_MAIL_PTR_INVALID        0x0200061a: The pointer to the memory to be freed is null.
  * @retval   #OS_ERRNO_QUEUE_MAIL_FREE_ERROR         0x0200061b: The memory for the queue fails to be freed.
  * @par Dependency:
- * <ul><li>los_queue_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_queue.h: the header file that contains the API declaration.</li></ul>
  * @see OsQueueMailAlloc
  */
 extern UINT32 OsQueueMailFree(UINT32 queueID, VOID *mailPool, VOID *mailMem);
@@ -873,7 +873,7 @@ extern UINT32 OsQueueMailFree(UINT32 queueID, VOID *mailPool, VOID *mailMem);
  *
  * @retval   UINT32  Initialization result.
  * @par Dependency:
- * <ul><li>los_queue_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_queue.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 OsQueueInit(VOID);
@@ -897,7 +897,7 @@ extern UINT32 OsQueueInit(VOID);
  *
  * @retval   UINT32  Handle result.
  * @par Dependency:
- * <ul><li>los_queue_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_queue.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 OsQueueOperate(UINT32 queueID, UINT32 operateType, VOID *bufferAddr, UINT32 *bufferSize,
diff --git a/kernel/liteos_m/kernel/include/los_sched.h b/kernel/liteos_m/kernel/include/los_sched.h
new file mode 100644
index 0000000..b514edb
--- /dev/null
+++ b/kernel/liteos_m/kernel/include/los_sched.h
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_SCHED_H
+#define _LOS_SCHED_H
+
+#include "los_task.h"
+#include "los_interrupt.h"
+#include "los_timer.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+extern UINT32 g_taskScheduled;
+typedef BOOL (*SchedScan)(VOID);
+
+VOID OsSchedUpdateSchedTimeBase(VOID);
+
+UINT64 OsGetCurrSchedTimeCycle(VOID);
+
+VOID OsSchedSetIdleTaskSchedParam(LosTaskCB *idleTask);
+
+UINT32 OsSchedSwtmrScanRegister(SchedScan func);
+
+VOID OsSchedUpdateExpireTime(UINT64 startTime);
+
+VOID OsSchedTaskDeQueue(LosTaskCB *taskCB);
+
+VOID OsSchedTaskEnQueue(LosTaskCB *taskCB);
+
+VOID OsSchedTaskWait(LOS_DL_LIST *list, UINT32 timeout);
+
+VOID OsSchedTaskWake(LosTaskCB *resumedTask);
+
+BOOL OsSchedModifyTaskSchedParam(LosTaskCB *taskCB, UINT16 priority);
+
+VOID OsSchedDelay(LosTaskCB *runTask, UINT32 tick);
+
+VOID OsSchedYield(VOID);
+
+VOID OsSchedTaskExit(LosTaskCB *taskCB);
+
+VOID OsSchedTick(VOID);
+
+UINT32 OsSchedInit(VOID);
+
+VOID OsSchedStart(VOID);
+
+BOOL OsSchedTaskSwitch(VOID);
+
+LosTaskCB *OsGetTopTask(VOID);
+
+extern VOID LOS_SchedTickHandler(VOID);
+
+extern VOID LOS_Schedule(VOID);
+
+#if (LOSCFG_BASE_CORE_SCHED_SLEEP == 1)
+VOID OsSchedUpdateSleepTime(VOID);
+
+VOID OsSchedToSleep(VOID);
+
+typedef UINT32 (*SchedSleepInit)(VOID);
+
+typedef VOID (*SchedSleepStart)(UINT64);
+
+typedef VOID (*SchedSleepStop)(VOID);
+
+typedef UINT64 (*SchedSleepGetSleepTimeNs)(VOID);
+
+extern UINT32 LOS_SchedSleepInit(SchedSleepInit init, SchedSleepStart start,
+                                 SchedSleepStop stop, SchedSleepGetSleepTimeNs getTime);
+#endif
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _LOS_SCHED_H */
diff --git a/kernel/liteos_m/kernel/include/los_sem.h b/kernel/liteos_m/kernel/include/los_sem.h
index ebe148c..49fbb81 100644
--- a/kernel/liteos_m/kernel/include/los_sem.h
+++ b/kernel/liteos_m/kernel/include/los_sem.h
@@ -285,11 +285,6 @@ extern UINT32 LOS_SemPend(UINT32 semHandle, UINT32 timeout);
  */
 extern UINT32 LOS_SemPost(UINT32 semHandle);
 
-enum LosSemMaxCount {
-    OS_SEM_COUNTING_MAX_COUNT = 0xFFFF, /**< Max count of counting semaphores */
-    OS_SEM_BINARY_MAX_COUNT = 1         /**< Max count of binary semaphores */
-};
-
 /**
  * @ingroup los_sem
  * Semaphore control structure.
@@ -302,24 +297,30 @@ typedef struct {
     LOS_DL_LIST semList; /**< Queue of tasks that are waiting on a semaphore */
 } LosSemCB;
 
+/**
+ * @ingroup los_config
+ * Max count of binary semaphores.
+ */
+#define OS_SEM_BINARY_MAX_COUNT     1
+
 /**
  * @ingroup los_sem
  * The semaphore is not in use.
- *
  */
-#define OS_SEM_UNUSED 0
+#define OS_SEM_UNUSED               0
+
 /**
  * @ingroup los_sem
  * The semaphore is used.
- *
  */
-#define OS_SEM_USED   1
+#define OS_SEM_USED                 1
+
 /**
  * @ingroup los_sem
  * Obtain the head node in a semaphore doubly linked list.
- *
  */
 #define GET_SEM_LIST(ptr) LOS_DL_LIST_ENTRY(ptr, LosSemCB, semList)
+
 extern LosSemCB *g_allSem;
 /**
  * @ingroup los_sem
@@ -343,7 +344,7 @@ extern LosSemCB *g_allSem;
  *
  * @retval UINT32   Initialization result.
  * @par Dependency:
- * <ul><li>los_sem_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_sem.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 OsSemInit(VOID);
@@ -365,7 +366,7 @@ extern UINT32 OsSemInit(VOID);
  *
  * @retval UINT32   Create result.
  * @par Dependency:
- * <ul><li>los_sem_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_sem.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 UINT32 OsSemCreate(UINT16 count, UINT16 maxCount, UINT32 *semHandle);
diff --git a/kernel/liteos_m/kernel/include/los_sortlink.h b/kernel/liteos_m/kernel/include/los_sortlink.h
new file mode 100644
index 0000000..2e0c5a8
--- /dev/null
+++ b/kernel/liteos_m/kernel/include/los_sortlink.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_SORTLINK_H
+#define _LOS_SORTLINK_H
+
+#include "los_compiler.h"
+#include "los_list.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+typedef enum {
+    OS_SORT_LINK_TASK = 1,
+    OS_SORT_LINK_SWTMR = 2,
+} SortLinkType;
+
+typedef struct {
+    LOS_DL_LIST sortLinkNode;
+    UINT64      responseTime;
+} SortLinkList;
+
+typedef struct {
+    LOS_DL_LIST sortLink;
+} SortLinkAttribute;
+
+#define OS_SORT_LINK_INVALID_TIME ((UINT64)-1)
+#define SET_SORTLIST_VALUE(sortList, value) (((SortLinkList *)(sortList))->responseTime = (value))
+
+SortLinkAttribute *OsGetSortLinkAttribute(SortLinkType type);
+UINT64 OsGetNextExpireTime(UINT64 startTime);
+UINT32 OsSortLinkInit(SortLinkAttribute *sortLinkHeader);
+VOID OsDeleteNodeSortLink(SortLinkAttribute *sortLinkHeader, SortLinkList *sortList);
+VOID OsAdd2SortLink(SortLinkList *node, UINT64 startTime, UINT32 waitTicks, SortLinkType type);
+VOID OsDeleteSortLink(SortLinkList *node, SortLinkType type);
+UINT32 OsSortLinkGetTargetExpireTime(UINT64 currTime, const SortLinkList *targetSortList);
+UINT32 OsSortLinkGetNextExpireTime(const SortLinkAttribute *sortLinkHeader);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _LOS_SORTLINK_H */
diff --git a/kernel/liteos_m/kernel/include/los_swtmr.h b/kernel/liteos_m/kernel/include/los_swtmr.h
index 9842e48..8d74ddd 100644
--- a/kernel/liteos_m/kernel/include/los_swtmr.h
+++ b/kernel/liteos_m/kernel/include/los_swtmr.h
@@ -37,6 +37,7 @@
 #ifndef _LOS_SWTMR_H
 #define _LOS_SWTMR_H
 
+#include "los_sortlink.h"
 
 #ifdef __cplusplus
 #if __cplusplus
@@ -279,6 +280,7 @@ typedef struct tagSwTmrCtrl {
     UINT32              uwArg;          /* Parameter passed in when the callback function
                                            that handles software timer timeout is called         */
     SWTMR_PROC_FUNC     pfnHandler;     /* Callback function that handles software timer timeout */
+    SortLinkList        stSortList;
 } SWTMR_CTRL_S;
 
 
@@ -365,7 +367,7 @@ extern UINT32 LOS_SwtmrTimeGet(UINT32 swtmrID, UINT32 *tick);
  * @attention
  * <ul>
  * <li>Do not use the delay interface in the callback function that handles software timer timeout.</li>
- * <li>Threre are LOSCFG_BASE_CORE_SWTMR_LIMIT timers available, change it's value when necessory.</li>
+ * <li>There are LOSCFG_BASE_CORE_SWTMR_LIMIT timers available, change it's value when necessary.</li>
  * </ul>
  *
  * @param  interval     [IN] Timing duration of the software timer to be created (unit: ms).
@@ -451,29 +453,6 @@ extern SWTMR_CTRL_S *g_swtmrCBArray;
 
 #define OS_SWT_FROM_SID(swtmrId)    ((SWTMR_CTRL_S *)g_swtmrCBArray + ((swtmrId) % LOSCFG_BASE_CORE_SWTMR_LIMIT))
 
-/**
- * @ingroup los_swtmr
- * @brief Scan a software timer.
- *
- * @par Description:
- * <ul>
- * <li>This API is used to scan a software timer when a Tick interrupt occurs and determine whether the software timer
-   expires.</li>
- * </ul>
- * @attention
- * <ul>
- * <li>None.</li>
- * </ul>
- *
- * @param  None.
- *
- * @retval None.
- * @par Dependency:
- * <ul><li>los_swtmr_pri.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_SwtmrStop
- */
-extern UINT32 OsSwtmrScan(VOID);
-
 /**
  * @ingroup los_swtmr
  * @brief Initialization software timer.
@@ -491,7 +470,7 @@ extern UINT32 OsSwtmrScan(VOID);
  *
  * @retval None.
  * @par Dependency:
- * <ul><li>los_swtmr_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_swtmr.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 OsSwtmrInit(VOID);
@@ -513,7 +492,7 @@ extern UINT32 OsSwtmrInit(VOID);
  *
  * @retval None.
  * @par Dependency:
- * <ul><li>los_swtmr_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_swtmr.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 OsSwtmrGetNextTimeout(VOID);
@@ -535,7 +514,7 @@ extern UINT32 OsSwtmrGetNextTimeout(VOID);
  *
  * @retval UINT32    Sleep time.
  * @par Dependency:
- * <ul><li>los_swtmr_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_swtmr.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern VOID OsSwtmrAdjust(UINT32 sleepTime);
diff --git a/kernel/liteos_m/kernel/include/los_task.h b/kernel/liteos_m/kernel/include/los_task.h
index 5ef1a69..de5072a 100644
--- a/kernel/liteos_m/kernel/include/los_task.h
+++ b/kernel/liteos_m/kernel/include/los_task.h
@@ -37,9 +37,11 @@
 #ifndef _LOS_TASK_H
 #define _LOS_TASK_H
 
-#include "los_tick.h"
+#include "los_config.h"
 #include "los_context.h"
 #include "los_event.h"
+#include "los_tick.h"
+#include "los_sortlink.h"
 
 #ifdef __cplusplus
 #if __cplusplus
@@ -367,6 +369,8 @@ extern "C" {
  */
 #define LOS_ERRNO_TSK_OPERATE_SWTMR                 LOS_ERRNO_OS_ERROR(LOS_MOD_TSK, 0x22)
 
+#define LOS_ERRNO_TSK_TIMEOUT                       LOS_ERRNO_OS_ERROR(LOS_MOD_TSK, 0x23)
+
 /**
  * @ingroup los_task
  * Define the type of the task switching hook function.
@@ -435,24 +439,20 @@ typedef struct tagTskInfo {
     BOOL                bOvf;                       /**< Flag that indicates whether a task stack overflow occurs */
 } TSK_INFO_S;
 
-
-
 /**
- * @ingroup los_base
+ * @ingroup los_task
  * Define the timeout interval as LOS_NO_WAIT.
  */
 #define LOS_NO_WAIT                      0
 
 /**
- * @ingroup los_base
+ * @ingroup los_task
  * Define the timeout interval as LOS_WAIT_FOREVER.
  */
 #define LOS_WAIT_FOREVER                 0xFFFFFFFF
 
-
-
 /**
- * @ingroup los_base
+ * @ingroup los_task
  * @brief Sleep the current task.
  *
  * @par Description:
@@ -474,13 +474,13 @@ typedef struct tagTskInfo {
  *
  * @retval None
  * @par Dependency:
- * <ul><li>los_base.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see None
  */
 extern VOID LOS_Msleep(UINT32 mSecs);
 
 /**
- * @ingroup los_base
+ * @ingroup los_task
  * @brief System kernel initialization function.
  *
  * @par Description:
@@ -500,12 +500,11 @@ extern VOID LOS_Msleep(UINT32 mSecs);
  * @see
  */
 extern UINT32 LOS_Start(VOID);
-extern VOID LOS_Reboot(VOID);
-extern VOID LOS_Panic(const CHAR *fmt, ...);
-
+extern NORETURN VOID LOS_Reboot(VOID);
+extern NORETURN VOID LOS_Panic(const CHAR *fmt, ...);
 
 /**
- * @ingroup los_base
+ * @ingroup los_task
  * @brief System kernel initialization function.
  *
  * @par Description:
@@ -1053,7 +1052,7 @@ extern BOOL LOS_TaskIsRunning(VOID);
  * @brief Obtain current new task ID.
  *
  * @par Description:
- * This API is used to obtain the ID of new  task.
+ * This API is used to obtain the ID of new task.
  *
  * @attention None.
  *
@@ -1067,10 +1066,10 @@ extern BOOL LOS_TaskIsRunning(VOID);
 extern  UINT32 LOS_NewTaskIDGet(VOID);
  /**
   * @ingroup  los_task
-  * @brief Obtain current new task name.
+  * @brief Obtain the task name.
   *
   * @par Description:
-  * This API is used to obtain the name of new  task.
+  * This API is used to obtain the task name.
   *
   * @attention None.
   *
@@ -1084,279 +1083,24 @@ extern  UINT32 LOS_NewTaskIDGet(VOID);
   */
 extern CHAR* LOS_TaskNameGet(UINT32 taskID);
 
-
 /* *
- * @ingroup  los_hw
- * @brief: Function to determine whether task scheduling is required.
+ * @ingroup  los_task
+ * @brief: cpu delay.
  *
  * @par Description:
- * This API is used to Judge and entry task scheduling.
+ * This API is used to cpu delay, no task switching.
  *
  * @attention:
  * <ul><li>None.</li></ul>
  *
- * @param  None.
+ * @param  UINT64  [IN] delay times, microseconds.
  *
  * @retval: None.
  * @par Dependency:
- * <ul><li>los_hw.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
-extern VOID LOS_Schedule(VOID);
-
-extern UINT32 OsTaskNextSwitchTimeGet(VOID);
-
-
-
-/**
-* @ingroup los_cpup
-* CPU usage error code: The request for memory fails.
-*
-* Value: 0x02001e00
-*
-* Solution: Decrease the maximum number of tasks.
-*/
-#define LOS_ERRNO_CPUP_NO_MEMORY             LOS_ERRNO_OS_ERROR(LOS_MOD_CPUP, 0x00)
-
-/**
-* @ingroup los_cpup
-* CPU usage error code: The pointer to an input parameter is NULL.
-*
-* Value: 0x02001e01
-*
-* Solution: Check whether the pointer to the input parameter is usable.
-*/
-#define LOS_ERRNO_CPUP_TASK_PTR_NULL         LOS_ERRNO_OS_ERROR(LOS_MOD_CPUP, 0x01)
-
-/**
-* @ingroup los_cpup
-* CPU usage error code: The CPU usage is not initialized.
-*
-* Value: 0x02001e02
-*
-* Solution: Check whether the CPU usage is initialized.
-*/
-#define LOS_ERRNO_CPUP_NO_INIT               LOS_ERRNO_OS_ERROR(LOS_MOD_CPUP, 0x02)
-
-/**
-* @ingroup los_cpup
-* CPU usage error code: The number of threads is invalid.
-*
-* Value: 0x02001e03
-*
-* Solution: Check whether the number of threads is applicable for the current operation.
-*/
-#define LOS_ERRNO_CPUP_MAXNUM_INVALID        LOS_ERRNO_OS_ERROR(LOS_MOD_CPUP, 0x03)
-
-/**
-* @ingroup los_cpup
-* CPU usage error code: The target thread is not created.
-*
-* Value: 0x02001e04
-*
-* Solution: Check whether the target thread is created.
-*/
-#define LOS_ERRNO_CPUP_THREAD_NO_CREATED     LOS_ERRNO_OS_ERROR(LOS_MOD_CPUP, 0x04)
-
-/**
-* @ingroup los_cpup
-* CPU usage error code: The target task ID is invalid.
-*
-* Value: 0x02001e05
-*
-* Solution: Check whether the target task ID is applicable for the current operation.
-*/
-#define LOS_ERRNO_CPUP_TSK_ID_INVALID        LOS_ERRNO_OS_ERROR(LOS_MOD_CPUP, 0x05)
-
-/**
-* @ingroup los_cpup
-* Sum of cpup with all tasks. It means the value of cpup is a permillage.
-*/
-#define LOS_CPUP_PRECISION                   1000
-
-/**
-* @ingroup los_cpup
-* Multiple of current cpup precision change to percent.
-*/
-#define LOS_CPUP_PRECISION_MULT              (LOS_CPUP_PRECISION / 100)
-
-/**
- * @ingroup los_cpup
- * Count the CPU usage structures of all tasks.
- */
-typedef struct tagCpupInfo {
-    UINT16 usStatus;            /**< save the cur task status     */
-    UINT32 uwUsage;             /**< Usage. The value range is [0,1000].   */
-} CPUP_INFO_S;
-
-/**
- * @ingroup los_monitor
- * Type of the CPU usage query.
- */
-typedef enum {
-    SYS_CPU_USAGE = 0,   /* system cpu occupancy rate */
-    TASK_CPU_USAGE,      /* task cpu occupancy rate */
-} CPUP_TYPE_E;
-
-/**
- * @ingroup los_monitor
- * Mode of the CPU usage query.
- */
-typedef enum {
-    CPUP_IN_10S = 0,     /* cpu occupancy rate in 10s */
-    CPUP_IN_1S,          /* cpu occupancy rate in 1s */
-    CPUP_LESS_THAN_1S,   /* cpu occupancy rate less than 1s, if the input mode is none of them, it will be this. */
-} CPUP_MODE_E;
-
-/**
- * @ingroup los_cpup
- * @brief Obtain the current CPU usage.
- *
- * @par Description:
- * This API is used to obtain the current CPU usage.
- * @attention
- * <ul>
- * <li>This API can be called only after the CPU usage is initialized. Otherwise, error codes will be returned.</li>
- * <li> The precision of the CPU usage can be adjusted by changing the value of the CPUP_PRECISION macro.</li>
- * </ul>
- *
- * @param None.
- *
- * @retval #OS_ERRNO_CPUP_NO_INIT           0x02001e02: The CPU usage is not initialized.
- * @retval #cpup                            [0,100], current CPU usage, of which the precision is adjustable.
- * @par Dependency:
- * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_SysCpuUsage
- */
-extern UINT32 LOS_SysCpuUsage(VOID);
-
-/**
- * @ingroup los_cpup
- * @brief Obtain the historical CPU usage.
- *
- * @par Description:
- * This API is used to obtain the historical CPU usage.
- * @attention
- * <ul>
- * <li>This API can be called only after the CPU usage is initialized. Otherwise, the CPU usage fails to be obtained.</li>
- * </ul>
- *
- * @param  mode     [IN] UINT16. Task mode. The parameter value 0 indicates that the CPU usage within 10s will be
- * obtained, and the parameter value 1 indicates that the CPU usage in the former 1s will be obtained. Other values
- * indicate that the CPU usage in the period that is less than 1s will be obtained.
- *
- * @retval #OS_ERRNO_CPUP_NO_INIT           0x02001e02: The CPU usage is not initialized.
- * @retval #cpup                            [0,100], historical CPU usage, of which the precision is adjustable.
- * @par Dependency:
- * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_HistoryTaskCpuUsage
- */
-extern UINT32 LOS_HistorySysCpuUsage(UINT16 mode);
-
-/**
- * @ingroup los_cpup
- * @brief Obtain the CPU usage of a specified task.
- *
- * @par Description:
- * This API is used to obtain the CPU usage of a task specified by a passed-in task ID.
- * @attention
- * <ul>
- * <li>This API can be called only after the CPU usage is initialized. Otherwise, the CPU usage fails to be obtained.</li>
- * <li>The passed-in task ID must be valid and the task specified by the task ID must be created. Otherwise,
- * the CPU usage fails to be obtained.</li>
- * </ul>
- *
- * @param taskID   [IN] UINT32. Task ID.
- *
- * @retval #OS_ERRNO_CPUP_NO_INIT             0x02001e02: The CPU usage is not initialized.
- * @retval #OS_ERRNO_CPUP_TSK_ID_INVALID      0x02001e05: The target task ID is invalid.
- * @retval #OS_ERRNO_CPUP_THREAD_NO_CREATED   0x02001e04: The target thread is not created.
- * @retval #cpup                              [0,100], CPU usage of the specified task.
- * @par Dependency:
- * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_HistoryTaskCpuUsage
- */
-extern UINT32 LOS_TaskCpuUsage(UINT32 taskID);
-
-/**
- * @ingroup los_cpup
- * @brief  Obtain the historical CPU usage of a specified task.
- *
- * @par Description:
- * This API is used to obtain the historical CPU usage of a task specified by a passed-in task ID.
- * @attention
- * <ul>
- * <li>This API can be called only after the CPU usage is initialized. Otherwise,
- * the CPU usage fails to be obtained.</li>
- * <li>The passed-in task ID must be valid and the task specified by the task ID must be created. Otherwise,
- * the CPU usage fails to be obtained.</li>
- * </ul>
- *
- * @param taskID   [IN] UINT32. Task ID.
- * @param mode     [IN] UINT16. Task mode. The parameter value 0 indicates that the CPU usage within 10s
- * will be obtained, and the parameter value 1 indicates that the CPU usage in the former 1s will be obtained.
- * Other values indicate that the CPU usage in the period that is less than 1s will be obtained.
- *
- * @retval #OS_ERRNO_CPUP_NO_INIT             0x02001e02: The CPU usage is not initialized.
- * @retval #OS_ERRNO_CPUP_TSK_ID_INVALID      0x02001e05: The target task ID is invalid.
- * @retval #OS_ERRNO_CPUP_THREAD_NO_CREATED   0x02001e04: The target thread is not created.
- * @retval #cpup                              [0,100], CPU usage of the specified task.
- * @par Dependency:
- * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_HistorySysCpuUsage
- */
-extern UINT32 LOS_HistoryTaskCpuUsage(UINT32 taskID, UINT16 mode);
-
-/**
- * @ingroup los_cpup
- * @brief Obtain the CPU usage of all tasks.
- *
- * @par Description:
- * This API is used to obtain the CPU usage of all tasks according to maximum number of threads.
- * @attention
- * <ul>
- * <li>This API can be called only after the CPU usage is initialized. Otherwise, the CPU usage fails to be obtained.</li>
- * <li>The input parameter pointer must not be NULL, Otherwise, the CPU usage fails to be obtained.</li>
- * </ul>
- *
- * @param cpupInfo    [OUT]Type.   CPUP_INFO_S* Pointer to the task CPUP information structure to be obtained.
- * @param mode        [IN] UINT16. Task mode. The parameter value 0 indicates that the CPU usage within 10s
- * will be obtained, and the parameter value 1 indicates that the CPU usage in the former 1s will be obtained.
- * Other values indicate that the CPU usage in the period that is less than 1s will be obtained.
- *
- * @retval #OS_ERRNO_CPUP_NO_INIT           0x02001e02: The CPU usage is not initialized.
- * @retval #OS_ERRNO_CPUP_TASK_PTR_NULL     0x02001e01: The input parameter pointer is NULL.
- * @retval #LOS_OK                          0x00000000: The CPU usage of all tasks is successfully obtained.
- * @par Dependency:
- * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_SysCpuUsage
- */
-extern UINT32 LOS_AllTaskCpuUsage(CPUP_INFO_S *cpupInfo, UINT16 mode);
-
-/**
- * @ingroup los_monitor
- * @brief Obtain CPU usage history of certain task.
- *
- * @par Description:
- * This API is used to obtain CPU usage history of certain task.
- * @attention
- * <ul>
- * <li>This API can be called only after the CPU usage is initialized. Otherwise, -1 will be returned.</li>
- * <li> Only in SYS_CPU_USAGE type, uwTaskID is invalid.</li>
- * </ul>
- *
- * @param type        [IN] cpup type, SYS_CPU_USAGE and TASK_CPU_USAGE
- * @param mode        [IN] mode,CPUP_IN_10S = usage in 10s,CPUP_IN_1S = usage in last 1s,
- * CPUP_LESS_THAN_1S = less than 1s, if the inpuit mode is none of them, it will be as CPUP_LESS_THAN_1S.
- * @param taskID      [IN] task ID, Only in SYS_CPU_USAGE type, taskID is invalid
- *
- * @retval #OS_ERROR           -1:CPU usage info obtain failed.
- * @retval #LOS_OK              0:CPU usage info is successfully obtained.
- * @par Dependency:
- * <ul><li>los_monitor.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_CpupUsageMonitor
- */
-extern UINT32 LOS_CpupUsageMonitor(CPUP_TYPE_E type, CPUP_MODE_E mode, UINT32 taskID);
+extern VOID LOS_UDelay(UINT64 microseconds);
 
 /**
  * @ingroup los_task
@@ -1441,33 +1185,9 @@ extern UINT32 LOS_CpupUsageMonitor(CPUP_TYPE_E type, CPUP_MODE_E mode, UINT32 ta
  * @ingroup los_task
  * Flag that indicates the task or task control block status.
  *
- * The task is waiting for an event to occur.
+ * The task is blocked on a time.
  */
-#define OS_TASK_STATUS_EVENT                        0x0400
-
-/**
- * @ingroup los_task
- * Flag that indicates the task or task control block status.
- *
- * The task is reading an event.
- */
-#define OS_TASK_STATUS_EVENT_READ                   0x0800
-
-/**
- * @ingroup los_task
- * Flag that indicates the task or task control block status.
- *
- * A software timer is waiting for an event to occur.
- */
-#define OS_TASK_STATUS_SWTMR_WAIT                   0x1000
-
-/**
- * @ingroup los_task
- * Flag that indicates the task or task control block status.
- *
- * The task is blocked on a queue.
- */
-#define OS_TASK_STATUS_PEND_QUEUE                   0x2000
+#define OS_TASK_STATUS_PEND_TIME                    0x0080
 
 /**
  * @ingroup los_task
@@ -1551,13 +1271,13 @@ extern UINT32 LOS_CpupUsageMonitor(CPUP_TYPE_E type, CPUP_MODE_E mode, UINT32 ta
  * @ingroup los_task
  * @brief the high-order mask of roll num.
  */
-#define OS_TSK_HIGH_BITS_MASK  (OS_TSK_SORTLINK_MASK << OS_TSK_LOW_BITS)
+#define OS_TSK_HIGH_BITS_MASK                       (OS_TSK_SORTLINK_MASK << OS_TSK_LOW_BITS)
 
 /**
  * @ingroup los_task
  * @brief the low-order mask of roll num.
  */
-#define OS_TSK_LOW_BITS_MASK   (~OS_TSK_HIGH_BITS_MASK)
+#define OS_TSK_LOW_BITS_MASK                        (~OS_TSK_HIGH_BITS_MASK)
 
 /**
  * @ingroup los_task
@@ -1567,20 +1287,20 @@ extern UINT32 LOS_CpupUsageMonitor(CPUP_TYPE_E type, CPUP_MODE_E mode, UINT32 ta
 
 /**
  * @ingroup  los_task
- * @brief Check whether a task ID is valid.
+ * @brief Get the real task ID.
  *
  * @par Description:
- * This API is used to check whether a task ID, excluding the idle task ID, is valid.
+ * This API is used to get the real task ID.
  * @attention None.
  *
  * @param  taskID [IN] Task ID.
  *
- * @retval 0 or 1. One indicates that the task ID is invalid, whereas zero indicates that the task ID is valid.
+ * @retval  real task ID.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see
  */
-#define OS_TSK_GET_INDEX(taskID)                      (taskID)
+#define OS_TSK_GET_INDEX(taskID)                        (taskID)
 
 /**
  * @ingroup  los_task
@@ -1594,7 +1314,7 @@ extern UINT32 LOS_CpupUsageMonitor(CPUP_TYPE_E type, CPUP_MODE_E mode, UINT32 ta
  *
  * @retval Pointer to the task control block.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see
  */
 #define OS_TCB_FROM_PENDLIST(ptr)                       LOS_DL_LIST_ENTRY(ptr, LosTaskCB, pendList)
@@ -1611,11 +1331,11 @@ extern UINT32 LOS_CpupUsageMonitor(CPUP_TYPE_E type, CPUP_MODE_E mode, UINT32 ta
  *
  * @retval Pointer to the task control block.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see
  */
-#define OS_TCB_FROM_TID(taskID)                       (((LosTaskCB *)g_taskCBArray) + (taskID))
-#define OS_IDLE_TASK_ENTRY                            ((TSK_ENTRY_FUNC)OsIdleTask)
+#define OS_TCB_FROM_TID(taskID)                         (((LosTaskCB *)g_taskCBArray) + (taskID))
+#define OS_IDLE_TASK_ENTRY                              ((TSK_ENTRY_FUNC)OsIdleTask)
 
 
 /**
@@ -1626,6 +1346,10 @@ typedef struct {
     VOID                        *stackPointer;            /**< Task stack pointer */
     UINT16                      taskStatus;
     UINT16                      priority;
+    INT32                       timeSlice;
+    UINT32                      waitTimes;
+    SortLinkList                sortList;
+    UINT64                      startTime;
     UINT32                      stackSize;                /**< Task stack size */
     UINT32                      topOfStack;               /**< Task stack top */
     UINT32                      taskID;                   /**< Task ID */
@@ -1636,7 +1360,6 @@ typedef struct {
     CHAR                        *taskName;                /**< Task name */
     LOS_DL_LIST                 pendList;
     LOS_DL_LIST                 timerList;
-    UINT32                      idxRollNum;
     EVENT_CB_S                  event;
     UINT32                      eventMask;                /**< Event mask */
     UINT32                      eventMode;                /**< Event mode */
@@ -1699,8 +1422,7 @@ extern UINT16               g_losTaskLock;
  * @ingroup los_hw
  * Check task schedule.
  */
-#define LOS_CHECK_SCHEDULE ((!g_losTaskLock))
-
+#define LOS_CHECK_SCHEDULE (!g_losTaskLock)
 
 /**
  * @ingroup los_task
@@ -1744,50 +1466,6 @@ extern LOS_DL_LIST          g_losFreeTask;
  */
 extern LOS_DL_LIST          g_taskRecyleList;
 
-/**
- * @ingroup  los_task
- * @brief Modify the priority of task.
- *
- * @par Description:
- * This API is used to modify the priority of task.
- *
- * @attention
- * <ul>
- * <li>The taskCB should be a correct pointer to task control block structure.</li>
- * <li>the priority should be in [0, OS_TASK_PRIORITY_LOWEST].</li>
- * </ul>
- *
- * @param  taskCB    [IN] Type #LosTaskCB * pointer to task control block structure.
- * @param  priority  [IN] Type #UINT16 the priority of task.
- *
- * @retval  None.
- * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
- * @see
- */
-extern VOID OsTaskPriModify(LosTaskCB *taskCB, UINT16 priority);
-
-/**
- * @ingroup  los_task
- * @brief Scan a task.
- *
- * @par Description:
- * This API is used to scan a task.
- *
- * @attention
- * <ul>
- * <li>None.</li>
- * </ul>
- *
- * @param  None.
- *
- * @retval  None.
- * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
- * @see
- */
-extern VOID OsTaskScan(VOID);
-
 /**
  * @ingroup  los_task
  * @brief Initialization a task.
@@ -1804,7 +1482,7 @@ extern VOID OsTaskScan(VOID);
  *
  * @retval  UINT32    Initialization result.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see
  */
 extern UINT32 OsTaskInit(VOID);
@@ -1825,7 +1503,7 @@ extern UINT32 OsTaskInit(VOID);
  *
  * @retval  UINT32   Create result.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see
  */
 extern UINT32 OsIdleTaskCreate(VOID);
@@ -1846,7 +1524,7 @@ extern UINT32 OsIdleTaskCreate(VOID);
  *
  * @retval  None.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see
  */
 extern VOID OsTaskSwitchCheck(VOID);
@@ -1867,7 +1545,7 @@ extern VOID OsTaskSwitchCheck(VOID);
  *
  * @retval  None.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see
  */
 extern VOID OsTaskMonInit(VOID);
@@ -1888,57 +1566,11 @@ extern VOID OsTaskMonInit(VOID);
  *
  * @retval  None.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see
  */
 extern VOID OsTaskEntry(UINT32 taskID);
 
-/**
- * @ingroup  los_task
- * @brief pend running task to pendlist
- *
- * @par Description:
- * This API is used to pend task to  pendlist and add to sorted delay list.
- *
- * @attention
- * <ul>
- * <li>The pstList should be a vaild pointer to pendlist.</li>
- * </ul>
- *
- * @param  list       [IN] Type #LOS_DL_LIST * pointer to list which running task will be pended.
- * @param  taskStatus [IN] Type #UINT32  Task Status.
- * @param  timeOut    [IN] Type #UINT32  Expiry time. The value range is [0,LOS_WAIT_FOREVER].
- *
- * @retval  LOS_OK       wait success
- * @retval  LOS_NOK      pend out
- * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
- * @see OsTaskWake
- */
-extern VOID OsTaskWait(LOS_DL_LIST *list, UINT32 taskStatus, UINT32 timeOut);
-
-/**
- * @ingroup  los_task
- * @brief delete task from pendlist.
- *
- * @par Description:
- * This API is used to delete task from pendlist and also add to the priqueue.
- *
- * @attention
- * <ul>
- * <li>The pstList should be a vaild pointer to pend list.</li>
- * </ul>
- *
- * @param  resumedTask [IN] Type #LosTaskCB * pointer to the task which will be add to priqueue.
- * @param  taskStatus  [IN] Type #UINT32  Task Status.
- *
- * @retval  None.
- * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
- * @see OsTaskWait
- */
-extern VOID OsTaskWake(LosTaskCB *resumedTask, UINT32 taskStatus);
-
 /**
  * @ingroup  los_task
  * @brief Get the task water line.
@@ -1955,7 +1587,7 @@ extern VOID OsTaskWake(LosTaskCB *resumedTask, UINT32 taskStatus);
  *
  * @retval  UINT32  Task water line.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 OsGetTaskWaterLine(UINT32 taskID);
@@ -1976,54 +1608,11 @@ extern UINT32 OsGetTaskWaterLine(UINT32 taskID);
  *
  * @retval  UINT8 *  String.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT8 *OsConvertTskStatus(UINT16 taskStatus);
 
-/**
- * @ingroup  los_task
- * @brief Add task to sorted delay list.
- *
- * @par Description:
- * This API is used to add task to sorted delay list.
- *
- * @attention
- * <ul>
- * <li>The taskCB should be a correct pointer to task control block structure.</li>
- * </ul>
- *
- * @param  taskCB     [IN] Type #LosTaskCB * pointer to task control block structure.
- * @param  timeout    [IN] Type #UINT32 wait time, ticks.
- *
- * @retval  None.
- * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
- * @see OsTimerListDelete
- */
-extern VOID OsTaskAdd2TimerList(LosTaskCB *taskCB, UINT32 timeout);
-
-/**
- * @ingroup  los_task
- * @brief delete task from sorted delay list.
- *
- * @par Description:
- * This API is used to delete task from sorted delay list.
- *
- * @attention
- * <ul>
- * <li>The taskCB should be a correct pointer to task control block structure.</li>
- * </ul>
- *
- * @param  taskCB [IN] Type #LosTaskCB * pointer to task control block structure.
- *
- * @retval  None.
- * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
- * @see OsTaskAdd2TimerList
- */
-extern VOID OsTimerListDelete(LosTaskCB *taskCB);
-
 /**
  * @ingroup  los_task
  * @brief Get all task information.
@@ -2040,58 +1629,13 @@ extern VOID OsTimerListDelete(LosTaskCB *taskCB);
  *
  * @retval  UINT32  All task information.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 OsGetAllTskInfo(VOID);
 
 extern VOID *OsTskUserStackInit(VOID* stackPtr, VOID* userSP, UINT32 userStackSize);
 
-/**
- * @ingroup los_timeslice
- * @brief Initialize time slices.
- *
- * @par Description:
- * <ul>
- * <li>This API is used to initialize time slices that defines the cycle of time slices according to
-   LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT.</li>
- * </ul>
- * @attention
- * <ul>
- * <li>None.</li>
- * </ul>
- *
- * @param None.
- *
- * @retval None.
- * @par Dependency:
- * <ul><li>los_timeslice_pri.h: the header file that contains the API declaration.</li></ul>
- * @see None.
- */
-extern VOID OsTimesliceInit(VOID);
-
-/**
- * @ingroup los_timeslice
- * @brief Check time slices.
- *
- * @par Description:
- * <ul>
- * <li>This API is used to check time slices. If the number of Ticks equals to the time for task switch, tasks are switched. Otherwise, the Tick counting continues.</li>
- * </ul>
- * @attention
- * <ul>
- * <li>None.</li>
- * </ul>
- *
- * @param None.
- *
- * @retval None.
- * @par Dependency:
- * <ul><li>los_timeslice_pri.h: the header file that contains the API declaration.</li></ul>
- * @see None.
- */
-extern VOID OsTimesliceCheck(VOID);
-
 #ifdef __cplusplus
 #if __cplusplus
 }
diff --git a/kernel/liteos_m/kernel/include/los_tick.h b/kernel/liteos_m/kernel/include/los_tick.h
index ea8f51d..45cc665 100644
--- a/kernel/liteos_m/kernel/include/los_tick.h
+++ b/kernel/liteos_m/kernel/include/los_tick.h
@@ -30,7 +30,7 @@
  */
 
 /**
- * @defgroup los_tick Tick
+ * @defgroup los_tick
  * @ingroup kernel
  */
 
@@ -79,41 +79,46 @@ extern "C" {
 
 /**
  *  @ingroup  los_tick
- *  @brief: System clock get function.
+ *  @brief: System timer cycles get function.
  *
  *  @par Description:
- *  This API is used to get system clock.
+ *  This API is used to get system timer cycles.
  *
  * @attention:
  * <ul><li>None.</li></ul>
  *
  * @param: None.
  *
- * @retval: system clock.
+ * @retval: current system cycles.
  *
  * @par Dependency:
  * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  *
  * */
-extern UINT32 LOS_SysClockGet(VOID);
-
-
+extern UINT64 LOS_SysCycleGet(VOID);
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * Number of milliseconds in one second.
  */
 #define OS_SYS_MS_PER_SECOND   1000
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * Number of microseconds in one second.
  */
 #define OS_SYS_US_PER_SECOND   1000000
+#define OS_SYS_NS_PER_SECOND   1000000000
+#define OS_SYS_NS_PER_US       1000
+#define OS_CYCLE_PER_TICK      (OS_SYS_CLOCK / LOSCFG_BASE_CORE_TICK_PER_SECOND)
+#define OS_NS_PER_CYCLE        (OS_SYS_NS_PER_SECOND / OS_SYS_CLOCK)
+#define OS_MS_PER_TICK         (OS_SYS_MS_PER_SECOND / LOSCFG_BASE_CORE_TICK_PER_SECOND)
+#define OS_US_PER_TICK         (OS_SYS_US_PER_SECOND / LOSCFG_BASE_CORE_TICK_PER_SECOND)
+#define OS_NS_PER_TICK         (OS_SYS_NS_PER_SECOND / LOSCFG_BASE_CORE_TICK_PER_SECOND)
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * System time basic function error code: Null pointer.
  *
  * Value: 0x02000010
@@ -123,7 +128,7 @@ extern UINT32 LOS_SysClockGet(VOID);
 #define LOS_ERRNO_SYS_PTR_NULL                 LOS_ERRNO_OS_ERROR(LOS_MOD_SYS, 0x10)
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * System time basic function error code: Invalid system clock configuration.
  *
  * Value: 0x02000011
@@ -133,7 +138,7 @@ extern UINT32 LOS_SysClockGet(VOID);
 #define LOS_ERRNO_SYS_CLOCK_INVALID            LOS_ERRNO_OS_ERROR(LOS_MOD_SYS, 0x11)
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * System time basic function error code: This error code is not in use temporarily.
  *
  * Value: 0x02000012
@@ -143,7 +148,7 @@ extern UINT32 LOS_SysClockGet(VOID);
 #define LOS_ERRNO_SYS_MAXNUMOFCORES_IS_INVALID LOS_ERRNO_OS_ERROR(LOS_MOD_SYS, 0x12)
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * System time error code: This error code is not in use temporarily.
  *
  * Value: 0x02000013
@@ -153,7 +158,7 @@ extern UINT32 LOS_SysClockGet(VOID);
 #define LOS_ERRNO_SYS_PERIERRCOREID_IS_INVALID LOS_ERRNO_OS_ERROR(LOS_MOD_SYS, 0x13)
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * System time error code: This error code is not in use temporarily.
  *
  * Value: 0x02000014
@@ -163,10 +168,10 @@ extern UINT32 LOS_SysClockGet(VOID);
 #define LOS_ERRNO_SYS_HOOK_IS_FULL             LOS_ERRNO_OS_ERROR(LOS_MOD_SYS, 0x14)
 
 /**
- * @ingroup los_typedef
+ * @ingroup los_tick
  * system time structure.
  */
-typedef struct tagSysTime {
+typedef struct TagSysTime {
     UINT16  uwYear;    /**< value 1970 ~ 2038 or 1970 ~ 2100 */
     UINT8   ucMonth;   /**< value 1 - 12 */
     UINT8   ucDay;     /**< value 1 - 31 */
@@ -177,7 +182,7 @@ typedef struct tagSysTime {
 } SYS_TIME_S;
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * @brief Obtain the number of Ticks.
  *
  * @par Description:
@@ -191,13 +196,13 @@ typedef struct tagSysTime {
  *
  * @retval UINT64 The number of Ticks.
  * @par Dependency:
- * <ul><li>los_sys.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see None
  */
 extern UINT64 LOS_TickCountGet(VOID);
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * @brief Obtain the number of cycles in one second.
  *
  * @par Description:
@@ -211,13 +216,13 @@ extern UINT64 LOS_TickCountGet(VOID);
  *
  * @retval UINT32 Number of cycles obtained in one second.
  * @par Dependency:
- * <ul><li>los_sys.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see None
  */
 extern UINT32 LOS_CyclePerTickGet(VOID);
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * @brief Convert Ticks to milliseconds.
  *
  * @par Description:
@@ -232,13 +237,13 @@ extern UINT32 LOS_CyclePerTickGet(VOID);
  * @retval UINT32 Number of milliseconds obtained through the conversion. Ticks are successfully converted to
  * milliseconds.
  * @par  Dependency:
- * <ul><li>los_sys.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see LOS_MS2Tick
  */
 extern UINT32 LOS_Tick2MS(UINT32 ticks);
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * @brief Convert milliseconds to Ticks.
  *
  * @par Description:
@@ -253,17 +258,11 @@ extern UINT32 LOS_Tick2MS(UINT32 ticks);
  *
  * @retval UINT32 Number of Ticks obtained through the conversion.
  * @par Dependency:
- * <ul><li>los_sys.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see LOS_Tick2MS
  */
 extern UINT32 LOS_MS2Tick(UINT32 millisec);
 
-/**
- * @ingroup los_tick
- * Count of Ticks
- */
-extern UINT64 g_ullTickCount;
-
 /**
  * @ingroup los_tick
  * Ticks per second
@@ -287,6 +286,7 @@ extern UINT32    g_cyclesPerTick;
  * System Clock
  */
 extern UINT32    g_sysClock;
+
 /**
  * @ingroup  los_tick
  * @brief Handle the system tick timeout.
@@ -303,58 +303,58 @@ extern UINT32    g_sysClock;
  *
  * @retval None.
  * @par Dependency:
- * <ul><li>los_tick_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern VOID OsTickHandler(VOID);
 
 /**
- * @ingroup los_base
+ * @ingroup los_tick
  * Define the CPU Tick structure.
  */
-typedef struct tagCpuTick {
+typedef struct TagCpuTick {
     UINT32 cntHi; /* < Upper 32 bits of the tick value */
     UINT32 cntLo; /* < Lower 32 bits of the tick value */
 } CpuTick;
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * Number of operable bits of a 32-bit operand
  */
 #define OS_SYS_MV_32_BIT       32
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * Number of milliseconds in one second.
  */
 #define OS_SYS_MS_PER_SECOND   1000
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * Number of microseconds in one second.
  */
 #define OS_SYS_US_PER_SECOND   1000000
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * The maximum length of name.
  */
 #define OS_SYS_APPVER_NAME_MAX 64
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * The magic word.
  */
 #define OS_SYS_MAGIC_WORD      0xAAAAAAAA
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * The initialization value of stack space.
  */
 #define OS_SYS_EMPTY_STACK     0xCACACACA
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * @brief Convert cycles to milliseconds.
  *
  * @par Description:
@@ -371,13 +371,13 @@ typedef struct tagCpuTick {
  * @retval #LOS_ERRNO_SYS_PTR_NULL    0x02000011: Invalid parameter.
  * @retval #LOS_OK                   0:  Cycles are successfully converted to microseconds.
  * @par Dependency:
- * <ul><li>los_sys_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 OsCpuTick2MS(CpuTick *cpuTick, UINT32 *msHi, UINT32 *msLo);
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * @brief Convert cycles to microseconds.
  *
  * @par Description:
@@ -394,13 +394,13 @@ extern UINT32 OsCpuTick2MS(CpuTick *cpuTick, UINT32 *msHi, UINT32 *msLo);
  * @retval #LOS_ERRNO_SYS_PTR_NULL    0x02000011: Invalid parameter.
  * @retval #LOS_OK                   0: Cycles are successfully converted to microseconds.
  * @par Dependency:
- * <ul><li>los_sys_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 OsCpuTick2US(CpuTick *cpuTick, UINT32 *usHi, UINT32 *usLo);
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * @brief Convert cycles to milliseconds.
  *
  * @par Description:
@@ -414,7 +414,7 @@ extern UINT32 OsCpuTick2US(CpuTick *cpuTick, UINT32 *usHi, UINT32 *usLo);
  *
  * @retval Number of milliseconds obtained through the conversion.    Cycles are successfully converted to milliseconds.
  * @par Dependency:
- * <ul><li>los_sys_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 STATIC_INLINE UINT64 OsCycle2MS(UINT64 cycle)
@@ -423,7 +423,7 @@ STATIC_INLINE UINT64 OsCycle2MS(UINT64 cycle)
 }
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * @brief Convert cycles to microseconds.
  *
  * @par Description:
@@ -437,7 +437,7 @@ STATIC_INLINE UINT64 OsCycle2MS(UINT64 cycle)
  *
  * @retval Number of microseconds obtained through the conversion. Cycles are successfully converted to microseconds.
  * @par Dependency:
- * <ul><li>los_sys_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 STATIC_INLINE UINT64 OsCycle2US(UINT64 cycle)
diff --git a/kernel/liteos_m/kernel/src/los_event.c b/kernel/liteos_m/kernel/src/los_event.c
index f1ab2af..bae96b3 100644
--- a/kernel/liteos_m/kernel/src/los_event.c
+++ b/kernel/liteos_m/kernel/src/los_event.c
@@ -29,13 +29,12 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "los_task.h"
+#include "los_event.h"
+#include "los_hook.h"
 #include "los_interrupt.h"
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif
-#endif /* __cplusplus */
+#include "los_task.h"
+#include "los_sched.h"
+
 
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_EventInit(PEVENT_CB_S eventCB)
 {
@@ -44,13 +43,14 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_EventInit(PEVENT_CB_S eventCB)
     }
     eventCB->uwEventID = 0;
     LOS_ListInit(&eventCB->stEventList);
+    OsHookCall(LOS_HOOK_TYPE_EVENT_INIT);
     return LOS_OK;
 }
 
 LITE_OS_SEC_TEXT UINT32 LOS_EventPoll(UINT32 *eventID, UINT32 eventMask, UINT32 mode)
 {
     UINT32 ret = 0;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
 
     if (eventID == NULL) {
         return LOS_ERRNO_EVENT_PTR_NULL;
@@ -97,7 +97,7 @@ LITE_OS_SEC_TEXT STATIC_INLINE UINT32 OsEventReadParamCheck(PEVENT_CB_S eventCB,
 LITE_OS_SEC_TEXT UINT32 LOS_EventRead(PEVENT_CB_S eventCB, UINT32 eventMask, UINT32 mode, UINT32 timeOut)
 {
     UINT32 ret;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     LosTaskCB *runTsk = NULL;
 
     ret = OsEventReadParamCheck(eventCB, eventMask, mode);
@@ -110,6 +110,7 @@ LITE_OS_SEC_TEXT UINT32 LOS_EventRead(PEVENT_CB_S eventCB, UINT32 eventMask, UIN
     }
     intSave = LOS_IntLock();
     ret = LOS_EventPoll(&(eventCB->uwEventID), eventMask, mode);
+    OsHookCall(LOS_HOOK_TYPE_EVENT_READ, eventCB, eventMask, mode);
     if (ret == 0) {
         if (timeOut == 0) {
             LOS_IntRestore(intSave);
@@ -123,22 +124,21 @@ LITE_OS_SEC_TEXT UINT32 LOS_EventRead(PEVENT_CB_S eventCB, UINT32 eventMask, UIN
         runTsk = g_losTask.runTask;
         runTsk->eventMask = eventMask;
         runTsk->eventMode = mode;
-        OsTaskWait(&eventCB->stEventList, OS_TASK_STATUS_PEND, timeOut);
+        OsSchedTaskWait(&eventCB->stEventList, timeOut);
         LOS_IntRestore(intSave);
         LOS_Schedule();
 
+        intSave = LOS_IntLock();
         if (runTsk->taskStatus & OS_TASK_STATUS_TIMEOUT) {
-            intSave = LOS_IntLock();
-            runTsk->taskStatus &= (~OS_TASK_STATUS_TIMEOUT);
+            runTsk->taskStatus &= ~OS_TASK_STATUS_TIMEOUT;
             LOS_IntRestore(intSave);
             return LOS_ERRNO_EVENT_READ_TIMEOUT;
         }
-        intSave = LOS_IntLock();
+
         ret = LOS_EventPoll(&eventCB->uwEventID, eventMask, mode);
-        LOS_IntRestore(intSave);
-    } else {
-        LOS_IntRestore(intSave);
     }
+
+    LOS_IntRestore(intSave);
     return ret;
 }
 
@@ -146,7 +146,7 @@ LITE_OS_SEC_TEXT UINT32 LOS_EventWrite(PEVENT_CB_S eventCB, UINT32 events)
 {
     LosTaskCB *resumedTask = NULL;
     LosTaskCB *nextTask = (LosTaskCB *)NULL;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     UINT8 exitFlag = 0;
     if (eventCB == NULL) {
         return LOS_ERRNO_EVENT_PTR_NULL;
@@ -159,6 +159,7 @@ LITE_OS_SEC_TEXT UINT32 LOS_EventWrite(PEVENT_CB_S eventCB, UINT32 events)
     }
     intSave = LOS_IntLock();
     eventCB->uwEventID |= events;
+    OsHookCall(LOS_HOOK_TYPE_EVENT_WRITE, eventCB);
     if (!LOS_ListEmpty(&eventCB->stEventList)) {
         for (resumedTask = LOS_DL_LIST_ENTRY((&eventCB->stEventList)->pstNext, LosTaskCB, pendList);
              &resumedTask->pendList != (&eventCB->stEventList);) {
@@ -169,7 +170,7 @@ LITE_OS_SEC_TEXT UINT32 LOS_EventWrite(PEVENT_CB_S eventCB, UINT32 events)
                  ((resumedTask->eventMask & eventCB->uwEventID) == resumedTask->eventMask))) {
                 exitFlag = 1;
 
-                OsTaskWake(resumedTask, OS_TASK_STATUS_PEND);
+                OsSchedTaskWake(resumedTask);
             }
             resumedTask = nextTask;
         }
@@ -187,7 +188,7 @@ LITE_OS_SEC_TEXT UINT32 LOS_EventWrite(PEVENT_CB_S eventCB, UINT32 events)
 
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_EventDestroy(PEVENT_CB_S eventCB)
 {
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     if (eventCB == NULL) {
         return LOS_ERRNO_EVENT_PTR_NULL;
     }
@@ -195,28 +196,25 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_EventDestroy(PEVENT_CB_S eventCB)
 
     if (!LOS_ListEmpty(&eventCB->stEventList)) {
         LOS_IntRestore(intSave);
-        return LOS_ERRNO_EVENT_SHOULD_NOT_DESTORY;
+        return LOS_ERRNO_EVENT_SHOULD_NOT_DESTROYED;
     }
     eventCB->stEventList.pstNext = (LOS_DL_LIST *)NULL;
     eventCB->stEventList.pstPrev = (LOS_DL_LIST *)NULL;
     LOS_IntRestore(intSave);
+    OsHookCall(LOS_HOOK_TYPE_EVENT_DESTROY);
     return LOS_OK;
 }
-LITE_OS_SEC_TEXT_MINOR UINT32 LOS_EventClear(PEVENT_CB_S eventCB, UINT32 events)
+LITE_OS_SEC_TEXT_MINOR UINT32 LOS_EventClear(PEVENT_CB_S eventCB, UINT32 eventMask)
 {
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     if (eventCB == NULL) {
         return LOS_ERRNO_EVENT_PTR_NULL;
     }
     intSave = LOS_IntLock();
-    eventCB->uwEventID &= events;
+    eventCB->uwEventID &= eventMask;
     LOS_IntRestore(intSave);
+    OsHookCall(LOS_HOOK_TYPE_EVENT_CLEAR, eventCB);
     return LOS_OK;
 }
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif
-#endif /* __cplusplus */
 
diff --git a/kernel/liteos_m/kernel/src/los_init.c b/kernel/liteos_m/kernel/src/los_init.c
old mode 100755
new mode 100644
index 50a344c..e752dae
--- a/kernel/liteos_m/kernel/src/los_init.c
+++ b/kernel/liteos_m/kernel/src/los_init.c
@@ -28,15 +28,14 @@
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-#include "los_config.h"
+#include "stdarg.h"
 #include "los_arch.h"
-#include "los_queue.h"
+#include "los_config.h"
+#include "los_debug.h"
 #include "los_memory.h"
 #include "los_mux.h"
+#include "los_queue.h"
 #include "los_sem.h"
-#include "los_debug.h"
-#include "stdarg.h"
 
 #if (LOSCFG_PLATFORM_HWI == 1)
 #include "los_interrupt.h"
@@ -58,11 +57,6 @@
 #include "los_exc_info.h"
 #endif
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cpluscplus */
-#endif /* __cpluscplus */
 
 /*****************************************************************************
  Function    : LOS_Reboot
@@ -119,6 +113,10 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_KernelInit(VOID)
     PRINTK("entering kernel init...\n");
 
     OsRegister();
+
+#if (LOSCFG_BACKTRACE_TYPE != 0)
+	LOS_BackTraceInit();
+#endif
     ret = OsMemSystemInit();
     if (ret != LOS_OK) {
         PRINT_ERR("OsMemSystemInit error %d\n", ret);
@@ -175,10 +173,6 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_KernelInit(VOID)
     }
 #endif
 
-#if (LOSCFG_BASE_CORE_TIMESLICE == 1)
-    OsTimesliceInit();
-#endif
-
     ret = OsIdleTaskCreate();
     if (ret != LOS_OK) {
         return ret;
@@ -193,11 +187,11 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_KernelInit(VOID)
 #endif
 
 #ifdef LOSCFG_TEST
-    //ret = los_TestInit();
-    //if (ret != LOS_OK) {
-    //    PRINT_ERR("los_TestInit error\n");
-    //    return ret;
-    //}
+    ret = los_TestInit();
+    if (ret != LOS_OK) {
+        PRINT_ERR("los_TestInit error\n");
+        return ret;
+    }
 #endif
 
 #if (LOSCFG_PLATFORM_EXC == 1)
@@ -207,8 +201,3 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_KernelInit(VOID)
     return LOS_OK;
 }
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cpluscplus */
-#endif /* __cpluscplus */
diff --git a/kernel/liteos_m/kernel/src/los_mux.c b/kernel/liteos_m/kernel/src/los_mux.c
index 87cdf5a..d4f299c 100644
--- a/kernel/liteos_m/kernel/src/los_mux.c
+++ b/kernel/liteos_m/kernel/src/los_mux.c
@@ -28,17 +28,15 @@
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
+
+#include "los_mux.h"
 #include "los_config.h"
+#include "los_debug.h"
+#include "los_hook.h"
 #include "los_interrupt.h"
-#include "los_mux.h"
 #include "los_memory.h"
-#include "los_debug.h"
+#include "los_sched.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif
-#endif /* __cplusplus */
 
 #if (LOSCFG_BASE_IPC_MUX == 1)
 
@@ -86,7 +84,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsMuxInit(VOID)
  *****************************************************************************/
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_MuxCreate(UINT32 *muxHandle)
 {
-    UINT32 intSave;
+    UINT32 intSave = 0;
     LosMuxCB *muxCreated = NULL;
     LOS_DL_LIST *unusedMux = NULL;
     UINT32 errNo;
@@ -112,6 +110,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_MuxCreate(UINT32 *muxHandle)
     LOS_ListInit(&muxCreated->muxList);
     *muxHandle = (UINT32)muxCreated->muxID;
     LOS_IntRestore(intSave);
+    OsHookCall(LOS_HOOK_TYPE_MUX_CREATE, muxCreated);
     return LOS_OK;
 ERR_HANDLER:
     OS_RETURN_ERROR_P2(errLine, errNo);
@@ -126,7 +125,7 @@ ERR_HANDLER:
  *****************************************************************************/
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_MuxDelete(UINT32 muxHandle)
 {
-    UINT32 intSave;
+    UINT32 intSave = 0;
     LosMuxCB *muxDeleted = NULL;
     UINT32 errNo;
     UINT32 errLine;
@@ -152,6 +151,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_MuxDelete(UINT32 muxHandle)
 
     LOS_IntRestore(intSave);
 
+    OsHookCall(LOS_HOOK_TYPE_MUX_DELETE, muxDeleted);
     return LOS_OK;
 ERR_HANDLER:
     OS_RETURN_ERROR_P2(errLine, errNo);
@@ -185,7 +185,7 @@ STATIC_INLINE UINT32 OsMuxValidCheck(LosMuxCB *muxPended)
  *****************************************************************************/
 LITE_OS_SEC_TEXT UINT32 LOS_MuxPend(UINT32 muxHandle, UINT32 timeout)
 {
-    UINT32 intSave;
+    UINT32 intSave = 0;
     LosMuxCB *muxPended = NULL;
     UINT32 retErr;
     LosTaskCB *runningTask = NULL;
@@ -207,13 +207,13 @@ LITE_OS_SEC_TEXT UINT32 LOS_MuxPend(UINT32 muxHandle, UINT32 timeout)
         muxPended->owner = runningTask;
         muxPended->priority = runningTask->priority;
         LOS_IntRestore(intSave);
-        return LOS_OK;
+        goto HOOK;
     }
 
     if (muxPended->owner == runningTask) {
         muxPended->muxCount++;
         LOS_IntRestore(intSave);
-        return LOS_OK;
+        goto HOOK;
     }
 
     if (!timeout) {
@@ -224,21 +224,27 @@ LITE_OS_SEC_TEXT UINT32 LOS_MuxPend(UINT32 muxHandle, UINT32 timeout)
     runningTask->taskMux = (VOID *)muxPended;
 
     if (muxPended->owner->priority > runningTask->priority) {
-        OsTaskPriModify(muxPended->owner, runningTask->priority);
+        (VOID)OsSchedModifyTaskSchedParam(muxPended->owner, runningTask->priority);
     }
 
-    OsTaskWait(&muxPended->muxList, OS_TASK_STATUS_PEND, timeout);
+    OsSchedTaskWait(&muxPended->muxList, timeout);
 
     LOS_IntRestore(intSave);
+    OsHookCall(LOS_HOOK_TYPE_MUX_PEND, muxPended);
     LOS_Schedule();
 
+    intSave = LOS_IntLock();
     if (runningTask->taskStatus & OS_TASK_STATUS_TIMEOUT) {
-        intSave = LOS_IntLock();
         runningTask->taskStatus &= (~OS_TASK_STATUS_TIMEOUT);
         retErr = LOS_ERRNO_MUX_TIMEOUT;
         goto ERROR_MUX_PEND;
     }
 
+    LOS_IntRestore(intSave);
+    return LOS_OK;
+
+HOOK:
+    OsHookCall(LOS_HOOK_TYPE_MUX_PEND, muxPended);
     return LOS_OK;
 
 ERROR_MUX_PEND:
@@ -255,7 +261,7 @@ ERROR_MUX_PEND:
  *****************************************************************************/
 LITE_OS_SEC_TEXT UINT32 LOS_MuxPost(UINT32 muxHandle)
 {
-    UINT32 intSave;
+    UINT32 intSave = 0;
     LosMuxCB *muxPosted = GET_MUX(muxHandle);
     LosTaskCB *resumedTask = NULL;
     LosTaskCB *runningTask = NULL;
@@ -276,11 +282,12 @@ LITE_OS_SEC_TEXT UINT32 LOS_MuxPost(UINT32 muxHandle)
 
     if (--(muxPosted->muxCount) != 0) {
         LOS_IntRestore(intSave);
+        OsHookCall(LOS_HOOK_TYPE_MUX_POST, muxPosted);
         return LOS_OK;
     }
 
     if ((muxPosted->owner->priority) != muxPosted->priority) {
-        OsTaskPriModify(muxPosted->owner, muxPosted->priority);
+        (VOID)OsSchedModifyTaskSchedParam(muxPosted->owner, muxPosted->priority);
     }
 
     if (!LOS_ListEmpty(&muxPosted->muxList)) {
@@ -291,9 +298,10 @@ LITE_OS_SEC_TEXT UINT32 LOS_MuxPost(UINT32 muxHandle)
         muxPosted->priority = resumedTask->priority;
         resumedTask->taskMux = NULL;
 
-        OsTaskWake(resumedTask, OS_TASK_STATUS_PEND);
+        OsSchedTaskWake(resumedTask);
 
         LOS_IntRestore(intSave);
+        OsHookCall(LOS_HOOK_TYPE_MUX_POST, muxPosted);
         LOS_Schedule();
     } else {
         LOS_IntRestore(intSave);
@@ -303,8 +311,3 @@ LITE_OS_SEC_TEXT UINT32 LOS_MuxPost(UINT32 muxHandle)
 }
 #endif /* (LOSCFG_BASE_IPC_MUX == 1) */
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/kernel/src/los_queue.c b/kernel/liteos_m/kernel/src/los_queue.c
old mode 100755
new mode 100644
index c68ace3..ad2e0f0
--- a/kernel/liteos_m/kernel/src/los_queue.c
+++ b/kernel/liteos_m/kernel/src/los_queue.c
@@ -28,20 +28,18 @@
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-#include "los_config.h"
+
 #include "los_queue.h"
 #include "securec.h"
+#include "los_config.h"
+#include "los_debug.h"
+#include "los_hook.h"
+#include "los_interrupt.h"
 #include "los_membox.h"
-#include "los_task.h"
 #include "los_memory.h"
-#include "los_interrupt.h"
-#include "los_debug.h"
+#include "los_task.h"
+#include "los_sched.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif
-#endif /* __cplusplus */
 
 #if (LOSCFG_BASE_IPC_QUEUE == 1)
 
@@ -86,7 +84,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsQueueInit(VOID)
  Function    : LOS_QueueCreate
  Description : Create a queue
  Input       : queueName  --- Queue name, less than 4 characters
-             : len        --- Queue lenth
+             : len        --- Queue length
              : flags      --- Queue type, FIFO or PRIO
              : maxMsgSize --- Maximum message size in byte
  Output      : queueID    --- Queue ID
@@ -99,7 +97,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_QueueCreate(CHAR *queueName,
                                              UINT16 maxMsgSize)
 {
     LosQueueCB *queueCB = NULL;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     LOS_DL_LIST *unusedQueue = NULL;
     UINT8 *queue = NULL;
     UINT16 msgSize;
@@ -152,6 +150,8 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_QueueCreate(CHAR *queueName,
 
     *queueID = queueCB->queueID;
 
+    OsHookCall(LOS_HOOK_TYPE_QUEUE_CREATE, queueCB);
+
     return LOS_OK;
 }
 
@@ -205,23 +205,23 @@ static INLINE VOID OsQueueBufferOperate(LosQueueCB *queueCB, UINT32 operateType,
 {
     UINT8 *queueNode = NULL;
     UINT32 msgDataSize;
-    UINT16 queuePosion;
+    UINT16 queuePosition;
     errno_t rc;
 
     /* get the queue position */
     switch (OS_QUEUE_OPERATE_GET(operateType)) {
         case OS_QUEUE_READ_HEAD:
-            queuePosion = queueCB->queueHead;
+            queuePosition = queueCB->queueHead;
             ((queueCB->queueHead + 1) == queueCB->queueLen) ? (queueCB->queueHead = 0) : (queueCB->queueHead++);
             break;
 
         case OS_QUEUE_WRITE_HEAD:
             (queueCB->queueHead == 0) ? (queueCB->queueHead = (queueCB->queueLen - 1)) : (--queueCB->queueHead);
-            queuePosion = queueCB->queueHead;
+            queuePosition = queueCB->queueHead;
             break;
 
         case OS_QUEUE_WRITE_TAIL:
-            queuePosion = queueCB->queueTail;
+            queuePosition = queueCB->queueTail;
             ((queueCB->queueTail + 1) == queueCB->queueLen) ? (queueCB->queueTail = 0) : (queueCB->queueTail++);
             break;
 
@@ -230,7 +230,7 @@ static INLINE VOID OsQueueBufferOperate(LosQueueCB *queueCB, UINT32 operateType,
             return;
     }
 
-    queueNode = &(queueCB->queue[(queuePosion * (queueCB->queueSize))]);
+    queueNode = &(queueCB->queue[(queuePosition * (queueCB->queueSize))]);
 
     if (OS_QUEUE_IS_POINT(operateType)) {
         if (OS_QUEUE_IS_READ(operateType)) {
@@ -277,13 +277,12 @@ static INLINE UINT32 OsQueueOperateParamCheck(const LosQueueCB *queueCB, UINT32
 UINT32 OsQueueOperate(UINT32 queueID, UINT32 operateType, VOID *bufferAddr, UINT32 *bufferSize, UINT32 timeOut)
 {
     LosQueueCB *queueCB = NULL;
-    LosTaskCB *runTsk = NULL;
     LosTaskCB *resumedTask = NULL;
     UINT32 ret;
     UINT32 readWrite = OS_QUEUE_READ_WRITE_GET(operateType);
     UINT32 readWriteTmp = !readWrite;
 
-    UINTPTR intSave = LOS_IntLock();
+    UINT32 intSave = LOS_IntLock();
 
     queueCB = (LosQueueCB *)GET_QUEUE_HANDLE(queueID);
     ret = OsQueueOperateParamCheck(queueCB, operateType, bufferSize);
@@ -302,14 +301,14 @@ UINT32 OsQueueOperate(UINT32 queueID, UINT32 operateType, VOID *bufferAddr, UINT
             goto QUEUE_END;
         }
 
-        runTsk = (LosTaskCB *)g_losTask.runTask;
-        OsTaskWait(&queueCB->readWriteList[readWrite], OS_TASK_STATUS_PEND_QUEUE, timeOut);
+        LosTaskCB *runTsk = (LosTaskCB *)g_losTask.runTask;
+        OsSchedTaskWait(&queueCB->readWriteList[readWrite], timeOut);
         LOS_IntRestore(intSave);
         LOS_Schedule();
 
         intSave = LOS_IntLock();
         if (runTsk->taskStatus & OS_TASK_STATUS_TIMEOUT) {
-            runTsk->taskStatus &= (~OS_TASK_STATUS_TIMEOUT);
+            runTsk->taskStatus &= ~OS_TASK_STATUS_TIMEOUT;
             ret = LOS_ERRNO_QUEUE_TIMEOUT;
             goto QUEUE_END;
         }
@@ -319,10 +318,9 @@ UINT32 OsQueueOperate(UINT32 queueID, UINT32 operateType, VOID *bufferAddr, UINT
 
     OsQueueBufferOperate(queueCB, operateType, bufferAddr, bufferSize);
 
-
     if (!LOS_ListEmpty(&queueCB->readWriteList[readWriteTmp])) {
         resumedTask = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&queueCB->readWriteList[readWriteTmp]));
-        OsTaskWake(resumedTask, OS_TASK_STATUS_PEND_QUEUE);
+        OsSchedTaskWake(resumedTask);
         LOS_IntRestore(intSave);
         LOS_Schedule();
         return LOS_OK;
@@ -397,6 +395,9 @@ LITE_OS_SEC_TEXT UINT32 LOS_QueueRead(UINT32 queueID, VOID *bufferAddr, UINT32 b
     }
 
     operateType = OS_QUEUE_OPERATE_TYPE(OS_QUEUE_READ, OS_QUEUE_HEAD, OS_QUEUE_POINT);
+
+    OsHookCall(LOS_HOOK_TYPE_QUEUE_READ, (LosQueueCB *)GET_QUEUE_HANDLE(queueID));
+
     return OsQueueOperate(queueID, operateType, bufferAddr, &bufferSize, timeOut);
 }
 
@@ -413,6 +414,9 @@ LITE_OS_SEC_TEXT UINT32 LOS_QueueWrite(UINT32 queueID, VOID *bufferAddr, UINT32
     }
 
     operateType = OS_QUEUE_OPERATE_TYPE(OS_QUEUE_WRITE, OS_QUEUE_TAIL, OS_QUEUE_POINT);
+
+    OsHookCall(LOS_HOOK_TYPE_QUEUE_WRITE, (LosQueueCB *)GET_QUEUE_HANDLE(queueID));
+
     return OsQueueOperate(queueID, operateType, &bufferAddr, &size, timeOut);
 }
 
@@ -443,7 +447,7 @@ LITE_OS_SEC_TEXT UINT32 LOS_QueueWriteHead(UINT32 queueID,
 LITE_OS_SEC_TEXT VOID *OsQueueMailAlloc(UINT32 queueID, VOID *mailPool, UINT32 timeOut)
 {
     VOID *mem = (VOID *)NULL;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     LosQueueCB *queueCB = (LosQueueCB *)NULL;
     LosTaskCB *runTsk = (LosTaskCB *)NULL;
 
@@ -474,7 +478,7 @@ LITE_OS_SEC_TEXT VOID *OsQueueMailAlloc(UINT32 queueID, VOID *mailPool, UINT32 t
         }
 
         runTsk = (LosTaskCB *)g_losTask.runTask;
-        OsTaskWait(&queueCB->memList, OS_TASK_STATUS_PEND_QUEUE, timeOut);
+        OsSchedTaskWait(&queueCB->memList, timeOut);
         LOS_IntRestore(intSave);
         LOS_Schedule();
 
@@ -508,7 +512,7 @@ END:
 LITE_OS_SEC_TEXT UINT32 OsQueueMailFree(UINT32 queueID, VOID *mailPool, VOID *mailMem)
 {
     VOID *mem = (VOID *)NULL;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     LosQueueCB *queueCB = (LosQueueCB *)NULL;
     LosTaskCB *resumedTask = (LosTaskCB *)NULL;
 
@@ -535,7 +539,7 @@ LITE_OS_SEC_TEXT UINT32 OsQueueMailFree(UINT32 queueID, VOID *mailPool, VOID *ma
 
     if (!LOS_ListEmpty(&queueCB->memList)) {
         resumedTask = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&queueCB->memList));
-        OsTaskWake(resumedTask, OS_TASK_STATUS_PEND_QUEUE);
+        OsSchedTaskWake(resumedTask);
         mem = LOS_MemboxAlloc(mailPool);
         if (mem == NULL) {
             LOS_IntRestore(intSave);
@@ -561,7 +565,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_QueueDelete(UINT32 queueID)
 {
     LosQueueCB *queueCB = NULL;
     UINT8 *queue = NULL;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     UINT32 ret;
 
     if (queueID >= LOSCFG_BASE_IPC_QUEUE_LIMIT) {
@@ -602,6 +606,8 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_QueueDelete(UINT32 queueID)
     LOS_ListAdd(&g_freeQueueList, &queueCB->readWriteList[OS_QUEUE_WRITE]);
     LOS_IntRestore(intSave);
 
+    OsHookCall(LOS_HOOK_TYPE_QUEUE_DELETE, queueCB);
+
     ret = LOS_MemFree(m_aucSysMem0, (VOID *)queue);
     return ret;
 
@@ -612,7 +618,7 @@ QUEUE_END:
 
 LITE_OS_SEC_TEXT_MINOR UINT32 LOS_QueueInfoGet(UINT32 queueID, QUEUE_INFO_S *queueInfo)
 {
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     UINT32 ret = LOS_OK;
     LosQueueCB *queueCB = NULL;
     LosTaskCB *tskCB = NULL;
@@ -662,8 +668,3 @@ QUEUE_END:
 
 #endif /* (LOSCFG_BASE_IPC_QUEUE == 1) */
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/kernel/src/los_sched.c b/kernel/liteos_m/kernel/src/los_sched.c
new file mode 100644
index 0000000..1582af1
--- /dev/null
+++ b/kernel/liteos_m/kernel/src/los_sched.c
@@ -0,0 +1,644 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "los_sched.h"
+#include "los_task.h"
+#include "los_tick.h"
+#include "los_debug.h"
+#include "los_hook.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#define OS_64BIT_MAX               0xFFFFFFFFFFFFFFFFULL
+#define OS_PRIORITY_QUEUE_NUM      32
+#define PRIQUEUE_PRIOR0_BIT        0x80000000U
+#define OS_SCHED_TIME_SLICES       ((LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT * OS_SYS_NS_PER_US) / OS_NS_PER_CYCLE)
+#define OS_TIME_SLICE_MIN          (INT32)((50 * OS_SYS_NS_PER_US) / OS_NS_PER_CYCLE) /* 50us */
+#define OS_SCHED_MAX_RESPONSE_TIME (UINT64)(OS_64BIT_MAX - 1U)
+#define OS_TICK_RESPONSE_TIME_MAX  LOSCFG_BASE_CORE_TICK_RESPONSE_MAX
+
+#if (LOSCFG_BASE_CORE_TICK_RESPONSE_MAX == 0)
+#error "Must specify the maximum value that tick timer counter supports!"
+#endif
+
+STATIC SchedScan  g_swtmrScan = NULL;
+STATIC SortLinkAttribute *g_taskSortLinkList = NULL;
+STATIC LOS_DL_LIST g_priQueueList[OS_PRIORITY_QUEUE_NUM];
+STATIC UINT32 g_queueBitmap;
+
+STATIC UINT32 g_schedResponseID = 0;
+STATIC UINT64 g_schedResponseTime = OS_SCHED_MAX_RESPONSE_TIME;
+#if (LOSCFG_BASE_CORE_SCHED_SLEEP == 1)
+typedef struct {
+    SchedSleepInit           init;
+    SchedSleepStart          start;
+    SchedSleepStop           stop;
+    SchedSleepGetSleepTimeNs getTimeNs;
+} SchedSleep;
+
+STATIC BOOL       g_schedSleepFlags = FALSE;
+STATIC UINT64     g_schedSleepTime;
+STATIC UINT64     g_schedEntrySleepTime;
+STATIC SchedSleep g_schedSleepCB;
+#endif
+
+#if (LOSCFG_BASE_CORE_TICK_WTIMER == 0)
+STATIC UINT64 g_schedTimerBase;
+
+UINT64 OsGetBaseCycleTimer(VOID)
+{
+	return g_schedTimerBase;
+}
+
+VOID OsSchedUpdateSchedTimeBase(VOID)
+{
+    UINT32 period = 0;
+
+    (VOID)HalGetTickCycle(&period);
+    g_schedTimerBase += period;
+}
+#endif
+
+UINT64 OsGetCurrSchedTimeCycle(VOID)
+{
+    if (!g_taskScheduled) {
+        return 0;
+    }
+
+#if (LOSCFG_BASE_CORE_TICK_WTIMER == 1)
+    return HalGetTickCycle(NULL);
+#else
+    STATIC UINT64 oldSchedTime = 0;
+    UINT32 period = 0;
+    UINT32 intSave = LOS_IntLock();
+    UINT64 time = HalGetTickCycle(&period);
+    UINT64 schedTime = g_schedTimerBase + time;
+	
+    if (schedTime < oldSchedTime) {
+        /* Turn the timer count */
+        g_schedTimerBase += period;
+        schedTime = g_schedTimerBase + time;
+    }
+
+    LOS_ASSERT(schedTime >= oldSchedTime);
+
+    oldSchedTime = schedTime;
+    LOS_IntRestore(intSave);
+    return schedTime;
+#endif
+}
+
+STATIC INLINE VOID OsTimeSliceUpdate(LosTaskCB *taskCB, UINT64 currTime)
+{
+    LOS_ASSERT(currTime >= taskCB->startTime);
+
+    INT32 incTime = currTime - taskCB->startTime;
+    if (taskCB->taskID != g_idleTaskID) {
+        taskCB->timeSlice -= incTime;
+    }
+    taskCB->startTime = currTime;
+}
+
+STATIC INLINE VOID OsSchedSetNextExpireTime(UINT64 startTime, UINT32 responseID, UINT64 taskEndTime)
+{
+    UINT64 nextExpireTime = OsGetNextExpireTime(startTime);
+    UINT64 nextResponseTime;
+    BOOL isTimeSlice = FALSE;
+
+    /* The current thread's time slice has been consumed, but the current system lock task cannot
+     * trigger the schedule to release the CPU
+     */
+    if (taskEndTime < nextExpireTime) {
+        nextExpireTime = taskEndTime;
+        isTimeSlice = TRUE;
+    }
+
+    if ((g_schedResponseTime > nextExpireTime) && ((g_schedResponseTime - nextExpireTime) >= OS_CYCLE_PER_TICK)) {
+        nextResponseTime = nextExpireTime - startTime;
+        if (nextResponseTime > OS_TICK_RESPONSE_TIME_MAX) {
+#if (LOSCFG_BASE_CORE_SCHED_SLEEP == 1)
+            g_schedSleepTime = nextResponseTime - OS_CYCLE_PER_TICK;
+#endif
+            nextResponseTime = OS_TICK_RESPONSE_TIME_MAX;
+            nextExpireTime = startTime + nextResponseTime;
+        } else if (nextResponseTime < OS_CYCLE_PER_TICK) {
+#if (LOSCFG_BASE_CORE_SCHED_SLEEP == 1)
+            g_schedSleepTime = 0;
+#endif
+            nextResponseTime = OS_CYCLE_PER_TICK;
+            nextExpireTime = startTime + nextResponseTime;
+            if (nextExpireTime >= g_schedResponseTime) {
+                return;
+            }
+        }
+    } else {
+        /* There is no point earlier than the current expiration date */
+        return;
+    }
+
+    if (isTimeSlice) {
+        /* The expiration time of the current system is the thread's slice expiration time */
+        g_schedResponseID = responseID;
+    } else {
+        g_schedResponseID = OS_INVALID;
+    }
+
+    g_schedResponseTime = nextExpireTime;
+#if (LOSCFG_BASE_CORE_TICK_WTIMER == 0)
+    g_schedTimerBase = OsGetCurrSchedTimeCycle();
+#endif
+    HalSysTickReload(nextResponseTime);
+}
+
+VOID OsSchedUpdateExpireTime(UINT64 startTime)
+{
+    UINT64 endTime;
+    LosTaskCB *runTask = g_losTask.runTask;
+
+    if (runTask->taskID != g_idleTaskID) {
+        INT32 timeSlice = (runTask->timeSlice <= OS_TIME_SLICE_MIN) ? OS_SCHED_TIME_SLICES : runTask->timeSlice;
+        endTime = startTime + timeSlice;
+    } else {
+        endTime = OS_SCHED_MAX_RESPONSE_TIME;
+    }
+    OsSchedSetNextExpireTime(startTime, runTask->taskID, endTime);
+}
+
+STATIC INLINE VOID OsSchedPriQueueEnHead(LOS_DL_LIST *priqueueItem, UINT32 priority)
+{
+    /*
+     * Task control blocks are inited as zero. And when task is deleted,
+     * and at the same time would be deleted from priority queue or
+     * other lists, task pend node will restored as zero.
+     */
+    if (LOS_ListEmpty(&g_priQueueList[priority])) {
+        g_queueBitmap |= PRIQUEUE_PRIOR0_BIT >> priority;
+    }
+
+    LOS_ListAdd(&g_priQueueList[priority], priqueueItem);
+}
+
+STATIC INLINE VOID OsSchedPriQueueEnTail(LOS_DL_LIST *priqueueItem, UINT32 priority)
+{
+    if (LOS_ListEmpty(&g_priQueueList[priority])) {
+        g_queueBitmap |= PRIQUEUE_PRIOR0_BIT >> priority;
+    }
+
+    LOS_ListTailInsert(&g_priQueueList[priority], priqueueItem);
+}
+
+STATIC INLINE VOID OsSchedPriQueueDelete(LOS_DL_LIST *priqueueItem, UINT32 priority)
+{
+    LOS_ListDelete(priqueueItem);
+    if (LOS_ListEmpty(&g_priQueueList[priority])) {
+        g_queueBitmap &= ~(PRIQUEUE_PRIOR0_BIT >> priority);
+    }
+}
+
+STATIC INLINE VOID OsSchedWakePendTimeTask(UINT64 currTime, LosTaskCB *taskCB, BOOL *needSchedule)
+{
+    UINT16 tempStatus = taskCB->taskStatus;
+    if (tempStatus & (OS_TASK_STATUS_PEND | OS_TASK_STATUS_DELAY)) {
+        taskCB->taskStatus &= ~(OS_TASK_STATUS_PEND | OS_TASK_STATUS_PEND_TIME | OS_TASK_STATUS_DELAY);
+        if (tempStatus & OS_TASK_STATUS_PEND) {
+            taskCB->taskStatus |= OS_TASK_STATUS_TIMEOUT;
+            LOS_ListDelete(&taskCB->pendList);
+            taskCB->taskMux = NULL;
+            taskCB->taskSem = NULL;
+        }
+
+        if (!(tempStatus & OS_TASK_STATUS_SUSPEND)) {
+            OsSchedTaskEnQueue(taskCB);
+            *needSchedule = TRUE;
+        }
+    }
+}
+
+STATIC INLINE BOOL OsSchedScanTimerList(VOID)
+{
+    BOOL needSchedule = FALSE;
+    LOS_DL_LIST *listObject = &g_taskSortLinkList->sortLink;
+    /*
+     * When task is pended with timeout, the task block is on the timeout sortlink
+     * (per cpu) and ipc(mutex,sem and etc.)'s block at the same time, it can be waken
+     * up by either timeout or corresponding ipc it's waiting.
+     *
+     * Now synchronize sortlink preocedure is used, therefore the whole task scan needs
+     * to be protected, preventing another core from doing sortlink deletion at same time.
+     */
+
+    if (LOS_ListEmpty(listObject)) {
+        return needSchedule;
+    }
+
+    SortLinkList *sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
+    UINT64 currTime = OsGetCurrSchedTimeCycle();
+
+    while (sortList->responseTime <= currTime) {
+        LosTaskCB *taskCB = LOS_DL_LIST_ENTRY(sortList, LosTaskCB, sortList);
+        OsDeleteNodeSortLink(g_taskSortLinkList, &taskCB->sortList);
+
+        OsSchedWakePendTimeTask(currTime, taskCB, &needSchedule);
+
+        if (LOS_ListEmpty(listObject)) {
+            break;
+        }
+
+        sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
+    }
+
+    return needSchedule;
+}
+
+VOID OsSchedTaskEnQueue(LosTaskCB *taskCB)
+{
+    LOS_ASSERT(!(taskCB->taskStatus & OS_TASK_STATUS_READY));
+
+    if (taskCB->taskID != g_idleTaskID) {
+        if (taskCB->timeSlice > OS_TIME_SLICE_MIN) {
+            OsSchedPriQueueEnHead(&taskCB->pendList, taskCB->priority);
+        } else {
+            taskCB->timeSlice = OS_SCHED_TIME_SLICES;
+            OsSchedPriQueueEnTail(&taskCB->pendList, taskCB->priority);
+        }
+        OsHookCall(LOS_HOOK_TYPE_MOVEDTASKTOREADYSTATE, taskCB);
+    }
+
+    taskCB->taskStatus &= ~(OS_TASK_STATUS_PEND | OS_TASK_STATUS_SUSPEND |
+                            OS_TASK_STATUS_DELAY | OS_TASK_STATUS_PEND_TIME);
+
+    taskCB->taskStatus |= OS_TASK_STATUS_READY;
+}
+
+VOID OsSchedTaskDeQueue(LosTaskCB *taskCB)
+{
+    if (taskCB->taskStatus & OS_TASK_STATUS_READY) {
+        if (taskCB->taskID != g_idleTaskID) {
+            OsSchedPriQueueDelete(&taskCB->pendList, taskCB->priority);
+        }
+
+        taskCB->taskStatus &= ~OS_TASK_STATUS_READY;
+    }
+}
+
+VOID OsSchedTaskExit(LosTaskCB *taskCB)
+{
+    if (taskCB->taskStatus & OS_TASK_STATUS_READY) {
+        OsSchedTaskDeQueue(taskCB);
+    } else if (taskCB->taskStatus & OS_TASK_STATUS_PEND) {
+        LOS_ListDelete(&taskCB->pendList);
+        taskCB->taskStatus &= ~OS_TASK_STATUS_PEND;
+    }
+
+    if (taskCB->taskStatus & (OS_TASK_STATUS_DELAY | OS_TASK_STATUS_PEND_TIME)) {
+        OsDeleteSortLink(&taskCB->sortList, OS_SORT_LINK_TASK);
+        taskCB->taskStatus &= ~(OS_TASK_STATUS_DELAY | OS_TASK_STATUS_PEND_TIME);
+    }
+}
+
+VOID OsSchedYield(VOID)
+{
+    LosTaskCB *runTask = g_losTask.runTask;
+
+    runTask->timeSlice = 0;
+}
+
+VOID OsSchedDelay(LosTaskCB *runTask, UINT32 tick)
+{
+    runTask->taskStatus |= OS_TASK_STATUS_DELAY;
+    runTask->waitTimes = tick;
+}
+
+VOID OsSchedTaskWait(LOS_DL_LIST *list, UINT32 ticks)
+{
+    LosTaskCB *runTask = g_losTask.runTask;
+
+    runTask->taskStatus |= OS_TASK_STATUS_PEND;
+    LOS_ListTailInsert(list, &runTask->pendList);
+
+    if (ticks != LOS_WAIT_FOREVER) {
+        runTask->taskStatus |= OS_TASK_STATUS_PEND_TIME;
+        runTask->waitTimes = ticks;
+    }
+}
+
+VOID OsSchedTaskWake(LosTaskCB *resumedTask)
+{
+    LOS_ListDelete(&resumedTask->pendList);
+    resumedTask->taskStatus &= ~OS_TASK_STATUS_PEND;
+
+    if (resumedTask->taskStatus & OS_TASK_STATUS_PEND_TIME) {
+        OsDeleteSortLink(&resumedTask->sortList, OS_SORT_LINK_TASK);
+        resumedTask->taskStatus &= ~OS_TASK_STATUS_PEND_TIME;
+    }
+
+    if (!(resumedTask->taskStatus & OS_TASK_STATUS_SUSPEND) &&
+        !(resumedTask->taskStatus & OS_TASK_STATUS_RUNNING)) {
+        OsSchedTaskEnQueue(resumedTask);
+    }
+}
+
+BOOL OsSchedModifyTaskSchedParam(LosTaskCB *taskCB, UINT16 priority)
+{
+    if (taskCB->taskStatus & OS_TASK_STATUS_READY) {
+        OsSchedTaskDeQueue(taskCB);
+        taskCB->priority = priority;
+        OsSchedTaskEnQueue(taskCB);
+        return TRUE;
+    }
+
+    taskCB->priority = priority;
+    OsHookCall(LOS_HOOK_TYPE_TASK_PRIMODIFY, taskCB, taskCB->priority);
+    if (taskCB->taskStatus & OS_TASK_STATUS_RUNNING) {
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+VOID OsSchedSetIdleTaskSchedParam(LosTaskCB *idleTask)
+{
+    OsSchedTaskEnQueue(idleTask);
+}
+
+UINT32 OsSchedSwtmrScanRegister(SchedScan func)
+{
+    if (func == NULL) {
+        return LOS_NOK;
+    }
+
+    g_swtmrScan = func;
+    return LOS_OK;
+}
+
+UINT32 OsTaskNextSwitchTimeGet(VOID)
+{
+    UINT32 intSave = LOS_IntLock();
+    UINT32 ticks = OsSortLinkGetNextExpireTime(g_taskSortLinkList);
+    LOS_IntRestore(intSave);
+    return ticks;
+}
+
+UINT32 OsSchedInit(VOID)
+{
+    UINT16 pri;
+    for (pri = 0; pri < OS_PRIORITY_QUEUE_NUM; pri++) {
+        LOS_ListInit(&g_priQueueList[pri]);
+    }
+    g_queueBitmap = 0;
+
+    g_taskSortLinkList = OsGetSortLinkAttribute(OS_SORT_LINK_TASK);
+    if (g_taskSortLinkList == NULL) {
+        return LOS_NOK;
+    }
+
+    OsSortLinkInit(g_taskSortLinkList);
+    g_schedResponseTime = OS_SCHED_MAX_RESPONSE_TIME;
+
+    return LOS_OK;
+}
+
+LosTaskCB *OsGetTopTask(VOID)
+{
+    UINT32 priority;
+    LosTaskCB *newTask = NULL;
+    if (g_queueBitmap) {
+        priority = CLZ(g_queueBitmap);
+        newTask = LOS_DL_LIST_ENTRY(((LOS_DL_LIST *)&g_priQueueList[priority])->pstNext, LosTaskCB, pendList);
+    } else {
+        newTask = OS_TCB_FROM_TID(g_idleTaskID);
+    }
+
+    return newTask;
+}
+
+VOID OsSchedStart(VOID)
+{
+    (VOID)LOS_IntLock();
+    LosTaskCB *newTask = OsGetTopTask();
+
+    newTask->taskStatus |= OS_TASK_STATUS_RUNNING;
+    g_losTask.newTask = newTask;
+    g_losTask.runTask = g_losTask.newTask;
+
+    g_taskScheduled = 1;
+    newTask->startTime = OsGetCurrSchedTimeCycle();
+    OsSchedTaskDeQueue(newTask);
+
+    g_schedResponseTime = OS_SCHED_MAX_RESPONSE_TIME;
+    g_schedResponseID = OS_INVALID;
+    OsSchedSetNextExpireTime(newTask->startTime, newTask->taskID, newTask->startTime + newTask->timeSlice);
+
+    PRINTK("Entering scheduler\n");
+}
+
+BOOL OsSchedTaskSwitch(VOID)
+{
+    UINT64 endTime;
+    BOOL isTaskSwitch = FALSE;
+    LosTaskCB *runTask = g_losTask.runTask;
+    OsTimeSliceUpdate(runTask, OsGetCurrSchedTimeCycle());
+
+    if (runTask->taskStatus & (OS_TASK_STATUS_PEND_TIME | OS_TASK_STATUS_DELAY)) {
+        OsAdd2SortLink(&runTask->sortList, runTask->startTime, runTask->waitTimes, OS_SORT_LINK_TASK);
+    } else if (!(runTask->taskStatus & (OS_TASK_STATUS_PEND | OS_TASK_STATUS_SUSPEND | OS_TASK_STATUS_UNUSED))) {
+        OsSchedTaskEnQueue(runTask);
+    }
+
+    LosTaskCB *newTask = OsGetTopTask();
+    g_losTask.newTask = newTask;
+
+    if (runTask != newTask) {
+#if (LOSCFG_BASE_CORE_TSK_MONITOR == 1)
+        OsTaskSwitchCheck();
+#endif
+        runTask->taskStatus &= ~OS_TASK_STATUS_RUNNING;
+        newTask->taskStatus |= OS_TASK_STATUS_RUNNING;
+        newTask->startTime = runTask->startTime;
+        isTaskSwitch = TRUE;
+
+        OsHookCall(LOS_HOOK_TYPE_TASK_SWITCHEDIN);
+    }
+
+    OsSchedTaskDeQueue(newTask);
+
+    if (newTask->taskID != g_idleTaskID) {
+        endTime = newTask->startTime + newTask->timeSlice;
+    } else {
+        endTime = OS_SCHED_MAX_RESPONSE_TIME;
+    }
+    OsSchedSetNextExpireTime(newTask->startTime, newTask->taskID, endTime);
+
+    return isTaskSwitch;
+}
+
+VOID LOS_SchedTickHandler(VOID)
+{
+    UINT64 currTime;
+    BOOL needSched = FALSE;
+
+    LOS_ASSERT(g_taskScheduled);
+
+    UINT32 intSave = LOS_IntLock();
+
+    if (g_schedResponseID == OS_INVALID) {
+        if (g_swtmrScan != NULL) {
+            needSched = g_swtmrScan();
+        }
+
+        needSched |= OsSchedScanTimerList();
+    }
+
+    g_schedResponseTime = OS_SCHED_MAX_RESPONSE_TIME;
+    if (needSched && LOS_CHECK_SCHEDULE) {
+        HalTaskSchedule();
+    } else {
+        currTime = OsGetCurrSchedTimeCycle();
+        OsTimeSliceUpdate(g_losTask.runTask, currTime);
+        OsSchedUpdateExpireTime(currTime);
+    }
+
+    LOS_IntRestore(intSave);
+}
+
+VOID LOS_Schedule(VOID)
+{
+    if (g_taskScheduled && LOS_CHECK_SCHEDULE) {
+        HalTaskSchedule();
+    }
+}
+
+#if (LOSCFG_BASE_CORE_SCHED_SLEEP == 1)
+VOID OsSchedUpdateSleepTime(VOID)
+{
+    UINT64 nextResponseTime;
+    UINT64 currTime, realSleepTime;
+    UINT32 intSave = 0;
+
+    if ((g_schedSleepFlags == FALSE) || (g_schedSleepCB.stop == NULL)) {
+        return;
+    }
+
+    intSave = LOS_IntLock();
+    if (g_schedSleepCB.getTimeNs != NULL) {
+        realSleepTime = g_schedSleepCB.getTimeNs();
+        realSleepTime = (realSleepTime / OS_SYS_NS_PER_SECOND) * OS_SYS_CLOCK +
+                        (realSleepTime % OS_SYS_NS_PER_SECOND) * OS_SYS_CLOCK / OS_SYS_NS_PER_SECOND;
+        if (realSleepTime < g_schedSleepTime) {
+            nextResponseTime = g_schedSleepTime - realSleepTime;
+        } else {
+            nextResponseTime = 0;
+        }
+
+#if (LOSCFG_BASE_CORE_TICK_WTIMER == 1)
+        currTime = HalGetTickCycle(NULL);
+#else
+        g_schedTimerBase = g_schedEntrySleepTime + realSleepTime;
+        currTime = g_schedTimerBase;
+#endif
+        if (nextResponseTime > OS_TICK_RESPONSE_TIME_MAX) {
+            nextResponseTime = OS_TICK_RESPONSE_TIME_MAX;
+        } else if (nextResponseTime < OS_CYCLE_PER_TICK) {
+            nextResponseTime = OS_CYCLE_PER_TICK;
+        }
+
+        g_schedResponseID = OS_INVALID;
+        g_schedResponseTime = currTime + nextResponseTime;
+        HalSysTickReload(nextResponseTime);
+        g_schedSleepTime = 0;
+    }
+    g_schedSleepFlags = FALSE;
+    g_schedSleepCB.stop();
+    LOS_IntRestore(intSave);
+}
+
+VOID OsSchedToSleep(VOID)
+{
+    UINT32 intSave = 0;
+    UINT64 sleepTime;
+
+    if (g_schedSleepCB.start == NULL) {
+        return;
+    }
+
+    if (g_schedSleepCB.getTimeNs != NULL) {
+        sleepTime = (g_schedSleepTime / OS_SYS_CLOCK) * OS_SYS_NS_PER_SECOND +
+                    (g_schedSleepTime % OS_SYS_CLOCK) * OS_SYS_NS_PER_SECOND / OS_SYS_CLOCK;
+        if (sleepTime == 0) {
+            return;
+        }
+
+        intSave = LOS_IntLock();
+        HalTickLock();
+        g_schedEntrySleepTime = OsGetCurrSchedTimeCycle();
+    } else {
+        intSave = LOS_IntLock();
+    }
+
+    g_schedSleepCB.start(sleepTime);
+    g_schedSleepFlags = TRUE;
+    LOS_IntRestore(intSave);
+}
+
+UINT32 LOS_SchedSleepInit(SchedSleepInit init, SchedSleepStart start,
+                          SchedSleepStop stop, SchedSleepGetSleepTimeNs getTime)
+{
+    UINT32 ret;
+
+    if ((init == NULL) && (start == NULL) && (stop == NULL)) {
+        return LOS_NOK;
+    }
+
+    g_schedSleepCB.init = init;
+    g_schedSleepCB.start = start;
+    g_schedSleepCB.stop = stop;
+    g_schedSleepCB.getTimeNs = getTime;
+
+    if (g_schedSleepCB.init != NULL) {
+        ret = g_schedSleepCB.init();
+        if (ret != LOS_OK) {
+            return ret;
+        }
+    }
+
+    return LOS_OK;
+}
+#endif
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
diff --git a/kernel/liteos_m/kernel/src/los_sem.c b/kernel/liteos_m/kernel/src/los_sem.c
old mode 100755
new mode 100644
index 830625a..cb58a5d
--- a/kernel/liteos_m/kernel/src/los_sem.c
+++ b/kernel/liteos_m/kernel/src/los_sem.c
@@ -28,17 +28,16 @@
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-#include "los_config.h"
+
 #include "los_sem.h"
-#include "los_memory.h"
-#include "los_interrupt.h"
+#include "los_arch.h"
+#include "los_config.h"
 #include "los_debug.h"
+#include "los_hook.h"
+#include "los_interrupt.h"
+#include "los_memory.h"
+#include "los_sched.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif
-#endif /* __cplusplus */
 
 #if (LOSCFG_BASE_IPC_SEM == 1)
 
@@ -47,7 +46,7 @@ LITE_OS_SEC_BSS LosSemCB *g_allSem = NULL;
 
 /*****************************************************************************
  Function     : OsSemInit
- Description  : Initialize the  Semaphore doubly linked list
+ Description  : Initialize the Semaphore doubly linked list
  Input        : None
  Output       : None
  Return       : LOS_OK on success, or error code on failure
@@ -68,7 +67,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsSemInit(VOID)
         return LOS_ERRNO_SEM_NO_MEMORY;
     }
 
-    /* Connect all the ECBs in a doubly linked list. */
+    /* Connect all the semaphore CBs in a doubly linked list. */
     for (index = 0; index < LOSCFG_BASE_IPC_SEM_LIMIT; index++) {
         semNode = ((LosSemCB *)g_allSem) + index;
         semNode->semID = index;
@@ -80,7 +79,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsSemInit(VOID)
 
 /*****************************************************************************
  Function     : OsSemCreate
- Description  : create the  Semaphore
+ Description  : create the Semaphore
  Input        : count      --- Semaphore count
               : maxCount   --- Max semaphore count for check
  Output       : semHandle  --- Index of semaphore
@@ -88,7 +87,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsSemInit(VOID)
  *****************************************************************************/
 LITE_OS_SEC_TEXT_INIT UINT32 OsSemCreate(UINT16 count, UINT16 maxCount, UINT32 *semHandle)
 {
-    UINT32 intSave;
+    UINT32 intSave = 0;
     LosSemCB *semCreated = NULL;
     LOS_DL_LIST *unusedSem = NULL;
     UINT32 errNo;
@@ -118,6 +117,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsSemCreate(UINT16 count, UINT16 maxCount, UINT32 *
     LOS_ListInit(&semCreated->semList);
     *semHandle = (UINT32)semCreated->semID;
     LOS_IntRestore(intSave);
+    OsHookCall(LOS_HOOK_TYPE_SEM_CREATE, semCreated);
     return LOS_OK;
 
 ERR_HANDLER:
@@ -157,7 +157,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_BinarySemCreate(UINT16 count, UINT32 *semHandle
  *****************************************************************************/
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_SemDelete(UINT32 semHandle)
 {
-    UINT32 intSave;
+    UINT32 intSave = 0;
     LosSemCB *semDeleted = NULL;
     UINT32 errNo;
     UINT32 errLine;
@@ -181,6 +181,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_SemDelete(UINT32 semHandle)
     LOS_ListAdd(&g_unusedSemList, &semDeleted->semList);
     semDeleted->semStat = OS_SEM_UNUSED;
     LOS_IntRestore(intSave);
+    OsHookCall(LOS_HOOK_TYPE_SEM_DELETE, semDeleted);
     return LOS_OK;
 ERR_HANDLER:
     OS_RETURN_ERROR_P2(errLine, errNo);
@@ -215,7 +216,7 @@ STATIC_INLINE UINT32 OsSemValidCheck(LosSemCB *semPended)
  *****************************************************************************/
 LITE_OS_SEC_TEXT UINT32 LOS_SemPend(UINT32 semHandle, UINT32 timeout)
 {
-    UINT32 intSave;
+    UINT32 intSave = 0;
     LosSemCB *semPended = NULL;
     UINT32 retErr;
     LosTaskCB *runningTask = NULL;
@@ -235,6 +236,7 @@ LITE_OS_SEC_TEXT UINT32 LOS_SemPend(UINT32 semHandle, UINT32 timeout)
     if (semPended->semCount > 0) {
         semPended->semCount--;
         LOS_IntRestore(intSave);
+        OsHookCall(LOS_HOOK_TYPE_SEM_PEND, semPended, runningTask);
         return LOS_OK;
     }
 
@@ -245,17 +247,19 @@ LITE_OS_SEC_TEXT UINT32 LOS_SemPend(UINT32 semHandle, UINT32 timeout)
 
     runningTask = (LosTaskCB *)g_losTask.runTask;
     runningTask->taskSem = (VOID *)semPended;
-    OsTaskWait(&semPended->semList, OS_TASK_STATUS_PEND, timeout);
+    OsSchedTaskWait(&semPended->semList, timeout);
     LOS_IntRestore(intSave);
+    OsHookCall(LOS_HOOK_TYPE_SEM_PEND, semPended, runningTask);
     LOS_Schedule();
 
+    intSave = LOS_IntLock();
     if (runningTask->taskStatus & OS_TASK_STATUS_TIMEOUT) {
-        intSave = LOS_IntLock();
         runningTask->taskStatus &= (~OS_TASK_STATUS_TIMEOUT);
         retErr = LOS_ERRNO_SEM_TIMEOUT;
         goto ERROR_SEM_PEND;
     }
 
+    LOS_IntRestore(intSave);
     return LOS_OK;
 
 ERROR_SEM_PEND:
@@ -272,7 +276,7 @@ ERROR_SEM_PEND:
  *****************************************************************************/
 LITE_OS_SEC_TEXT UINT32 LOS_SemPost(UINT32 semHandle)
 {
-    UINT32 intSave;
+    UINT32 intSave = 0;
     LosSemCB *semPosted = GET_SEM(semHandle);
     LosTaskCB *resumedTask = NULL;
 
@@ -294,22 +298,18 @@ LITE_OS_SEC_TEXT UINT32 LOS_SemPost(UINT32 semHandle)
     if (!LOS_ListEmpty(&semPosted->semList)) {
         resumedTask = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&(semPosted->semList)));
         resumedTask->taskSem = NULL;
-        OsTaskWake(resumedTask, OS_TASK_STATUS_PEND);
+        OsSchedTaskWake(resumedTask);
 
         LOS_IntRestore(intSave);
+        OsHookCall(LOS_HOOK_TYPE_SEM_POST, semPosted, resumedTask);
         LOS_Schedule();
     } else {
         semPosted->semCount++;
         LOS_IntRestore(intSave);
+        OsHookCall(LOS_HOOK_TYPE_SEM_POST, semPosted, resumedTask);
     }
 
     return LOS_OK;
 }
 
 #endif /* (LOSCFG_BASE_IPC_SEM == 1) */
-
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/kernel/src/los_sortlink.c b/kernel/liteos_m/kernel/src/los_sortlink.c
new file mode 100644
index 0000000..90ceccd
--- /dev/null
+++ b/kernel/liteos_m/kernel/src/los_sortlink.c
@@ -0,0 +1,214 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "los_sortlink.h"
+#include "los_sched.h"
+#include "los_debug.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+STATIC SortLinkAttribute g_taskSortLink;
+STATIC SortLinkAttribute g_swtmrSortLink;
+
+UINT32 OsSortLinkInit(SortLinkAttribute *sortLinkHeader)
+{
+    LOS_ListInit(&sortLinkHeader->sortLink);
+    return LOS_OK;
+}
+
+STATIC INLINE VOID OsAddNode2SortLink(SortLinkAttribute *sortLinkHeader, SortLinkList *sortList)
+{
+    LOS_DL_LIST *head = (LOS_DL_LIST *)&sortLinkHeader->sortLink;
+
+    if (LOS_ListEmpty(head)) {
+        LOS_ListAdd(head, &sortList->sortLinkNode);
+        return;
+    }
+
+    SortLinkList *listSorted = LOS_DL_LIST_ENTRY(head->pstNext, SortLinkList, sortLinkNode);
+    if (listSorted->responseTime > sortList->responseTime) {
+        LOS_ListAdd(head, &sortList->sortLinkNode);
+        return;
+    } else if (listSorted->responseTime == sortList->responseTime) {
+        LOS_ListAdd(head->pstNext, &sortList->sortLinkNode);
+        return;
+    }
+
+    LOS_DL_LIST *prevNode = head->pstPrev;
+    do {
+        listSorted = LOS_DL_LIST_ENTRY(prevNode, SortLinkList, sortLinkNode);
+        if (listSorted->responseTime <= sortList->responseTime) {
+            LOS_ListAdd(prevNode, &sortList->sortLinkNode);
+            break;
+        }
+
+        prevNode = prevNode->pstPrev;
+    } while (1);
+}
+
+VOID OsDeleteNodeSortLink(SortLinkAttribute *sortLinkHeader, SortLinkList *sortList)
+{
+    LOS_ListDelete(&sortList->sortLinkNode);
+    SET_SORTLIST_VALUE(sortList, OS_SORT_LINK_INVALID_TIME);
+}
+
+STATIC INLINE UINT64 OsGetSortLinkNextExpireTime(SortLinkAttribute *sortHeader, UINT64 startTime)
+{
+    UINT64 expirTime = 0;
+    UINT64 nextExpirTime = 0;
+    LOS_DL_LIST *head = &sortHeader->sortLink;
+    LOS_DL_LIST *list = head->pstNext;
+
+    if (LOS_ListEmpty(head)) {
+        return (UINT64)-1;
+    }
+
+    do {
+        SortLinkList *listSorted = LOS_DL_LIST_ENTRY(list, SortLinkList, sortLinkNode);
+        if (listSorted->responseTime <= startTime) {
+            expirTime = startTime;
+            list = list->pstNext;
+        } else {
+            nextExpirTime = listSorted->responseTime;
+            break;
+        }
+    } while (list != head);
+
+    if (expirTime == 0) {
+        return nextExpirTime;
+    }
+
+    if (nextExpirTime == 0) {
+        return expirTime;
+    }
+
+    if ((nextExpirTime - expirTime) <= OS_US_PER_TICK) {
+        return nextExpirTime;
+    }
+
+    return expirTime;
+}
+
+VOID OsAdd2SortLink(SortLinkList *node, UINT64 startTime, UINT32 waitTicks, SortLinkType type)
+{
+    UINT32 intSave = 0;
+    SortLinkAttribute *sortLinkHeader = NULL;
+
+    if (type == OS_SORT_LINK_TASK) {
+        sortLinkHeader = &g_taskSortLink;
+    } else if (type == OS_SORT_LINK_SWTMR) {
+        sortLinkHeader = &g_swtmrSortLink;
+    } else {
+        LOS_Panic("Sort link type error : %u\n", type);
+    }
+
+    intSave = LOS_IntLock();
+    SET_SORTLIST_VALUE(node, startTime + (UINT64)waitTicks * OS_CYCLE_PER_TICK);
+    OsAddNode2SortLink(sortLinkHeader, node);
+    LOS_IntRestore(intSave);
+}
+
+VOID OsDeleteSortLink(SortLinkList *node, SortLinkType type)
+{
+    UINT32 intSave = 0;
+    SortLinkAttribute *sortLinkHeader = NULL;
+
+    if (type == OS_SORT_LINK_TASK) {
+        sortLinkHeader = &g_taskSortLink;
+    } else if (type == OS_SORT_LINK_SWTMR) {
+        sortLinkHeader = &g_swtmrSortLink;
+    } else {
+        LOS_Panic("Sort link type error : %u\n", type);
+    }
+
+    intSave = LOS_IntLock();
+    if (node->responseTime != OS_SORT_LINK_INVALID_TIME) {
+        OsDeleteNodeSortLink(sortLinkHeader, node);
+    }
+    LOS_IntRestore(intSave);
+}
+
+SortLinkAttribute *OsGetSortLinkAttribute(SortLinkType type)
+{
+    if (type == OS_SORT_LINK_TASK) {
+        return &g_taskSortLink;
+    } else if (type == OS_SORT_LINK_SWTMR) {
+        return &g_swtmrSortLink;
+    }
+
+    PRINT_ERR("Invalid sort link type!\n");
+    return NULL;
+}
+
+UINT64 OsGetNextExpireTime(UINT64 startTime)
+{
+    UINT32 intSave = 0;
+    SortLinkAttribute *taskHeader = &g_taskSortLink;
+    SortLinkAttribute *swtmrHeader = &g_swtmrSortLink;
+
+    intSave = LOS_IntLock();
+    UINT64 taskExpirTime = OsGetSortLinkNextExpireTime(taskHeader, startTime);
+    UINT64 swtmrExpirTime = OsGetSortLinkNextExpireTime(swtmrHeader, startTime);
+    LOS_IntRestore(intSave);
+
+    return (taskExpirTime < swtmrExpirTime) ? taskExpirTime : swtmrExpirTime;
+}
+
+UINT32 OsSortLinkGetTargetExpireTime(UINT64 currTime, const SortLinkList *targetSortList)
+{
+    if (currTime >= targetSortList->responseTime) {
+        return 0;
+    }
+
+    return (UINT32)(((targetSortList->responseTime - currTime) * LOSCFG_BASE_CORE_TICK_PER_SECOND) / OS_SYS_CLOCK);
+}
+
+UINT32 OsSortLinkGetNextExpireTime(const SortLinkAttribute *sortLinkHeader)
+{
+    LOS_DL_LIST *head = (LOS_DL_LIST *)&sortLinkHeader->sortLink;
+
+    if (LOS_ListEmpty(head)) {
+        return 0;
+    }
+
+    SortLinkList *listSorted = LOS_DL_LIST_ENTRY(head->pstNext, SortLinkList, sortLinkNode);
+    return OsSortLinkGetTargetExpireTime(OsGetCurrSchedTimeCycle(), listSorted);
+}
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
diff --git a/kernel/liteos_m/kernel/src/los_swtmr.c b/kernel/liteos_m/kernel/src/los_swtmr.c
index 1d02a04..4bee8b3 100644
--- a/kernel/liteos_m/kernel/src/los_swtmr.c
+++ b/kernel/liteos_m/kernel/src/los_swtmr.c
@@ -29,26 +29,21 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 #include "los_config.h"
-#include "securec.h"
 #include "los_interrupt.h"
 #include "los_swtmr.h"
 #include "los_task.h"
 #include "los_memory.h"
 #include "los_queue.h"
 #include "los_debug.h"
-
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
+#include "los_sched.h"
+#include "securec.h"
 
 #if (LOSCFG_BASE_CORE_SWTMR == 1)
 
-LITE_OS_SEC_BSS UINT32          g_swtmrHandlerQueue;           /* Software Timer timeout queue ID */
-LITE_OS_SEC_BSS SWTMR_CTRL_S    *g_swtmrCBArray = NULL;        /* first address in Timer memory space */
-LITE_OS_SEC_BSS SWTMR_CTRL_S    *g_swtmrFreeList = NULL;       /* Free list of Softwaer Timer */
-LITE_OS_SEC_BSS SWTMR_CTRL_S    *g_swtmrSortList = NULL;       /* The software timer count list */
+LITE_OS_SEC_BSS UINT32            g_swtmrHandlerQueue;           /* Software Timer timeout queue ID */
+LITE_OS_SEC_BSS SWTMR_CTRL_S      *g_swtmrCBArray = NULL;        /* first address in Timer memory space */
+LITE_OS_SEC_BSS SWTMR_CTRL_S      *g_swtmrFreeList = NULL;       /* Free list of Software Timer */
+LITE_OS_SEC_BSS SortLinkAttribute *g_swtmrSortLinkList = NULL;       /* The software timer count list */
 
 #if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
 typedef struct SwtmrAlignDataStr {
@@ -59,9 +54,6 @@ typedef struct SwtmrAlignDataStr {
     UINT32 isAligned : 1;
 } SwtmrAlignData;
 LITE_OS_SEC_BSS SwtmrAlignData      g_swtmrAlignID[LOSCFG_BASE_CORE_SWTMR_LIMIT] = {0};   /* store swtmr align */
-static UINT32                       g_swtimerRousesTime = 0;  /* suspend time */
-static SWTMR_CTRL_S                 *g_swtmrRouses = NULL;    /* first swtmr that can wake up */
-static SWTMR_CTRL_S                 *g_swtmrRousesPrev = NULL;
 #endif
 
 #define SWTMR_MAX_RUNNING_TICKS 2
@@ -77,14 +69,14 @@ Return      : None
 LITE_OS_SEC_TEXT VOID OsSwtmrTask(VOID)
 {
     SwtmrHandlerItem swtmrHandle;
-    UINT32 readSzie;
+    UINT32 readSize;
     UINT32 ret;
     UINT64 tick;
-    readSzie = sizeof(SwtmrHandlerItem);
+    readSize = sizeof(SwtmrHandlerItem);
 
     for (;;) {
-        ret = LOS_QueueReadCopy(g_swtmrHandlerQueue, &swtmrHandle, &readSzie, LOS_WAIT_FOREVER);
-        if ((ret == LOS_OK) && (readSzie == sizeof(SwtmrHandlerItem))) {
+        ret = LOS_QueueReadCopy(g_swtmrHandlerQueue, &swtmrHandle, &readSize, LOS_WAIT_FOREVER);
+        if ((ret == LOS_OK) && (readSize == sizeof(SwtmrHandlerItem))) {
             if (swtmrHandle.handler == NULL) {
                 continue;
             }
@@ -125,103 +117,48 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsSwtmrTaskCreate(VOID)
     return ret;
 }
 
-/*****************************************************************************
-Function    : OsSwtmrInit
-Description : Initializes Software Timer
-Input       : None
-Output      : None
-Return      : LOS_OK on success or error code on failure
-*****************************************************************************/
-LITE_OS_SEC_TEXT_INIT UINT32 OsSwtmrInit(VOID)
-{
-    UINT32 size;
-    UINT16 index;
-    UINT32 ret;
-    SWTMR_CTRL_S *swtmr = NULL;
-    SWTMR_CTRL_S *temp = NULL;
-
-#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
-    // Ignore the return code when matching CSEC rule 6.6(1).
-    (VOID)memset_s((VOID *)g_swtmrAlignID, sizeof(SwtmrAlignData) * LOSCFG_BASE_CORE_SWTMR_LIMIT,
-                   0, sizeof(SwtmrAlignData) * LOSCFG_BASE_CORE_SWTMR_LIMIT);
-#endif
-
-    g_swtmrSortList = (SWTMR_CTRL_S *)NULL;
-    size = sizeof(SWTMR_CTRL_S) * LOSCFG_BASE_CORE_SWTMR_LIMIT;
-    swtmr = (SWTMR_CTRL_S *)LOS_MemAlloc(m_aucSysMem0, size);
-    if (swtmr == NULL) {
-        return LOS_ERRNO_SWTMR_NO_MEMORY;
-    }
-    // Ignore the return code when matching CSEC rule 6.6(3).
-    (VOID)memset_s((VOID *)swtmr, size, 0, size);
-    g_swtmrCBArray = swtmr;
-    g_swtmrFreeList = swtmr;
-    swtmr->usTimerID = 0;
-    temp = swtmr;
-    swtmr++;
-    for (index = 1; index < LOSCFG_BASE_CORE_SWTMR_LIMIT; index++, swtmr++) {
-        swtmr->usTimerID = index;
-        temp->pstNext = swtmr;
-        temp = swtmr;
-    }
-
-    ret = LOS_QueueCreate((CHAR *)NULL, OS_SWTMR_HANDLE_QUEUE_SIZE,
-                          &g_swtmrHandlerQueue, 0, sizeof(SwtmrHandlerItem));
-    if (ret != LOS_OK) {
-        (VOID)LOS_MemFree(m_aucSysMem0, swtmr);
-        return LOS_ERRNO_SWTMR_QUEUE_CREATE_FAILED;
-    }
-
-    ret = OsSwtmrTaskCreate();
-    if (ret != LOS_OK) {
-        (VOID)LOS_MemFree(m_aucSysMem0, swtmr);
-        return LOS_ERRNO_SWTMR_TASK_CREATE_FAILED;
-    }
-
-    return LOS_OK;
-}
-
 #if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
-STATIC_INLINE UINT32 OsSwtmrCalcAlignCount(UINT32 interval, UINT32 timerId)
+STATIC_INLINE UINT32 OsSwtmrCalcAlignCount(UINT64 currTime, UINT32 interval, UINT32 timerId)
 {
-    SWTMR_CTRL_S *cur = g_swtmrSortList;
-    UINT32 count = 0;
+    UINT32 count;
+
     if (interval == 0) {
         return interval;
     }
-    while (cur != NULL) {
-        count += cur->uwCount;
-        if (cur->usTimerID == timerId) {
-            return (interval - (cur->uwInterval - count) % interval);
-        }
-        cur = cur->pstNext;
-    }
-    return interval;
+    SWTMR_CTRL_S *cur = g_swtmrCBArray + timerId % LOSCFG_BASE_CORE_SWTMR_LIMIT;
+    count = OsSortLinkGetTargetExpireTime(currTime, &cur->stSortList);
+    return (interval - (cur->uwInterval - count) % interval);
 }
 
-LITE_OS_SEC_TEXT SWTMR_CTRL_S* OsSwtmrFindAlignPos(SWTMR_CTRL_S *swtmr)
+VOID OsSwtmrFindAlignPos(UINT64 currTime, SWTMR_CTRL_S *swtmr)
 {
-    SWTMR_CTRL_S *intPos = (SWTMR_CTRL_S *)NULL;
-    SWTMR_CTRL_S *cur = (SWTMR_CTRL_S *)NULL;
     SWTMR_CTRL_S *minInLarge = (SWTMR_CTRL_S *)NULL;
-    SWTMR_CTRL_S *maxInLitte = (SWTMR_CTRL_S *)NULL;
+    SWTMR_CTRL_S *maxInLittle = (SWTMR_CTRL_S *)NULL;
     UINT32 currSwtmrTimes, swtmrTimes;
-    SwtmrAlignData swtmrAlgInfo, currSwtmrAlgInfo;
     UINT32 minInLargeVal = OS_NULL_INT;
-    UINT32 maxInLitteval = OS_NULL_INT;
+    UINT32 maxInLittleVal = OS_NULL_INT;
 
-    currSwtmrAlgInfo = g_swtmrAlignID[swtmr->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT];
+    LOS_DL_LIST *listHead = &g_swtmrSortLinkList->sortLink;
+    if (LOS_ListEmpty(listHead)) {
+        return;
+    }
+
+    SwtmrAlignData currSwtmrAlgInfo = g_swtmrAlignID[swtmr->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT];
     currSwtmrTimes = currSwtmrAlgInfo.times;
-    cur = g_swtmrSortList;
-    while (cur != NULL) {
-        swtmrAlgInfo = g_swtmrAlignID[cur->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT];
-        if ((swtmrAlgInfo.isAligned == 0) || (swtmrAlgInfo.canAlign == 0)) { // swtmr not start
+    LOS_DL_LIST *listObject = listHead->pstNext;
+
+    do {
+        SortLinkList *sortList = LOS_DL_LIST_ENTRY(listObject, SortLinkList, sortLinkNode);
+        SWTMR_CTRL_S *cur = LOS_DL_LIST_ENTRY(sortList, SWTMR_CTRL_S, stSortList);
+        SwtmrAlignData swtmrAlgInfo = g_swtmrAlignID[cur->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT];
+        /* swtmr not start */
+        if ((swtmrAlgInfo.isAligned == 0) || (swtmrAlgInfo.canAlign == 0)) {
             goto CONTINUE_NEXT_NODE;
         }
-        // find same interval timer, directly return
+        /* find same interval timer, directly return */
         if (cur->uwInterval == swtmr->uwInterval) {
-            swtmr->uwCount = 0;
-            return cur;
+            swtmr->uwCount = OsSortLinkGetTargetExpireTime(currTime, &cur->stSortList);
+            return;
         }
 
         if ((currSwtmrAlgInfo.canMultiple != 1) || (swtmrAlgInfo.times == 0)) {
@@ -229,7 +166,7 @@ LITE_OS_SEC_TEXT SWTMR_CTRL_S* OsSwtmrFindAlignPos(SWTMR_CTRL_S *swtmr)
         }
         swtmrTimes = swtmrAlgInfo.times;
         if (currSwtmrTimes == 0) {
-            return NULL;
+            return;
         }
         if ((swtmrTimes >= currSwtmrTimes) && ((swtmrTimes % currSwtmrTimes) == 0)) {
             if (minInLargeVal > (swtmrTimes / currSwtmrTimes)) {
@@ -237,22 +174,22 @@ LITE_OS_SEC_TEXT SWTMR_CTRL_S* OsSwtmrFindAlignPos(SWTMR_CTRL_S *swtmr)
                 minInLarge = cur;
             }
         } else if ((swtmrTimes < currSwtmrTimes) && ((currSwtmrTimes % swtmrTimes) == 0)) {
-            if (maxInLitteval > (currSwtmrTimes / swtmrTimes)) {
-                maxInLitteval = currSwtmrTimes / swtmrTimes;
-                maxInLitte = cur;
+            if (maxInLittleVal > (currSwtmrTimes / swtmrTimes)) {
+                maxInLittleVal = currSwtmrTimes / swtmrTimes;
+                maxInLittle = cur;
             }
         }
-    CONTINUE_NEXT_NODE:
+CONTINUE_NEXT_NODE:
+        listObject = listObject->pstNext;
+    } while (listObject != listHead);
 
-        cur = cur->pstNext;
-    }
     if (minInLarge != NULL) {
-        swtmr->uwCount = OsSwtmrCalcAlignCount(swtmr->uwInterval, minInLarge->usTimerID);
-    } else if (maxInLitte != NULL) {
-        swtmr->uwCount = 0;
-        intPos = maxInLitte;
+        swtmr->uwCount = OsSwtmrCalcAlignCount(currTime, swtmr->uwInterval, minInLarge->usTimerID);
+    } else if (maxInLittle != NULL) {
+        swtmr->uwCount = OsSortLinkGetTargetExpireTime(currTime, &maxInLittle->stSortList);
     }
-    return intPos;
+
+    return;
 }
 #endif
 
@@ -265,38 +202,22 @@ Return      : None
 *****************************************************************************/
 LITE_OS_SEC_TEXT VOID OsSwtmrStart(SWTMR_CTRL_S *swtmr)
 {
-    SWTMR_CTRL_S *prev = (SWTMR_CTRL_S *)NULL;
-    SWTMR_CTRL_S *cur = (SWTMR_CTRL_S *)NULL;
+    UINT64 currTime = OsGetCurrSchedTimeCycle();
 
     swtmr->uwCount = swtmr->uwInterval;
+    swtmr->ucState = OS_SWTMR_STATUS_TICKING;
 
 #if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
     if ((g_swtmrAlignID[swtmr->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT].canAlign == 1) &&
         (g_swtmrAlignID[swtmr->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT].isAligned == 0)) {
         g_swtmrAlignID[swtmr->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT].isAligned = 1;
-        prev = OsSwtmrFindAlignPos(swtmr);
+        OsSwtmrFindAlignPos(currTime, swtmr);
     }
 #endif
-
-    if (prev == NULL) {
-        cur = g_swtmrSortList;
-        while (cur != NULL) {
-            if (cur->uwCount > swtmr->uwCount) {
-                break;
-            }
-
-            swtmr->uwCount -= cur->uwCount;
-            prev = cur;
-            cur = cur->pstNext;
-        }
+    OsAdd2SortLink(&swtmr->stSortList, currTime, swtmr->uwCount, OS_SORT_LINK_SWTMR);
+    if (LOS_TaskIsRunning()) {
+        OsSchedUpdateExpireTime(currTime);
     }
-
-    swtmr->pstNext = ((prev == NULL) ? g_swtmrSortList : prev->pstNext);
-    if (swtmr->pstNext != NULL) {
-        swtmr->pstNext->uwCount -= swtmr->uwCount;
-    }
-    (prev == NULL) ? (g_swtmrSortList = swtmr) : (prev->pstNext = swtmr);
-    swtmr->ucState = OS_SWTMR_STATUS_TICKING;
 }
 
 /*****************************************************************************
@@ -320,93 +241,67 @@ STATIC_INLINE VOID OsSwtmrDelete(SWTMR_CTRL_S *swtmr)
 }
 
 
-LITE_OS_SEC_TEXT VOID OsSwtmrStop(const SWTMR_CTRL_S *swtmr)
+LITE_OS_SEC_TEXT VOID OsSwtmrStop(SWTMR_CTRL_S *swtmr)
 {
-    SWTMR_CTRL_S *prev = (SWTMR_CTRL_S *)NULL;
-    SWTMR_CTRL_S *cur = (SWTMR_CTRL_S *)NULL;
-
-    if (!g_swtmrSortList) {
-        return;
-    }
-
-    cur = g_swtmrSortList;
-
-    while (cur != swtmr) {
-        prev = cur;
-        cur = cur->pstNext;
-    }
-    if (cur == NULL) {
-        return;
-    }
-    if (cur->pstNext != NULL) {
-        cur->pstNext->uwCount += cur->uwCount;
-    }
-
-    if (prev == NULL) {
-        g_swtmrSortList = cur->pstNext;
-    } else {
-        prev->pstNext = cur->pstNext;
-    }
-
-    cur->pstNext = (SWTMR_CTRL_S *)NULL;
-    cur->ucState = OS_SWTMR_STATUS_CREATED;
+    OsDeleteSortLink(&swtmr->stSortList, OS_SORT_LINK_SWTMR);
+    swtmr->ucState = OS_SWTMR_STATUS_CREATED;
 
+    if (LOS_TaskIsRunning()) {
+        OsSchedUpdateExpireTime(OsGetCurrSchedTimeCycle());
 #if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
-    g_swtmrAlignID[swtmr->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT].isAligned = 0;
+        g_swtmrAlignID[swtmr->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT].isAligned = 0;
 #endif
+    }
 }
 
-/*****************************************************************************
-Function    : OsSwtmrTimeoutHandle
-Description : Software Timer time out handler
-Input       : None
-Output      : None
-Return      : None
-*****************************************************************************/
-LITE_OS_SEC_TEXT static VOID OsSwtmrTimeoutHandle(VOID)
+STATIC VOID OsSwtmrTimeoutHandle(SWTMR_CTRL_S *swtmr)
 {
-    SWTMR_CTRL_S *swtmr = g_swtmrSortList;
     SwtmrHandlerItem swtmrHandler;
 
-    while ((swtmr != NULL) && (swtmr->uwCount == 0)) {
-        g_swtmrSortList = swtmr->pstNext;
-        swtmrHandler.handler = swtmr->pfnHandler;
-        swtmrHandler.arg = swtmr->uwArg;
-        (VOID)LOS_QueueWriteCopy(g_swtmrHandlerQueue, &swtmrHandler, sizeof(SwtmrHandlerItem), LOS_NO_WAIT);
-        if (swtmr->ucMode == LOS_SWTMR_MODE_ONCE) {
-            OsSwtmrDelete(swtmr);
-            if (swtmr->usTimerID < (OS_SWTMR_MAX_TIMERID - LOSCFG_BASE_CORE_SWTMR_LIMIT)) {
-                swtmr->usTimerID += LOSCFG_BASE_CORE_SWTMR_LIMIT;
-            } else {
-                swtmr->usTimerID %= LOSCFG_BASE_CORE_SWTMR_LIMIT;
-            }
-        } else if (swtmr->ucMode == LOS_SWTMR_MODE_PERIOD) {
-            OsSwtmrStart(swtmr);
-        } else if (swtmr->ucMode == LOS_SWTMR_MODE_NO_SELFDELETE) {
-            swtmr->ucState = OS_SWTMR_STATUS_CREATED;
-        }
+    swtmrHandler.handler = swtmr->pfnHandler;
+    swtmrHandler.arg = swtmr->uwArg;
 
-        swtmr = g_swtmrSortList;
+    (VOID)LOS_QueueWriteCopy(g_swtmrHandlerQueue, &swtmrHandler, sizeof(SwtmrHandlerItem), LOS_NO_WAIT);
+    if (swtmr->ucMode == LOS_SWTMR_MODE_ONCE) {
+        OsSwtmrDelete(swtmr);
+        if (swtmr->usTimerID < (OS_SWTMR_MAX_TIMERID - LOSCFG_BASE_CORE_SWTMR_LIMIT)) {
+            swtmr->usTimerID += LOSCFG_BASE_CORE_SWTMR_LIMIT;
+        } else {
+            swtmr->usTimerID %= LOSCFG_BASE_CORE_SWTMR_LIMIT;
+        }
+    } else if (swtmr->ucMode == LOS_SWTMR_MODE_PERIOD) {
+        OsSwtmrStart(swtmr);
+    } else if (swtmr->ucMode == LOS_SWTMR_MODE_NO_SELFDELETE) {
+        swtmr->ucState = OS_SWTMR_STATUS_CREATED;
     }
 }
 
-/*****************************************************************************
-Function    : OsSwtmrScan
-Description : Tick interrupt interface module of Software Timer
-Input       : None
-Output      : None
-Return      : LOS_OK on success
-*****************************************************************************/
-LITE_OS_SEC_TEXT UINT32 OsSwtmrScan(VOID)
+STATIC BOOL OsSwtmrScan(VOID)
 {
-    UINTPTR intSave = LOS_IntLock();
-    if (g_swtmrSortList != NULL) {
-        if (--(g_swtmrSortList->uwCount) == 0) {
-            OsSwtmrTimeoutHandle();
+    BOOL needSchedule = FALSE;
+    LOS_DL_LIST *listObject = &g_swtmrSortLinkList->sortLink;
+
+    if (LOS_ListEmpty(listObject)) {
+        return needSchedule;
+    }
+
+    SortLinkList *sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
+    UINT64 currTime = OsGetCurrSchedTimeCycle();
+    while (sortList->responseTime <= currTime) {
+        OsDeleteNodeSortLink(g_swtmrSortLinkList, sortList);
+
+        SWTMR_CTRL_S *swtmr = LOS_DL_LIST_ENTRY(sortList, SWTMR_CTRL_S, stSortList);
+        OsSwtmrTimeoutHandle(swtmr);
+
+        needSchedule = TRUE;
+        if (LOS_ListEmpty(listObject)) {
+            break;
         }
+
+        sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
     }
-    LOS_IntRestore(intSave);
-    return LOS_OK;
+
+    return needSchedule;
 }
 
 /*****************************************************************************
@@ -416,174 +311,88 @@ Input       : None
 Output      : None
 Return      : Count of the Timer list
 *****************************************************************************/
-#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
-LITE_OS_SEC_TEXT UINT32 OsSwtmrGetNextTimeout(VOID)
-{
-    SWTMR_CTRL_S *cur = NULL;
-    UINT32 tmpTime = 0;
-    UINT32 sleepTime = OS_NULL_INT;
-    UINTPTR intSave = LOS_IntLock();
-    cur = g_swtmrSortList;
-
-    // find first timer can wakeup the system
-    while (cur != NULL) {
-        if (cur->ucRouses == OS_SWTMR_ROUSES_ALLOW) {
-            g_swtmrRouses = cur;
-            break;
-        }
-
-        tmpTime += cur->uwCount;
-        g_swtmrRousesPrev = cur;
-        cur = cur->pstNext;
-    }
-
-    if (cur != NULL) {
-        sleepTime = cur->uwCount + tmpTime;
-        g_swtimerRousesTime  = sleepTime;
-    }
-    LOS_IntRestore(intSave);
-    return sleepTime;
-}
-#else
 LITE_OS_SEC_TEXT UINT32 OsSwtmrGetNextTimeout(VOID)
 {
-    UINTPTR intSave = LOS_IntLock();
-    if (g_swtmrSortList == NULL) {
-        LOS_IntRestore(intSave);
-        return OS_NULL_INT;
-    }
-    UINT32 tmp = g_swtmrSortList->uwCount;
+    UINT32 intSave = LOS_IntLock();
+    UINT32 ticks = OsSortLinkGetNextExpireTime(g_swtmrSortLinkList);
     LOS_IntRestore(intSave);
-    return tmp;
+    return ticks;
 }
-#endif
 
-/*****************************************************************************
-Function    : OsSwtimerInsert
-Description : Insert a list of swtmr
-Input       : **head, *swtmr
-Output      : **head, *swtmr
-Return      : None
-*****************************************************************************/
-#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
-VOID OsSwtimerInsert(SWTMR_CTRL_S **head, SWTMR_CTRL_S *swtmr)
+LITE_OS_SEC_TEXT UINT32 OsSwtmrTimeGet(const SWTMR_CTRL_S *swtmr)
 {
-    SWTMR_CTRL_S *prev = NULL;
-    SWTMR_CTRL_S *nextTmp = swtmr->pstNext;
-    SWTMR_CTRL_S *cur = *head;
-
-    while (swtmr != NULL) {
-        while (cur != NULL) {
-            if (cur->uwCount > swtmr->uwCount) {
-                break;
-            }
-
-            swtmr->uwCount -= cur->uwCount;
-            prev = cur;
-            cur = cur->pstNext;
-        }
-        swtmr->pstNext = cur;
-
-        if (cur != NULL) {
-            cur->uwCount -= swtmr->uwCount;
-        }
-        if (prev == NULL) {
-            *head = swtmr;
-        } else {
-            prev->pstNext = swtmr;
-        }
-
-        prev = swtmr;
-        swtmr = nextTmp;
-        nextTmp = nextTmp->pstNext;
-    }
-
-    return;
+    return OsSortLinkGetTargetExpireTime(OsGetCurrSchedTimeCycle(), &swtmr->stSortList);
 }
-#endif
+
 /*****************************************************************************
-Function    : OsSwtmrAdjust
-Description : Adjust Software Timer list
-Input       : sleepTime
+Function    : OsSwtmrInit
+Description : Initializes Software Timer
+Input       : None
 Output      : None
-Return      : None
+Return      : LOS_OK on success or error code on failure
 *****************************************************************************/
-#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
-LITE_OS_SEC_TEXT VOID OsSwtmrAdjust(UINT32 sleepTime)
+LITE_OS_SEC_TEXT_INIT UINT32 OsSwtmrInit(VOID)
 {
-    SWTMR_CTRL_S  *cur = NULL;
-    UINTPTR intSave = LOS_IntLock();
-    if (g_swtmrRouses == NULL) {
-        LOS_IntRestore(intSave);
-        return;
-    }
-
-    if (sleepTime > g_swtimerRousesTime) {
-        sleepTime = g_swtimerRousesTime;
-    }
+    UINT32 size;
+    UINT16 index;
+    UINT32 ret;
 
-    if (sleepTime <= g_swtmrRouses->uwCount) {
-        g_swtmrRouses->uwCount -= sleepTime;
-    } else {
-        g_swtmrRouses->uwCount = g_swtimerRousesTime - sleepTime;
+#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
+    // Ignore the return code when matching CSEC rule 6.6(1).
+    (VOID)memset_s((VOID *)g_swtmrAlignID, sizeof(SwtmrAlignData) * LOSCFG_BASE_CORE_SWTMR_LIMIT,
+                   0, sizeof(SwtmrAlignData) * LOSCFG_BASE_CORE_SWTMR_LIMIT);
+#endif
 
-        if (g_swtmrRousesPrev != NULL) {
-            g_swtmrRousesPrev->pstNext = NULL;
-            cur = g_swtmrSortList;
-            OsSwtimerInsert(&g_swtmrRouses, cur);
-            g_swtmrSortList = g_swtmrRouses;
-        }
+    size = sizeof(SWTMR_CTRL_S) * LOSCFG_BASE_CORE_SWTMR_LIMIT;
+    SWTMR_CTRL_S *swtmr = (SWTMR_CTRL_S *)LOS_MemAlloc(m_aucSysMem0, size);
+    if (swtmr == NULL) {
+        return LOS_ERRNO_SWTMR_NO_MEMORY;
     }
-    if (g_swtmrSortList->uwCount == 0) {
-        OsSwtmrTimeoutHandle();
+    // Ignore the return code when matching CSEC rule 6.6(3).
+    (VOID)memset_s((VOID *)swtmr, size, 0, size);
+    g_swtmrCBArray = swtmr;
+    g_swtmrFreeList = swtmr;
+    swtmr->usTimerID = 0;
+    SWTMR_CTRL_S *temp = swtmr;
+    swtmr++;
+    for (index = 1; index < LOSCFG_BASE_CORE_SWTMR_LIMIT; index++, swtmr++) {
+        swtmr->usTimerID = index;
+        temp->pstNext = swtmr;
+        temp = swtmr;
     }
 
-    g_swtmrRouses = NULL;
-    g_swtmrRousesPrev = NULL;
-    LOS_IntRestore(intSave);
-}
-#else
-LITE_OS_SEC_TEXT VOID OsSwtmrAdjust(UINT32 sleepTime)
-{
-    UINT32 tmpSleepTime = sleepTime;
-    UINTPTR intSave = LOS_IntLock();
-    if (g_swtmrSortList == NULL) {
-        LOS_IntRestore(intSave);
-        return;
+    ret = LOS_QueueCreate((CHAR *)NULL, OS_SWTMR_HANDLE_QUEUE_SIZE,
+                          &g_swtmrHandlerQueue, 0, sizeof(SwtmrHandlerItem));
+    if (ret != LOS_OK) {
+        (VOID)LOS_MemFree(m_aucSysMem0, swtmr);
+        return LOS_ERRNO_SWTMR_QUEUE_CREATE_FAILED;
     }
 
-    if (tmpSleepTime > g_swtmrSortList->uwCount) {
-        tmpSleepTime = g_swtmrSortList->uwCount;
+    ret = OsSwtmrTaskCreate();
+    if (ret != LOS_OK) {
+        (VOID)LOS_MemFree(m_aucSysMem0, swtmr);
+        return LOS_ERRNO_SWTMR_TASK_CREATE_FAILED;
     }
 
-    g_swtmrSortList->uwCount -= tmpSleepTime;
-
-    if (g_swtmrSortList->uwCount == 0) {
-        OsSwtmrTimeoutHandle();
+    g_swtmrSortLinkList = OsGetSortLinkAttribute(OS_SORT_LINK_SWTMR);
+    if (g_swtmrSortLinkList == NULL) {
+        (VOID)LOS_MemFree(m_aucSysMem0, swtmr);
+        return LOS_NOK;
     }
-    LOS_IntRestore(intSave);
-}
-#endif
-
-LITE_OS_SEC_TEXT UINT32 OsSwtmrTimeGet(const SWTMR_CTRL_S *swtmr)
-{
-    SWTMR_CTRL_S *cur = (SWTMR_CTRL_S *)NULL;
-    UINT32 tick = 0;
 
-    cur = g_swtmrSortList;
-    while (1) {
-        if (cur == NULL) {
-            break;
-        }
-        tick += cur->uwCount;
-        if (cur == swtmr) {
-            break;
-        }
+    ret = OsSortLinkInit(g_swtmrSortLinkList);
+    if (ret != LOS_OK) {
+        (VOID)LOS_MemFree(m_aucSysMem0, swtmr);
+        return LOS_NOK;
+    }
 
-        cur = cur->pstNext;
+    ret = OsSchedSwtmrScanRegister((SchedScan)OsSwtmrScan);
+    if (ret != LOS_OK) {
+        (VOID)LOS_MemFree(m_aucSysMem0, swtmr);
+        return LOS_NOK;
     }
 
-    return tick;
+    return LOS_OK;
 }
 
 /*****************************************************************************
@@ -613,7 +422,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_SwtmrCreate(UINT32 interval,
 #endif
 {
     SWTMR_CTRL_S  *swtmr = NULL;
-    UINTPTR  intSave;
+    UINT32 intSave = 0;
 
     if (interval == 0) {
         return LOS_ERRNO_SWTMR_INTERVAL_NOT_SUITED;
@@ -664,6 +473,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_SwtmrCreate(UINT32 interval,
 #endif
     swtmr->ucState       = OS_SWTMR_STATUS_CREATED;
     *swtmrId = swtmr->usTimerID;
+    SET_SORTLIST_VALUE(&swtmr->stSortList, OS_SORT_LINK_INVALID_TIME);
 
     return LOS_OK;
 }
@@ -677,21 +487,15 @@ Return      : LOS_OK on success or error code on failure
 *****************************************************************************/
 LITE_OS_SEC_TEXT UINT32 LOS_SwtmrStart(UINT32 swtmrId)
 {
-    SWTMR_CTRL_S *swtmr = NULL;
-    UINTPTR intSave;
-#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
-    UINT32 times;
-    UINT32 swtmrAlignIdIndex = 0;
-#endif
+    UINT32 intSave = 0;
     UINT32 ret = LOS_OK;
-    UINT16 swtmrCbId;
 
     if (swtmrId >= OS_SWTMR_MAX_TIMERID) {
         return LOS_ERRNO_SWTMR_ID_INVALID;
     }
+
     intSave = LOS_IntLock();
-    swtmrCbId = swtmrId % LOSCFG_BASE_CORE_SWTMR_LIMIT;
-    swtmr = g_swtmrCBArray + swtmrCbId;
+    SWTMR_CTRL_S *swtmr = g_swtmrCBArray + swtmrId % LOSCFG_BASE_CORE_SWTMR_LIMIT;
     if (swtmr->usTimerID != swtmrId) {
         LOS_IntRestore(intSave);
         return LOS_ERRNO_SWTMR_ID_INVALID;
@@ -699,12 +503,11 @@ LITE_OS_SEC_TEXT UINT32 LOS_SwtmrStart(UINT32 swtmrId)
 
 #if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
     if ((swtmr->ucSensitive == OS_SWTMR_ALIGN_INSENSITIVE) && (swtmr->ucMode == LOS_SWTMR_MODE_PERIOD)) {
-        swtmrAlignIdIndex = swtmr->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT;
+        UINT32 swtmrAlignIdIndex = swtmr->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT;
         g_swtmrAlignID[swtmrAlignIdIndex].canAlign = 1;
         if ((swtmr->uwInterval % LOS_COMMON_DIVISOR) == 0) {
             g_swtmrAlignID[swtmrAlignIdIndex].canMultiple = 1;
-            times = swtmr->uwInterval / (LOS_COMMON_DIVISOR);
-            g_swtmrAlignID[swtmrAlignIdIndex].times = times;
+            g_swtmrAlignID[swtmrAlignIdIndex].times = swtmr->uwInterval / LOS_COMMON_DIVISOR;
         }
     }
 #endif
@@ -738,7 +541,7 @@ Return      : LOS_OK on success or error code on failure
 LITE_OS_SEC_TEXT UINT32 LOS_SwtmrStop(UINT32 swtmrId)
 {
     SWTMR_CTRL_S *swtmr = NULL;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     UINT16 swtmrCbId;
     UINT32 ret = LOS_OK;
 
@@ -775,7 +578,7 @@ LITE_OS_SEC_TEXT UINT32 LOS_SwtmrStop(UINT32 swtmrId)
 LITE_OS_SEC_TEXT UINT32 LOS_SwtmrTimeGet(UINT32 swtmrId, UINT32 *tick)
 {
     SWTMR_CTRL_S *swtmr = NULL;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     UINT32 ret = LOS_OK;
     UINT16 swtmrCbId;
 
@@ -823,7 +626,7 @@ Return      : LOS_OK on success or error code on failure
 LITE_OS_SEC_TEXT UINT32 LOS_SwtmrDelete(UINT32 swtmrId)
 {
     SWTMR_CTRL_S *swtmr = NULL;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     UINT32 ret = LOS_OK;
     UINT16 swtmrCbId;
 
@@ -860,8 +663,3 @@ LITE_OS_SEC_TEXT UINT32 LOS_SwtmrDelete(UINT32 swtmrId)
 #endif /* (LOSCFG_BASE_CORE_SWTMR == 1) */
 
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif
-#endif
diff --git a/kernel/liteos_m/kernel/src/los_task.c b/kernel/liteos_m/kernel/src/los_task.c
old mode 100755
new mode 100644
index 619c17d..1832881
--- a/kernel/liteos_m/kernel/src/los_task.c
+++ b/kernel/liteos_m/kernel/src/los_task.c
@@ -28,27 +28,27 @@
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-#include "los_config.h"
+
+#include "los_task.h"
 #include "securec.h"
+#include "los_config.h"
+#include "los_debug.h"
+#include "los_hook.h"
+#include "los_interrupt.h"
 #include "los_memory.h"
+#include "los_mpu.h"
+#include "los_sched.h"
 #include "los_mux.h"
 #include "los_sem.h"
 #include "los_timer.h"
-#include "los_interrupt.h"
 #if (LOSCFG_BASE_CORE_CPUP == 1)
 #include "los_cpup.h"
 #endif
-#include "los_debug.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
 /**
  * @ingroup los_task
- * @brief Convinence macro for bitwise operation of task module
+ * @brief Convenience macro for bitwise operation of task module
  */
 #define EVALUATE_L(NUMBER, VALUE)  \
             ((NUMBER) = (((NUMBER) & OS_TSK_HIGH_BITS_MASK) | (VALUE)))
@@ -70,21 +70,19 @@ extern "C" {
             ((NUMBER) = ((NUMBER) - 1))
 
 
-#define OS_CHECK_TASK_BLOCK                     (OS_TASK_STATUS_DELAY | \
-                                                 OS_TASK_STATUS_PEND | \
-                                                 OS_TASK_STATUS_SUSPEND | \
-                                                 OS_TASK_STATUS_EVENT | \
-                                                 OS_TASK_STATUS_PEND_QUEUE)
+#define OS_CHECK_TASK_BLOCK                     (OS_TASK_STATUS_DELAY |  \
+                                                 OS_TASK_STATUS_PEND |   \
+                                                 OS_TASK_STATUS_SUSPEND)
 
 /**
  * @ingroup los_task
- * @brief check taks id's validation
+ * @brief check task id's validation
  */
 #define OS_TASK_ID_CHECK(taskID)              LOS_ASSERT_COND(OS_TSK_GET_INDEX(taskID) < g_taskMaxNum)
 
 /**
  * @ingroup los_task
- * @brief check taks id's invalidation
+ * @brief check task id's invalidation
  */
 #define OS_CHECK_TSK_PID_NOIDLE(taskID)       (OS_TSK_GET_INDEX(taskID) >= g_taskMaxNum)
 
@@ -94,12 +92,6 @@ extern "C" {
  */
 #define OS_TASK_STACK_TOP_OFFSET                4
 
-LITE_OS_SEC_BSS LOS_DL_LIST *g_losPriorityQueueList = NULL;
-static LITE_OS_SEC_BSS UINT32 g_priqueueBitmap = 0;
-
-#define PRIQUEUE_PRIOR0_BIT           (UINT32)0x80000000
-#define OS_PRIORITY_QUEUE_PRIORITYNUM 32
-
 LITE_OS_SEC_BSS  LosTaskCB                           *g_taskCBArray = NULL;
 LITE_OS_SEC_BSS  LosTask                             g_losTask;
 LITE_OS_SEC_BSS  UINT16                              g_losTaskLock;
@@ -108,7 +100,6 @@ LITE_OS_SEC_BSS  UINT32                              g_idleTaskID;
 LITE_OS_SEC_BSS  UINT32                              g_swtmrTaskID;
 LITE_OS_SEC_DATA_INIT LOS_DL_LIST                    g_losFreeTask;
 LITE_OS_SEC_DATA_INIT LOS_DL_LIST                    g_taskRecyleList;
-LITE_OS_SEC_BSS  TaskSortLinkAttr                    g_taskSortLink;
 LITE_OS_SEC_BSS  BOOL                                g_taskScheduled = FALSE;
 
 #if (LOSCFG_BASE_CORE_TSK_MONITOR == 1)
@@ -119,66 +110,6 @@ TSKSWITCHHOOK g_pfnUsrTskSwitchHook = NULL;
 TaskSwitchInfo g_taskSwitchInfo;
 #endif
 
-STATIC UINT32 OsPriqueueInit(VOID)
-{
-    UINT32 priority;
-    UINT32 size = OS_PRIORITY_QUEUE_PRIORITYNUM * sizeof(LOS_DL_LIST);
-
-    g_losPriorityQueueList = (LOS_DL_LIST *)LOS_MemAlloc(m_aucSysMem0, size);
-    if (g_losPriorityQueueList == NULL) {
-        return LOS_NOK;
-    }
-
-    for (priority = 0; priority < OS_PRIORITY_QUEUE_PRIORITYNUM; ++priority) {
-        LOS_ListInit(&g_losPriorityQueueList[priority]);
-    }
-    return LOS_OK;
-}
-
-STATIC VOID OsPriqueueEnqueue(LOS_DL_LIST *priqueueItem, UINT32 priority)
-{
-    if (LOS_ListEmpty(&g_losPriorityQueueList[priority])) {
-        g_priqueueBitmap |= (PRIQUEUE_PRIOR0_BIT >> priority);
-    }
-
-    LOS_ListTailInsert(&g_losPriorityQueueList[priority], priqueueItem);
-}
-
-STATIC VOID OsPriqueueDequeue(LOS_DL_LIST *priqueueItem)
-{
-    LosTaskCB *runningTask = NULL;
-    LOS_ListDelete(priqueueItem);
-
-    runningTask = LOS_DL_LIST_ENTRY(priqueueItem, LosTaskCB, pendList);
-    if (LOS_ListEmpty(&g_losPriorityQueueList[runningTask->priority])) {
-        g_priqueueBitmap &= ~(PRIQUEUE_PRIOR0_BIT >> runningTask->priority);
-    }
-}
-
-STATIC LOS_DL_LIST *OsPriqueueTop(VOID)
-{
-    UINT32 priority;
-
-    if (g_priqueueBitmap != 0) {
-        priority = CLZ(g_priqueueBitmap);
-        return LOS_DL_LIST_FIRST(&g_losPriorityQueueList[priority]);
-    }
-
-    return (LOS_DL_LIST *)NULL;
-}
-
-STATIC UINT32 OsPriqueueSize(UINT32 priority)
-{
-    UINT32 itemCnt = 0;
-    LOS_DL_LIST *curPQNode = (LOS_DL_LIST *)NULL;
-
-    LOS_DL_LIST_FOR_EACH(curPQNode, &g_losPriorityQueueList[priority]) {
-        ++itemCnt;
-    }
-
-    return itemCnt;
-}
-
 STATIC_INLINE UINT32 OsCheckTaskIDValid(UINT32 taskID)
 {
     UINT32 ret = LOS_OK;
@@ -195,41 +126,25 @@ STATIC_INLINE UINT32 OsCheckTaskIDValid(UINT32 taskID)
 STATIC VOID OsRecyleFinishedTask(VOID)
 {
     LosTaskCB *taskCB = NULL;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
+    UINTPTR stackPtr;
 
     intSave = LOS_IntLock();
     while (!LOS_ListEmpty(&g_taskRecyleList)) {
         taskCB = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&g_taskRecyleList));
         LOS_ListDelete(LOS_DL_LIST_FIRST(&g_taskRecyleList));
         LOS_ListAdd(&g_losFreeTask, &taskCB->pendList);
-        (VOID)LOS_MemFree(OS_TASK_STACK_ADDR, (VOID *)(UINTPTR)taskCB->topOfStack);
+#if (LOSCFG_EXC_HRADWARE_STACK_PROTECTION == 1)
+        stackPtr = taskCB->topOfStack - OS_TASK_STACK_PROTECT_SIZE;
+#else
+        stackPtr = taskCB->topOfStack;
+#endif
+        (VOID)LOS_MemFree(OS_TASK_STACK_ADDR, (VOID *)stackPtr);
         taskCB->topOfStack = (UINT32)NULL;
     }
     LOS_IntRestore(intSave);
 }
 
-UINT32 OsTaskNextSwitchTimeGet(VOID)
-{
-    LosTaskCB *taskCB = NULL;
-    UINT32 taskSortLinkTick = LOS_WAIT_FOREVER;
-    LOS_DL_LIST *listObject = NULL;
-    UINT32 tempTicks;
-    UINT32 index;
-
-    for (index = 0; index < OS_TSK_SORTLINK_LEN; index++) {
-        listObject = g_taskSortLink.sortLink + ((g_taskSortLink.cursor + index) % OS_TSK_SORTLINK_LEN);
-        if (!LOS_ListEmpty(listObject)) {
-            taskCB = LOS_DL_LIST_ENTRY((listObject)->pstNext, LosTaskCB, timerList);
-            tempTicks = (index == 0) ? OS_TSK_SORTLINK_LEN : index;
-            tempTicks += (UINT32)(UWROLLNUM((UINT32)taskCB->idxRollNum) * OS_TSK_SORTLINK_LEN);
-            if (taskSortLinkTick > tempTicks) {
-                taskSortLinkTick = tempTicks;
-            }
-        }
-    }
-    return taskSortLinkTick;
-}
-
 /*****************************************************************************
  Function    : OsIdleTask
  Description : Idle task.
@@ -241,152 +156,11 @@ LITE_OS_SEC_TEXT WEAK VOID OsIdleTask(VOID)
 {
     while (1) {
         OsRecyleFinishedTask();
-#if (LOSCFG_KERNEL_RUNSTOP == 1)
-        HalEnterSleep(OS_SYS_NORMAL_SLEEP);
-#endif
-    }
-}
-
-/*****************************************************************************
- Function    : OsTaskPriModify
- Description : Change task priority.
- Input       : taskCB    --- task control block
-               priority  --- priority
- Output      : None
- Return      : None
- *****************************************************************************/
-LITE_OS_SEC_TEXT_MINOR VOID OsTaskPriModify(LosTaskCB *taskCB, UINT16 priority)
-{
-    if (taskCB->taskStatus & OS_TASK_STATUS_READY) {
-        OsPriqueueDequeue(&taskCB->pendList);
-        taskCB->taskStatus &= (~OS_TASK_STATUS_READY);
-        taskCB->priority = priority;
-        taskCB->taskStatus |= OS_TASK_STATUS_READY;
-        OsPriqueueEnqueue(&taskCB->pendList, taskCB->priority);
-    } else {
-        taskCB->priority = priority;
-    }
-}
-
-/*****************************************************************************
- Function    : OsTaskAdd2TimerList
- Description : Add task to sorted delay list.
- Input       : taskCB    --- task control block
-               timeout   --- wait time, ticks
- Output      : None
- Return      : None
- *****************************************************************************/
-LITE_OS_SEC_TEXT VOID OsTaskAdd2TimerList(LosTaskCB *taskCB, UINT32 timeout)
-{
-    LosTaskCB *taskDelay = NULL;
-    LOS_DL_LIST *listObject = NULL;
-    UINT32 sortIndex;
-    UINT32 rollNum;
-
-    sortIndex = timeout & OS_TSK_SORTLINK_MASK;
-    rollNum = (timeout >> OS_TSK_SORTLINK_LOGLEN);
-    (sortIndex > 0) ? 0 : (rollNum--);
-    EVALUATE_L(taskCB->idxRollNum, rollNum);
-    sortIndex = (sortIndex + g_taskSortLink.cursor);
-    sortIndex = sortIndex & OS_TSK_SORTLINK_MASK;
-    EVALUATE_H(taskCB->idxRollNum, sortIndex);
-    listObject = g_taskSortLink.sortLink + sortIndex;
-    if (listObject->pstNext == listObject) {
-        LOS_ListTailInsert(listObject, &taskCB->timerList);
-    } else {
-        taskDelay = LOS_DL_LIST_ENTRY((listObject)->pstNext, LosTaskCB, timerList);
-        do {
-            if (UWROLLNUM(taskDelay->idxRollNum) <= UWROLLNUM(taskCB->idxRollNum)) {
-                UWROLLNUMSUB(taskCB->idxRollNum, taskDelay->idxRollNum);
-            } else {
-                UWROLLNUMSUB(taskDelay->idxRollNum, taskCB->idxRollNum);
-                break;
-            }
-
-            taskDelay = LOS_DL_LIST_ENTRY(taskDelay->timerList.pstNext, LosTaskCB, timerList);
-        } while (&taskDelay->timerList != (listObject));
-
-        LOS_ListTailInsert(&taskDelay->timerList, &taskCB->timerList);
-    }
-}
-
-
-LITE_OS_SEC_TEXT VOID OsTimerListDelete(LosTaskCB *taskCB)
-{
-    LOS_DL_LIST  *listObject = NULL;
-    LosTaskCB  *nextTask = NULL;
-    UINT32 sortIndex;
-
-    sortIndex = UWSORTINDEX(taskCB->idxRollNum);
-    listObject = g_taskSortLink.sortLink + sortIndex;
-
-    if (listObject != taskCB->timerList.pstNext) {
-        nextTask = LOS_DL_LIST_ENTRY(taskCB->timerList.pstNext, LosTaskCB, timerList);
-        UWROLLNUMADD(nextTask->idxRollNum, taskCB->idxRollNum);
-    }
-
-    LOS_ListDelete(&taskCB->timerList);
-}
-
-LITE_OS_SEC_TEXT VOID OsTaskScan(VOID)
-{
-    LosTaskCB *taskCB = NULL;
-    BOOL needSchedule = FALSE;
-    LOS_DL_LIST *listObject = NULL;
-    UINT16 tempStatus;
-    UINTPTR intSave;
-    intSave = LOS_IntLock();
-
-    g_taskSortLink.cursor = (g_taskSortLink.cursor + 1) % OS_TSK_SORTLINK_LEN;
-    listObject = g_taskSortLink.sortLink + g_taskSortLink.cursor;
-    if (listObject->pstNext == listObject) {
-        LOS_IntRestore(intSave);
-        return;
-    }
-
-    for (taskCB = LOS_DL_LIST_ENTRY((listObject)->pstNext, LosTaskCB, timerList);
-         &taskCB->timerList != (listObject);) {
-        tempStatus = taskCB->taskStatus;
-        if (UWROLLNUM(taskCB->idxRollNum) > 0) {
-            UWROLLNUMDEC(taskCB->idxRollNum);
-            break;
-        }
-
-        LOS_ListDelete(&taskCB->timerList);
-        if (tempStatus & OS_TASK_STATUS_PEND) {
-            taskCB->taskStatus &= ~(OS_TASK_STATUS_PEND);
-            LOS_ListDelete(&taskCB->pendList);
-            taskCB->taskSem = NULL;
-            taskCB->taskMux = NULL;
-        }
-        else if (tempStatus & OS_TASK_STATUS_EVENT) {
-            taskCB->taskStatus &= ~(OS_TASK_STATUS_EVENT);
-        }
-        else if (tempStatus & OS_TASK_STATUS_PEND_QUEUE) {
-            LOS_ListDelete(&taskCB->pendList);
-            taskCB->taskStatus &= ~(OS_TASK_STATUS_PEND_QUEUE);
-        } else {
-            taskCB->taskStatus &= ~(OS_TASK_STATUS_DELAY);
-        }
-
-        if (!(tempStatus & OS_TASK_STATUS_SUSPEND)) {
-            taskCB->taskStatus |= OS_TASK_STATUS_READY;
-            OsPriqueueEnqueue(&taskCB->pendList, taskCB->priority);
-            needSchedule = TRUE;
-        }
-
-        if (listObject->pstNext == listObject) {
-            break;
-        }
-
-        taskCB = LOS_DL_LIST_ENTRY(listObject->pstNext, LosTaskCB, timerList);
-    }
-
-    LOS_IntRestore(intSave);
-
-    if (needSchedule) {
-        LOS_Schedule();
-    }
+		
+		#if (0 == CFG_JTAG_ENABLE)
+        HalEnterSleep(OS_SYS_DEEP_SLEEP);
+		#endif
+	}
 }
 
 /*****************************************************************************
@@ -405,19 +179,12 @@ LITE_OS_SEC_TEXT_MINOR UINT8 *OsConvertTskStatus(UINT16 taskStatus)
     } else if (taskStatus & OS_TASK_STATUS_DELAY) {
         return (UINT8 *)"Delay";
     } else if (taskStatus & OS_TASK_STATUS_PEND) {
-        if (taskStatus & OS_TASK_STATUS_TIMEOUT) {
-            return (UINT8 *)"PendTimeOut";
+        if (taskStatus & OS_TASK_STATUS_PEND_TIME) {
+            return (UINT8 *)"PendTime";
         }
-
         return (UINT8 *)"Pend";
     } else if (taskStatus & OS_TASK_STATUS_SUSPEND) {
         return (UINT8 *)"Suspend";
-    } else if (taskStatus & OS_TASK_STATUS_PEND_QUEUE) {
-        if (taskStatus & OS_TASK_STATUS_TIMEOUT) {
-            return (UINT8 *)"QueuePendTimeOut";
-        }
-
-        return (UINT8 *)"QueuePend";
     }
 
     return (UINT8 *)"Impossible";
@@ -534,10 +301,6 @@ LITE_OS_SEC_TEXT_MINOR UINT32 OsGetAllTskInfo(VOID)
 
     OsPrintAllTskInfoHeader();
 
-#if (LOSCFG_EXC_HRADWARE_STACK_PROTECTION == 1)
-    UINT32 flag = osStackProtDisable();
-#endif
-
     for (loopNum = 0; loopNum < g_taskMaxNum; loopNum++) {
         taskCB = (((LosTaskCB *)g_taskCBArray) + loopNum);
         if (taskCB->taskStatus & OS_TASK_STATUS_UNUSED) {
@@ -545,9 +308,9 @@ LITE_OS_SEC_TEXT_MINOR UINT32 OsGetAllTskInfo(VOID)
         }
 
         PRINTK("%d    %d    %s    0x%x    0x%x    0x%x    0x%x    0x%x    ",
-                  taskCB->taskID, taskCB->priority, OsConvertTskStatus(taskCB->taskStatus),
-                  taskCB->stackSize, OsGetTaskWaterLine(taskCB->taskID),
-                  (UINT32)(UINTPTR)taskCB->stackPointer, taskCB->topOfStack, taskCB->eventMask);
+               taskCB->taskID, taskCB->priority, OsConvertTskStatus(taskCB->taskStatus),
+               taskCB->stackSize, OsGetTaskWaterLine(taskCB->taskID),
+               (UINT32)(UINTPTR)taskCB->stackPointer, taskCB->topOfStack, taskCB->eventMask);
 
         semID = (taskCB->taskSem == NULL) ? OS_NULL_SHORT : (((LosSemCB *)taskCB->taskSem)->semID);
         PRINTK("0x%x    ", semID);
@@ -564,10 +327,6 @@ LITE_OS_SEC_TEXT_MINOR UINT32 OsGetAllTskInfo(VOID)
         PRINTK("%s\n", taskCB->taskName);
     }
 
-#if (LOSCFG_EXC_HRADWARE_STACK_PROTECTION == 1)
-    osStackProtRestore(flag);
-#endif
-
 #if (LOSCFG_BASE_CORE_CPUP == 1)
     (VOID)LOS_MemFree((VOID *)OS_SYS_MEM_ADDR, cpuLessOneSec);
     (VOID)LOS_MemFree((VOID *)OS_SYS_MEM_ADDR, cpuTenSec);
@@ -588,8 +347,6 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsTaskInit(VOID)
 {
     UINT32 size;
     UINT32 index;
-    LOS_DL_LIST *listObject = NULL;
-    UINT32 queueResult;
 
     size = (g_taskMaxNum + 1) * sizeof(LosTaskCB);
     g_taskCBArray = (LosTaskCB *)LOS_MemAlloc(m_aucSysMem0, size);
@@ -613,28 +370,9 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsTaskInit(VOID)
     g_losTask.runTask->taskID = index;
     g_losTask.runTask->taskStatus = (OS_TASK_STATUS_UNUSED | OS_TASK_STATUS_RUNNING);
     g_losTask.runTask->priority = OS_TASK_PRIORITY_LOWEST + 1;
-    queueResult = OsPriqueueInit();
-    if (queueResult == LOS_NOK) {
-        (VOID)LOS_MemFree(m_aucSysMem0, g_taskCBArray);
-        return LOS_ERRNO_TSK_NO_MEMORY;
-    }
-
-    size = sizeof(LOS_DL_LIST) * OS_TSK_SORTLINK_LEN;
-    listObject = (LOS_DL_LIST *)LOS_MemAlloc(m_aucSysMem0, size);
-    if (listObject == NULL) {
-        (VOID)LOS_MemFree(m_aucSysMem0, g_taskCBArray);
-        return LOS_ERRNO_TSK_NO_MEMORY;
-    }
-
-    // Ignore the return code when matching CSEC rule 6.6(3).
-    (VOID)memset_s((VOID *)listObject, size, 0, size);
-    g_taskSortLink.sortLink = listObject;
-    g_taskSortLink.cursor = 0;
-    for (index = 0; index < OS_TSK_SORTLINK_LEN; index++, listObject++) {
-        LOS_ListInit(listObject);
-    }
 
-    return LOS_OK;
+    g_idleTaskID = OS_INVALID;
+    return OsSchedInit();
 }
 
 
@@ -655,12 +393,13 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsIdleTaskCreate(VOID)
     taskInitParam.uwStackSize = LOSCFG_BASE_CORE_TSK_IDLE_STACK_SIZE;
     taskInitParam.pcName = "IdleCore000";
     taskInitParam.usTaskPrio = OS_TASK_PRIORITY_LOWEST;
-    retVal = LOS_TaskCreate(&g_idleTaskID, &taskInitParam);
+    retVal = LOS_TaskCreateOnly(&g_idleTaskID, &taskInitParam);
 
     if (retVal != LOS_OK) {
         return retVal;
     }
 
+    OsSchedSetIdleTaskSchedParam(OS_TCB_FROM_TID(g_idleTaskID));
     return LOS_OK;
 }
 
@@ -688,10 +427,11 @@ LITE_OS_SEC_TEXT UINT32 LOS_CurTaskIDGet(VOID)
  *****************************************************************************/
 LITE_OS_SEC_TEXT UINT32 LOS_NextTaskIDGet(VOID)
 {
-    if (g_losTask.newTask == NULL) {
-        return LOS_ERRNO_TSK_ID_INVALID;
-    }
-    return g_losTask.newTask->taskID;
+    UINT32 intSave = LOS_IntLock();
+    UINT32 taskID = OsGetTopTask()->taskID;
+    LOS_IntRestore(intSave);
+
+    return taskID;
 }
 
 /*****************************************************************************
@@ -753,6 +493,32 @@ LITE_OS_SEC_TEXT STATIC VOID OsHandleNewTaskStackOverflow(VOID)
     OsDoExcHook(EXC_STACKOVERFLOW);
     g_losTask.runTask = tmp;
 }
+#else
+LITE_OS_SEC_TEXT STATIC VOID OsTaskStackProtect(VOID)
+{
+    MPU_CFG_PARA mpuAttr = {0};
+    STATIC INT32 id = -1;
+
+    if (id == -1) {
+        id = HalMpuUnusedRegionGet();
+        if (id < 0) {
+            PRINT_ERR("%s %d, get unused id failed!\n", __FUNCTION__, __LINE__);
+            return;
+        }
+    }
+
+    mpuAttr.baseAddr = g_losTask.newTask->topOfStack - OS_TASK_STACK_PROTECT_SIZE;
+    mpuAttr.size = OS_TASK_STACK_PROTECT_SIZE;
+    mpuAttr.memType = MPU_MEM_ON_CHIP_RAM;
+    mpuAttr.executable = MPU_NON_EXECUTABLE;
+    mpuAttr.shareability = MPU_NO_SHARE;
+    mpuAttr.permission = MPU_RO_BY_PRIVILEGED_ONLY;
+
+    HalMpuDisable();
+    (VOID)HalMpuDisableRegion(id);
+    (VOID)HalMpuSetRegion(id, &mpuAttr);
+    HalMpuEnable(1);
+}
 #endif
 #endif
 
@@ -766,7 +532,7 @@ LITE_OS_SEC_TEXT STATIC VOID OsHandleNewTaskStackOverflow(VOID)
 #if (LOSCFG_BASE_CORE_TSK_MONITOR == 1)
 LITE_OS_SEC_TEXT VOID OsTaskSwitchCheck(VOID)
 {
-    UINTPTR intSave = LOS_IntLock();
+    UINT32 intSave = LOS_IntLock();
 #if (LOSCFG_EXC_HRADWARE_STACK_PROTECTION == 0)
     UINT32 endOfStack = g_losTask.newTask->topOfStack + g_losTask.newTask->stackSize;
 
@@ -777,6 +543,8 @@ LITE_OS_SEC_TEXT VOID OsTaskSwitchCheck(VOID)
         ((UINT32)(UINTPTR)(g_losTask.newTask->stackPointer) > endOfStack)) {
         OsHandleNewTaskStackOverflow();
     }
+#else
+    OsTaskStackProtect();
 #endif
 
 #if (LOSCFG_BASE_CORE_EXC_TSK_SWITCH == 1)
@@ -832,11 +600,7 @@ LITE_OS_SEC_TEXT_MINOR VOID OsTaskMonInit(VOID)
 LITE_OS_SEC_TEXT_INIT VOID OsTaskEntry(UINT32 taskID)
 {
     UINT32 retVal;
-    LosTaskCB *taskCB = NULL;
-
-    OS_TASK_ID_CHECK(taskID);
-
-    taskCB = OS_TCB_FROM_TID(taskID);
+    LosTaskCB *taskCB = OS_TCB_FROM_TID(taskID);
 
     (VOID)taskCB->taskEntry(taskCB->arg);
 
@@ -894,11 +658,21 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsNewTaskInit(LosTaskCB *taskCB, TSK_INIT_PARAM_S *
     taskCB->taskMux         = NULL;
     taskCB->taskStatus      = OS_TASK_STATUS_SUSPEND;
     taskCB->priority        = taskInitParam->usTaskPrio;
+    taskCB->timeSlice       = 0;
+    taskCB->waitTimes       = 0;
     taskCB->taskEntry       = taskInitParam->pfnTaskEntry;
     taskCB->event.uwEventID = OS_NULL_INT;
     taskCB->eventMask       = 0;
     taskCB->taskName        = taskInitParam->pcName;
     taskCB->msg             = NULL;
+	
+	PRINT_INFO("Task:%s[0x%x, %d] sp:0x%x, top:0x%x--0x%x, size:0x%x entry:%p\n", 
+		taskCB->taskName, taskCB, taskCB->priority,
+		taskCB->stackPointer, taskCB->topOfStack, 
+		taskCB->topOfStack + taskCB->stackSize,
+		taskCB->stackSize, taskCB->taskEntry);
+	
+    SET_SORTLIST_VALUE(&taskCB->sortList, OS_SORT_LINK_INVALID_TIME);
     return LOS_OK;
 }
 
@@ -911,7 +685,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsNewTaskInit(LosTaskCB *taskCB, TSK_INIT_PARAM_S *
  *****************************************************************************/
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskCreateOnly(UINT32 *taskID, TSK_INIT_PARAM_S *taskInitParam)
 {
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     VOID  *topOfStack = NULL;
     LosTaskCB *taskCB = NULL;
     UINT32 retVal;
@@ -938,8 +712,14 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskCreateOnly(UINT32 *taskID, TSK_INIT_PARAM_S
 
     LOS_IntRestore(intSave);
 
+#if (LOSCFG_EXC_HRADWARE_STACK_PROTECTION == 1)
+    UINTPTR stackPtr = (UINTPTR)LOS_MemAllocAlign(OS_TASK_STACK_ADDR, taskInitParam->uwStackSize +
+        OS_TASK_STACK_PROTECT_SIZE, OS_TASK_STACK_PROTECT_SIZE);
+    topOfStack = (VOID *)(stackPtr + OS_TASK_STACK_PROTECT_SIZE);
+#else
     topOfStack = (VOID *)LOS_MemAllocAlign(OS_TASK_STACK_ADDR, taskInitParam->uwStackSize,
         LOSCFG_STACK_POINT_ALIGN_SIZE);
+#endif
     if (topOfStack == NULL) {
         intSave = LOS_IntLock();
         LOS_ListAdd(&g_losFreeTask, &taskCB->pendList);
@@ -953,6 +733,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskCreateOnly(UINT32 *taskID, TSK_INIT_PARAM_S
     }
 
     *taskID = taskCB->taskID;
+    OsHookCall(LOS_HOOK_TYPE_TASK_CREATE, taskCB);
     return retVal;
 
 LOS_ERREND:
@@ -960,21 +741,6 @@ LOS_ERREND:
     return retVal;
 }
 
-/* ****************************************************************************
- Function    : OsTaskSchedule
- Description : Function to check task schedule and do real task schedule.
- Input       : None
- Output      : None
- Return      : None
- **************************************************************************** */
-VOID OsTaskSchedule(VOID)
-{
-#if (LOSCFG_BASE_CORE_TSK_MONITOR == 1)
-    OsTaskSwitchCheck();
-#endif
-    HalTaskSchedule();
-}
-
 /*****************************************************************************
  Function    : LOS_TaskCreate
  Description : Create a task
@@ -985,7 +751,7 @@ VOID OsTaskSchedule(VOID)
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskCreate(UINT32 *taskID, TSK_INIT_PARAM_S *taskInitParam)
 {
     UINT32 retVal;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     LosTaskCB *taskCB = NULL;
 
     retVal = LOS_TaskCreateOnly(taskID, taskInitParam);
@@ -995,28 +761,18 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskCreate(UINT32 *taskID, TSK_INIT_PARAM_S *ta
     taskCB = OS_TCB_FROM_TID(*taskID);
 
     intSave = LOS_IntLock();
-    taskCB->taskStatus &= (~OS_TASK_STATUS_SUSPEND);
-    taskCB->taskStatus |= OS_TASK_STATUS_READY;
-
 #if (LOSCFG_BASE_CORE_CPUP == 1)
     g_cpup[taskCB->taskID].cpupID = taskCB->taskID;
     g_cpup[taskCB->taskID].status = taskCB->taskStatus;
 #endif
 
-    OsPriqueueEnqueue(&taskCB->pendList, taskCB->priority);
-    g_losTask.newTask = LOS_DL_LIST_ENTRY(OsPriqueueTop(), LosTaskCB, pendList);
+    OsSchedTaskEnQueue(taskCB);
+    LOS_IntRestore(intSave);
 
-    if ((g_taskScheduled) && (g_losTaskLock == 0)) {
-        if (g_losTask.runTask != g_losTask.newTask) {
-            if (LOS_CHECK_SCHEDULE) {
-                LOS_IntRestore(intSave);
-                OsTaskSchedule();
-                return LOS_OK;
-            }
-        }
+    if (g_taskScheduled) {
+        LOS_Schedule();
     }
 
-    LOS_IntRestore(intSave);
     return LOS_OK;
 }
 
@@ -1029,7 +785,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskCreate(UINT32 *taskID, TSK_INIT_PARAM_S *ta
  *****************************************************************************/
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskResume(UINT32 taskID)
 {
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     LosTaskCB *taskCB = NULL;
     UINT16 tempStatus;
     UINT32 retErr = OS_ERROR;
@@ -1052,14 +808,12 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskResume(UINT32 taskID)
 
     taskCB->taskStatus &= (~OS_TASK_STATUS_SUSPEND);
     if (!(taskCB->taskStatus & OS_CHECK_TASK_BLOCK)) {
-        taskCB->taskStatus |= OS_TASK_STATUS_READY;
-        OsPriqueueEnqueue(&taskCB->pendList, taskCB->priority);
+        OsSchedTaskEnQueue(taskCB);
         if (g_taskScheduled) {
             LOS_IntRestore(intSave);
             LOS_Schedule();
             return LOS_OK;
         }
-        g_losTask.newTask = LOS_DL_LIST_ENTRY(OsPriqueueTop(), LosTaskCB, pendList);
     }
 
     LOS_IntRestore(intSave);
@@ -1079,7 +833,7 @@ LOS_ERREND:
  *****************************************************************************/
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskSuspend(UINT32 taskID)
 {
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     LosTaskCB *taskCB = NULL;
     UINT16 tempStatus;
     UINT32 retErr;
@@ -1108,11 +862,11 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskSuspend(UINT32 taskID)
     }
 
     if (tempStatus & OS_TASK_STATUS_READY) {
-        OsPriqueueDequeue(&taskCB->pendList);
-        taskCB->taskStatus &= (~OS_TASK_STATUS_READY);
+        OsSchedTaskDeQueue(taskCB);
     }
 
     taskCB->taskStatus |= OS_TASK_STATUS_SUSPEND;
+    OsHookCall(LOS_HOOK_TYPE_MOVEDTASKTOSUSPENDEDLIST, taskCB);
     if (taskID == g_losTask.runTask->taskID) {
         LOS_IntRestore(intSave);
         LOS_Schedule();
@@ -1132,7 +886,7 @@ LITE_OS_SEC_TEXT_INIT STATIC_INLINE VOID OsRunningTaskDelete(UINT32 taskID, LosT
     LOS_ListTailInsert(&g_taskRecyleList, &taskCB->pendList);
     g_losTask.runTask = &g_taskCBArray[g_taskMaxNum];
     g_losTask.runTask->taskID = taskID;
-    g_losTask.runTask->taskStatus = taskCB->taskStatus;
+    g_losTask.runTask->taskStatus = taskCB->taskStatus | OS_TASK_STATUS_RUNNING;
     g_losTask.runTask->topOfStack = taskCB->topOfStack;
     g_losTask.runTask->taskName = taskCB->taskName;
 }
@@ -1145,8 +899,9 @@ LITE_OS_SEC_TEXT_INIT STATIC_INLINE VOID OsRunningTaskDelete(UINT32 taskID, LosT
  *****************************************************************************/
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskDelete(UINT32 taskID)
 {
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     LosTaskCB *taskCB = OS_TCB_FROM_TID(taskID);
+    UINTPTR stackPtr;
 
     UINT32 ret = OsCheckTaskIDValid(taskID);
     if (ret != LOS_OK) {
@@ -1154,6 +909,12 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskDelete(UINT32 taskID)
     }
 
     intSave = LOS_IntLock();
+	PRINT_INFO("                 LOS_TaskDelete:%s[0x%x, %d] sp:0x%x, top:0x%x--0x%x, size:0x%x entry:%p\n", 
+									taskCB->taskName, 
+									taskCB, taskCB->priority,
+									taskCB->stackPointer, taskCB->topOfStack, 
+									taskCB->topOfStack + taskCB->stackSize,
+									taskCB->stackSize, taskCB->taskEntry);
 
     if ((taskCB->taskStatus) & OS_TASK_STATUS_UNUSED) {
         LOS_IntRestore(intSave);
@@ -1166,36 +927,30 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskDelete(UINT32 taskID)
         g_losTaskLock = 0;
     }
 
-    if ((taskCB->taskStatus) & OS_TASK_STATUS_READY) {
-        OsPriqueueDequeue(&taskCB->pendList);
-        taskCB->taskStatus &= (~OS_TASK_STATUS_READY);
-    } else if (((taskCB->taskStatus) & (OS_TASK_STATUS_PEND | OS_TASK_STATUS_PEND_QUEUE))) {
-        LOS_ListDelete(&taskCB->pendList);
-    }
-
-    if ((taskCB->taskStatus) & (OS_TASK_STATUS_DELAY | OS_TASK_STATUS_TIMEOUT)) {
-        OsTimerListDelete(taskCB);
-    }
+    OsHookCall(LOS_HOOK_TYPE_TASK_DELETE, taskCB);
+    OsSchedTaskExit(taskCB);
 
-    taskCB->taskStatus &= (~(OS_TASK_STATUS_SUSPEND));
-    taskCB->taskStatus |= OS_TASK_STATUS_UNUSED;
     taskCB->event.uwEventID = OS_NULL_INT;
     taskCB->eventMask = 0;
 #if (LOSCFG_BASE_CORE_CPUP == 1)
     // Ignore the return code when matching CSEC rule 6.6(4).
     (VOID)memset_s((VOID *)&g_cpup[taskCB->taskID], sizeof(OsCpupCB), 0, sizeof(OsCpupCB));
 #endif
-    g_losTask.newTask = LOS_DL_LIST_ENTRY(OsPriqueueTop(), LosTaskCB, pendList);
-    if (taskCB->taskStatus & OS_TASK_STATUS_RUNNING) {
-        OsRunningTaskDelete(taskID, taskCB);
+    if (taskCB->taskStatus & OS_TASK_STATUS_RUNNING) { 
         taskCB->taskStatus = OS_TASK_STATUS_UNUSED;
+        OsRunningTaskDelete(taskID, taskCB);
         LOS_IntRestore(intSave);
-        OsTaskSchedule();
+        LOS_Schedule();
         return LOS_OK;
     } else {
         taskCB->taskStatus = OS_TASK_STATUS_UNUSED;
         LOS_ListAdd(&g_losFreeTask, &taskCB->pendList);
-        (VOID)LOS_MemFree(OS_TASK_STACK_ADDR, (VOID *)(UINTPTR)taskCB->topOfStack);
+#if (LOSCFG_EXC_HRADWARE_STACK_PROTECTION == 1)
+        stackPtr = taskCB->topOfStack - OS_TASK_STACK_PROTECT_SIZE;
+#else
+        stackPtr = taskCB->topOfStack;
+#endif
+        (VOID)LOS_MemFree(OS_TASK_STACK_ADDR, (VOID *)stackPtr);
         taskCB->topOfStack = (UINT32)NULL;
     }
 
@@ -1212,7 +967,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskDelete(UINT32 taskID)
  *****************************************************************************/
 LITE_OS_SEC_TEXT UINT32 LOS_TaskDelay(UINT32 tick)
 {
-    UINTPTR intSave;
+    UINT32 intSave = 0;
 
     if (OS_INT_ACTIVE) {
         return LOS_ERRNO_TSK_DELAY_IN_INT;
@@ -1222,14 +977,13 @@ LITE_OS_SEC_TEXT UINT32 LOS_TaskDelay(UINT32 tick)
         return LOS_ERRNO_TSK_DELAY_IN_LOCK;
     }
 
+    OsHookCall(LOS_HOOK_TYPE_TASK_DELAY, tick);
     if (tick == 0) {
         return LOS_TaskYield();
     } else {
         intSave = LOS_IntLock();
-        OsPriqueueDequeue(&(g_losTask.runTask->pendList));
-        g_losTask.runTask->taskStatus &= (~OS_TASK_STATUS_READY);
-        OsTaskAdd2TimerList((LosTaskCB *)g_losTask.runTask, tick);
-        g_losTask.runTask->taskStatus |= OS_TASK_STATUS_DELAY;
+        OsSchedDelay(g_losTask.runTask, tick);
+        OsHookCall(LOS_HOOK_TYPE_MOVEDTASKTODELAYEDLIST, g_losTask.runTask);
         LOS_IntRestore(intSave);
         LOS_Schedule();
     }
@@ -1239,7 +993,7 @@ LITE_OS_SEC_TEXT UINT32 LOS_TaskDelay(UINT32 tick)
 
 LITE_OS_SEC_TEXT_MINOR UINT16 LOS_TaskPriGet(UINT32 taskID)
 {
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     LosTaskCB *taskCB = NULL;
     UINT16 priority;
 
@@ -1264,7 +1018,7 @@ LITE_OS_SEC_TEXT_MINOR UINT16 LOS_TaskPriGet(UINT32 taskID)
 LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskPriSet(UINT32 taskID, UINT16 taskPrio)
 {
     BOOL isReady = FALSE;
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     LosTaskCB *taskCB = NULL;
     UINT16 tempStatus;
 
@@ -1291,18 +1045,8 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskPriSet(UINT32 taskID, UINT16 taskPrio)
         LOS_IntRestore(intSave);
         return LOS_ERRNO_TSK_NOT_CREATED;
     }
-    /* delete the task and insert with right priority into ready queue */
-    isReady = (tempStatus & OS_TASK_STATUS_READY);
-    if (isReady) {
-        OsPriqueueDequeue(&taskCB->pendList);
-        taskCB->taskStatus &= (~OS_TASK_STATUS_READY);
-        taskCB->priority = taskPrio;
-        taskCB->taskStatus |= OS_TASK_STATUS_READY;
-        OsPriqueueEnqueue(&taskCB->pendList, taskCB->priority);
-    } else {
-        taskCB->priority = taskPrio;
-    }
 
+    isReady = OsSchedModifyTaskSchedParam(taskCB, taskPrio);
     LOS_IntRestore(intSave);
     /* delete the task and insert with right priority into ready queue */
     if (isReady) {
@@ -1314,57 +1058,7 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskPriSet(UINT32 taskID, UINT16 taskPrio)
 
 LITE_OS_SEC_TEXT_MINOR UINT32 LOS_CurTaskPriSet(UINT16 taskPrio)
 {
-    UINT32 retVal;
-    retVal = LOS_TaskPriSet(g_losTask.runTask->taskID, taskPrio);
-    return retVal;
-}
-
-/**************************************************************************
- Function    : OsTaskWait
- Description : pend the running task in a list
- Input       : pendingList   -- The pending list
-               taskStatus    -- The status need to be converted to
-               timeout       -- Expiry time
- Output      : None
- Return      : None
-**************************************************************************/
-VOID OsTaskWait(LOS_DL_LIST *pendingList, UINT32 taskStatus, UINT32 timeout)
-{
-    LosTaskCB *runTask = NULL;
-    LOS_DL_LIST *pendObj = NULL;
-
-    runTask = g_losTask.runTask;
-    OsPriqueueDequeue(&runTask->pendList);
-    runTask->taskStatus &= (~OS_TASK_STATUS_READY);
-    pendObj = &runTask->pendList;
-    runTask->taskStatus |= taskStatus;
-    LOS_ListTailInsert(pendingList, pendObj);
-    if (timeout != LOS_WAIT_FOREVER) {
-        runTask->taskStatus |= OS_TASK_STATUS_TIMEOUT;
-        OsTaskAdd2TimerList((LosTaskCB *)runTask, timeout);
-    }
-}
-
-/**************************************************************************
- Function    : OsTaskWake
- Description : delete the task from pendlist and also add to the priqueue
- Input       : resumedTask    --  resumed task
-             : taskStatus     --  the status to be unset
- Output      : resumedTask    --  resumed task
- Return      : None
-**************************************************************************/
-VOID OsTaskWake(LosTaskCB *resumedTask, UINT32 taskStatus)
-{
-    LOS_ListDelete(&resumedTask->pendList);
-    resumedTask->taskStatus &= (~taskStatus);
-    if (resumedTask->taskStatus & OS_TASK_STATUS_TIMEOUT) {
-        OsTimerListDelete(resumedTask);
-        resumedTask->taskStatus &= (~OS_TASK_STATUS_TIMEOUT);
-    }
-    if (!(resumedTask->taskStatus & OS_TASK_STATUS_SUSPEND)) {
-        resumedTask->taskStatus |= OS_TASK_STATUS_READY;
-        OsPriqueueEnqueue(&resumedTask->pendList, resumedTask->priority);
-    }
+    return LOS_TaskPriSet(g_losTask.runTask->taskID, taskPrio);
 }
 
 /*****************************************************************************
@@ -1376,28 +1070,10 @@ VOID OsTaskWake(LosTaskCB *resumedTask, UINT32 taskStatus)
  *****************************************************************************/
 LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskYield(VOID)
 {
-    UINT32 taskCount;
-    UINTPTR intSave;
-
-    if (g_losTask.runTask->taskID >= g_taskMaxNum) {
-        return LOS_ERRNO_TSK_ID_INVALID;
-    }
-
-    if (!(g_losTask.runTask->taskStatus & OS_TASK_STATUS_READY)) {
-        return LOS_OK;
-    }
+    UINT32 intSave = 0;
 
     intSave = LOS_IntLock();
-    taskCount = OsPriqueueSize(g_losTask.runTask->priority);
-    if (taskCount > 1) {
-        LOS_ListDelete(&(g_losTask.runTask->pendList));
-        g_losTask.runTask->taskStatus |= OS_TASK_STATUS_READY;
-        OsPriqueueEnqueue(&(g_losTask.runTask->pendList), g_losTask.runTask->priority);
-    } else {
-        LOS_IntRestore(intSave);
-        return LOS_ERRNO_TSK_YIELD_NOT_ENOUGH_TASK;
-    }
-
+    OsSchedYield();
     LOS_IntRestore(intSave);
     LOS_Schedule();
     return LOS_OK;
@@ -1412,7 +1088,7 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskYield(VOID)
  *****************************************************************************/
 LITE_OS_SEC_TEXT_MINOR VOID LOS_TaskLock(VOID)
 {
-    UINTPTR intSave;
+    UINT32 intSave = 0;
 
     intSave = LOS_IntLock();
     g_losTaskLock++;
@@ -1428,7 +1104,7 @@ LITE_OS_SEC_TEXT_MINOR VOID LOS_TaskLock(VOID)
  *****************************************************************************/
 LITE_OS_SEC_TEXT_MINOR VOID LOS_TaskUnlock(VOID)
 {
-    UINTPTR intSave;
+    UINT32 intSave = 0;
 
     intSave = LOS_IntLock();
     if (g_losTaskLock > 0) {
@@ -1445,11 +1121,8 @@ LITE_OS_SEC_TEXT_MINOR VOID LOS_TaskUnlock(VOID)
 
 LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskInfoGet(UINT32 taskID, TSK_INFO_S *taskInfo)
 {
-    UINT32 intSave;
+    UINT32 intSave = 0;
     LosTaskCB *taskCB = NULL;
-#if (LOSCFG_EXC_HRADWARE_STACK_PROTECTION == 1)
-    UINT32 flag;
-#endif
 
     if (taskInfo == NULL) {
         return LOS_ERRNO_TSK_PTR_NULL;
@@ -1488,18 +1161,8 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskInfoGet(UINT32 taskID, TSK_INFO_S *taskInf
     taskInfo->uwBottomOfStack = TRUNCATE(((UINT32)(taskCB->topOfStack) + (taskCB->stackSize)),
                                          OS_TASK_STACK_ADDR_ALIGN);
     taskInfo->uwCurrUsed = taskInfo->uwBottomOfStack - taskInfo->uwSP;
-
-#if (LOSCFG_EXC_HRADWARE_STACK_PROTECTION == 1)
-    flag = osStackProtDisable();
-#endif
-
     taskInfo->uwPeakUsed = OsGetTaskWaterLine(taskID);
     taskInfo->bOvf = (taskInfo->uwPeakUsed == OS_NULL_INT) ? TRUE : FALSE;
-
-#if (LOSCFG_EXC_HRADWARE_STACK_PROTECTION == 1)
-    osStackProtRestore(flag);
-#endif
-
     LOS_IntRestore(intSave);
 
     return LOS_OK;
@@ -1536,7 +1199,7 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskStatusGet(UINT32 taskID, UINT32 *taskStatu
 #if (LOSCFG_BASE_CORE_EXC_TSK_SWITCH == 1)
 LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskSwitchInfoGet(UINT32 index, UINT32 *taskSwitchInfo)
 {
-    UINTPTR intSave;
+    UINT32 intSave = 0;
     UINT32 curIndex;
 
     curIndex = index;
@@ -1598,10 +1261,7 @@ LITE_OS_SEC_TEXT_MINOR BOOL LOS_TaskIsRunning(VOID)
  *****************************************************************************/
 LITE_OS_SEC_TEXT UINT32 LOS_NewTaskIDGet(VOID)
 {
-    if (g_losTask.newTask == NULL) {
-        return LOS_ERRNO_TSK_ID_INVALID;
-    }
-    return g_losTask.newTask->taskID;
+    return LOS_NextTaskIDGet();
 }
 
 /*****************************************************************************
@@ -1632,70 +1292,6 @@ LITE_OS_SEC_TEXT CHAR* LOS_TaskNameGet(UINT32 taskID)
     return taskCB->taskName;
 }
 
-/* ****************************************************************************
- Function    : LOS_Schedule
- Description : Function to determine whether task scheduling is required.
- Input       : None
- Output      : None
- Return      : None
- **************************************************************************** */
-VOID LOS_Schedule(VOID)
-{
-    UINTPTR intSave;
-
-    intSave = LOS_IntLock();
-    /* Find the highest task */
-    g_losTask.newTask = LOS_DL_LIST_ENTRY(OsPriqueueTop(), LosTaskCB, pendList);
-    /* In case that running is not highest then reschedule */
-    if (g_losTask.runTask != g_losTask.newTask) {
-        if (LOS_CHECK_SCHEDULE) {
-            LOS_IntRestore(intSave);
-            OsTaskSchedule();
-            return;
-        }
-    }
-    LOS_IntRestore(intSave);
-}
-
-#if (LOSCFG_BASE_CORE_TIMESLICE == 1)
-LITE_OS_SEC_BSS OsTaskRobin g_taskTimeSlice;
-
-/*****************************************************************************
- Function     : OsTimesliceInit
- Description  : Initialztion Timeslice
- Input        : None
- Output       : None
- Return       : None
- *****************************************************************************/
-LITE_OS_SEC_TEXT_INIT VOID OsTimesliceInit(VOID)
-{
-    g_taskTimeSlice.task = (LosTaskCB *)NULL;
-    g_taskTimeSlice.tout = LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT;
-}
-
-/*****************************************************************************
- Function     : OsTimesliceCheck
- Description  : check Timeslice
- Input        : None
- Output       : None
- Return       : None
- *****************************************************************************/
-LITE_OS_SEC_TEXT VOID OsTimesliceCheck(VOID)
-{
-    if (g_taskTimeSlice.task != g_losTask.runTask) {
-        g_taskTimeSlice.task = g_losTask.runTask;
-        g_taskTimeSlice.time = ((UINT16)g_ullTickCount + g_taskTimeSlice.tout) - 1;
-    }
-
-    if (g_taskTimeSlice.time  == (UINT16)g_ullTickCount) {
-        g_taskTimeSlice.task = (LosTaskCB *)NULL;
-        if (LOS_TaskYield() != LOS_OK) {
-            PRINT_INFO("%s, %d\n", __FUNCTION__, __LINE__);
-        }
-    }
-}
-#endif
-
 LITE_OS_SEC_TEXT_MINOR VOID LOS_Msleep(UINT32 mSecs)
 {
     UINT32 interval;
@@ -1716,8 +1312,19 @@ LITE_OS_SEC_TEXT_MINOR VOID LOS_Msleep(UINT32 mSecs)
     (VOID)LOS_TaskDelay(interval);
 }
 
-#ifdef __cplusplus
-#if __cplusplus
+VOID LOS_UDelay(UINT64 microseconds)
+{
+    UINT64 endTime;
+
+    if (microseconds == 0) {
+        return;
+    }
+
+    endTime = (microseconds / OS_SYS_US_PER_SECOND) * OS_SYS_CLOCK +
+            (microseconds % OS_SYS_US_PER_SECOND) * OS_SYS_CLOCK / OS_SYS_US_PER_SECOND;
+    endTime = LOS_SysCycleGet() + endTime;
+    while (LOS_SysCycleGet() < endTime) {
+    }
+
+    return;
 }
-#endif /* __cplusplus */
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/kernel/src/los_tick.c b/kernel/liteos_m/kernel/src/los_tick.c
index ea4e66d..897a44e 100644
--- a/kernel/liteos_m/kernel/src/los_tick.c
+++ b/kernel/liteos_m/kernel/src/los_tick.c
@@ -30,17 +30,12 @@
  */
 
 #include "los_tick.h"
+#include "los_config.h"
 #include "los_task.h"
 #include "los_swtmr.h"
-#include "los_config.h"
+#include "los_sched.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
-LITE_OS_SEC_BSS UINT64 g_ullTickCount;
 LITE_OS_SEC_BSS UINT32 g_ticksPerSec;
 LITE_OS_SEC_BSS UINT32 g_uwCyclePerSec;
 LITE_OS_SEC_BSS UINT32 g_cyclesPerTick;
@@ -52,29 +47,22 @@ extern VOID platform_tick_handler(VOID);
 
 LITE_OS_SEC_TEXT VOID OsTickHandler(VOID)
 {
-#if (LOSCFG_BASE_CORE_TICK_HW_TIME == 1)
-    platform_tick_handler();
+#if (LOSCFG_BASE_CORE_TICK_WTIMER == 0)
+    OsSchedUpdateSchedTimeBase();
 #endif
 
-    g_ullTickCount++;
-
-#if (LOSCFG_BASE_CORE_TIMESLICE == 1)
-    OsTimesliceCheck();
+#if (LOSCFG_BASE_CORE_TICK_HW_TIME == 1)
+    platform_tick_handler();
 #endif
 
-    OsTaskScan();  // task timeout scan
-
-#if (LOSCFG_BASE_CORE_SWTMR == 1)
-    (VOID)OsSwtmrScan();
-#endif
+    LOS_SchedTickHandler();
 }
 
-UINT32 LOS_SysClockGet(VOID)
+UINT64 LOS_SysCycleGet(VOID)
 {
-    return g_sysClock;
+    return OsGetCurrSchedTimeCycle();
 }
 
-
 /*****************************************************************************
 Function    : LOS_TickCountGet
 Description : get current tick
@@ -84,7 +72,7 @@ Return      : current tick
 *****************************************************************************/
 LITE_OS_SEC_TEXT_MINOR UINT64 LOS_TickCountGet(VOID)
 {
-    return g_ullTickCount;
+    return OsGetCurrSchedTimeCycle() / OS_CYCLE_PER_TICK;
 }
 
 /*****************************************************************************
@@ -190,8 +178,3 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsCpuTick2US(CpuTick *cpuTick, UINT32 *usHi, UINT32
 }
 
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/kernel/src/mm/los_membox.c b/kernel/liteos_m/kernel/src/mm/los_membox.c
old mode 100755
new mode 100644
index a4c1201..dc1a159
--- a/kernel/liteos_m/kernel/src/mm/los_membox.c
+++ b/kernel/liteos_m/kernel/src/mm/los_membox.c
@@ -36,11 +36,6 @@
 #include "los_debug.h"
 #include "los_task.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
 /* The magic length is 32 bits, the lower 8 bits are used to save the owner task ID,
    and the other 24 bits are used to set the magic number for verification. */
@@ -119,7 +114,7 @@ UINT32 LOS_MemboxInit(VOID *pool, UINT32 poolSize, UINT32 blkSize)
     LOS_MEMBOX_INFO *boxInfo = (LOS_MEMBOX_INFO *)pool;
     LOS_MEMBOX_NODE *node = NULL;
     UINT32 index;
-    UINT32 intSave;
+    UINT32 intSave = 0;
 
     if (pool == NULL) {
         return LOS_NOK;
@@ -134,11 +129,7 @@ UINT32 LOS_MemboxInit(VOID *pool, UINT32 poolSize, UINT32 blkSize)
     }
 
     MEMBOX_LOCK(intSave);
-    boxInfo->uwBlkSize = LOS_MEMBOX_ALLIGNED(blkSize + OS_MEMBOX_NODE_HEAD_SIZE);
-    if (boxInfo->uwBlkSize == 0) {
-        MEMBOX_UNLOCK(intSave);
-        return LOS_NOK;
-    }
+    boxInfo->uwBlkSize = LOS_MEMBOX_ALIGNED(blkSize + OS_MEMBOX_NODE_HEAD_SIZE);
     boxInfo->uwBlkNum = (poolSize - sizeof(LOS_MEMBOX_INFO)) / boxInfo->uwBlkSize;
     boxInfo->uwBlkCnt = 0;
     if (boxInfo->uwBlkNum == 0) {
@@ -171,7 +162,7 @@ VOID *LOS_MemboxAlloc(VOID *pool)
     LOS_MEMBOX_INFO *boxInfo = (LOS_MEMBOX_INFO *)pool;
     LOS_MEMBOX_NODE *node = NULL;
     LOS_MEMBOX_NODE *nodeTmp = NULL;
-    UINT32 intSave;
+    UINT32 intSave = 0;
 
     if (pool == NULL) {
         return NULL;
@@ -194,7 +185,7 @@ UINT32 LOS_MemboxFree(VOID *pool, VOID *box)
 {
     LOS_MEMBOX_INFO *boxInfo = (LOS_MEMBOX_INFO *)pool;
     UINT32 ret = LOS_NOK;
-    UINT32 intSave;
+    UINT32 intSave = 0;
 
     if ((pool == NULL) || (box == NULL)) {
         return LOS_NOK;
@@ -232,7 +223,7 @@ VOID LOS_MemboxClr(VOID *pool, VOID *box)
 VOID LOS_ShowBox(VOID *pool)
 {
     UINT32 index;
-    UINT32 intSave;
+    UINT32 intSave = 0;
     LOS_MEMBOX_INFO *boxInfo = (LOS_MEMBOX_INFO *)pool;
     LOS_MEMBOX_NODE *node = NULL;
 
@@ -276,7 +267,7 @@ STATIC VOID OsMemboxExcInfoGetSub(const LOS_MEMBOX_INFO *pool, MemInfoCB *memExc
     LOS_MEMBOX_NODE *node = NULL;
     UINTPTR poolStart, poolEnd;
     UINT32 index;
-    UINT32 intSave;
+    UINT32 intSave = 0;
 
     (VOID)memset_s(memExcInfo, sizeof(MemInfoCB), 0, sizeof(MemInfoCB));
 
@@ -324,8 +315,3 @@ UINT32 OsMemboxExcInfoGet(UINT32 memNumMax, MemInfoCB *memExcInfo)
 }
 #endif
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/kernel/src/mm/los_memory.c b/kernel/liteos_m/kernel/src/mm/los_memory.c
old mode 100755
new mode 100644
index 69ae3e2..9a727a9
--- a/kernel/liteos_m/kernel/src/mm/los_memory.c
+++ b/kernel/liteos_m/kernel/src/mm/los_memory.c
@@ -29,21 +29,14 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "los_memory.h"
 #include "securec.h"
+#include "los_arch.h"
 #include "los_config.h"
+#include "los_debug.h"
+#include "los_hook.h"
 #include "los_interrupt.h"
-#include "los_arch.h"
-#include "los_memory.h"
 #include "los_task.h"
-#include "los_debug.h"
-#ifdef LOSCFG_LIB_LIBC
-#endif
-
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
 /* Used to cut non-essential functions. */
 #define OS_MEM_EXPAND_ENABLE    0
@@ -538,7 +531,7 @@ VOID LOS_MemUsedNodeShow(VOID *pool)
     struct OsMemPoolHead *poolInfo = (struct OsMemPoolHead *)pool;
     struct OsMemNodeHead *tmpNode = NULL;
     struct OsMemNodeHead *endNode = NULL;
-    UINT32 intSave;
+    UINT32 intSave = 0;
     UINT32 count;
 
     PRINTK("\n\rnode          size    ");
@@ -894,7 +887,13 @@ UINT32 LOS_MemInit(VOID *pool, UINT32 size)
         return OS_ERROR;
     }
 
-    size = OS_MEM_ALIGN(size, OS_MEM_ALIGN_SIZE);
+    if (((UINTPTR)pool & (OS_MEM_ALIGN_SIZE - 1)) || \
+        (size & (OS_MEM_ALIGN_SIZE - 1))) {
+        PRINT_ERR("LiteOS heap memory address or size configured not aligned:address:0x%x,size:0x%x, alignsize:%d\n", \
+                  (UINTPTR)pool, size, OS_MEM_ALIGN_SIZE);
+        return OS_ERROR;
+    }
+
     if (OsMemPoolInit(pool, size)) {
         return OS_ERROR;
     }
@@ -911,6 +910,8 @@ UINT32 LOS_MemInit(VOID *pool, UINT32 size)
     LOS_TraceReg(LOS_TRACE_MEM_INFO, OsMemInfoTrace, LOS_TRACE_MEM_INFO_NAME, LOS_TRACE_ENABLE);
 #endif
 
+    OsHookCall(LOS_HOOK_TYPE_MEM_INIT, pool, size);
+
     return LOS_OK;
 }
 
@@ -932,6 +933,8 @@ UINT32 LOS_MemDeInit(VOID *pool)
     LOS_TraceUnreg(LOS_TRACE_MEM_INFO);
 #endif
 
+    OsHookCall(LOS_HOOK_TYPE_MEM_DEINIT, pool);
+
     return LOS_OK;
 }
 
@@ -960,10 +963,6 @@ STATIC INLINE VOID *OsMemAlloc(struct OsMemPoolHead *pool, UINT32 size, UINT32 i
 #endif
 
     UINT32 allocSize = OS_MEM_ALIGN(size + OS_MEM_NODE_HEAD_SIZE, OS_MEM_ALIGN_SIZE);
-    if (allocSize == 0) {
-        return NULL;
-    }
-
 #if OS_MEM_EXPAND_ENABLE
 retry:
 #endif
@@ -1017,7 +1016,7 @@ VOID *LOS_MemAlloc(VOID *pool, UINT32 size)
 
     struct OsMemPoolHead *poolHead = (struct OsMemPoolHead *)pool;
     VOID *ptr = NULL;
-    UINT32 intSave;
+    UINT32 intSave = 0;
 
     MEM_LOCK(poolHead, intSave);
     do {
@@ -1041,6 +1040,8 @@ VOID *LOS_MemAlloc(VOID *pool, UINT32 size)
               poolStatus.maxFreeNodeSize, poolStatus.usedNodeNum, poolStatus.freeNodeNum);
 #endif
 
+    OsHookCall(LOS_HOOK_TYPE_MEM_ALLOC, pool, size);
+
     return ptr;
 }
 
@@ -1076,7 +1077,7 @@ VOID *LOS_MemAllocAlign(VOID *pool, UINT32 size, UINT32 boundary)
     }
 
     struct OsMemPoolHead *poolHead = (struct OsMemPoolHead *)pool;
-    UINT32 intSave;
+    UINT32 intSave = 0;
     VOID *ptr = NULL;
     VOID *alignedPtr = NULL;
 
@@ -1104,6 +1105,8 @@ VOID *LOS_MemAllocAlign(VOID *pool, UINT32 size, UINT32 boundary)
     LOS_Trace(LOS_TRACE_MEM_TIME, (UINTPTR)pool & MEM_POOL_ADDR_MASK, MEM_TRACE_MEMALIGN, timeUsed);
 #endif
 
+    OsHookCall(LOS_HOOK_TYPE_MEM_ALLOCALIGN, pool, size, boundary);
+
     return ptr;
 }
 
@@ -1285,7 +1288,7 @@ UINT32 LOS_MemFree(VOID *pool, VOID *ptr)
     UINT32 ret = LOS_NOK;
     struct OsMemPoolHead *poolHead = (struct OsMemPoolHead *)pool;
     struct OsMemNodeHead *node = NULL;
-    UINT32 intSave;
+    UINT32 intSave = 0;
 
     MEM_LOCK(poolHead, intSave);
     do {
@@ -1304,6 +1307,8 @@ UINT32 LOS_MemFree(VOID *pool, VOID *ptr)
     LOS_Trace(LOS_TRACE_MEM_TIME, (UINTPTR)pool & MEM_POOL_ADDR_MASK, MEM_TRACE_FREE, timeUsed);
 #endif
 
+    OsHookCall(LOS_HOOK_TYPE_MEM_FREE, pool, ptr);
+
     return ret;
 }
 
@@ -1384,6 +1389,8 @@ VOID *LOS_MemRealloc(VOID *pool, VOID *ptr, UINT32 size)
         return NULL;
     }
 
+    OsHookCall(LOS_HOOK_TYPE_MEM_REALLOC, pool, ptr, size);
+
     if (ptr == NULL) {
         return LOS_MemAlloc(pool, size);
     }
@@ -1400,7 +1407,7 @@ VOID *LOS_MemRealloc(VOID *pool, VOID *ptr, UINT32 size)
     struct OsMemPoolHead *poolHead = (struct OsMemPoolHead *)pool;
     struct OsMemNodeHead *node = NULL;
     VOID *newPtr = NULL;
-    UINT32 intSave;
+    UINT32 intSave = 0;
 
     MEM_LOCK(poolHead, intSave);
     do {
@@ -1442,7 +1449,7 @@ UINT32 LOS_MemFreeByTaskID(VOID *pool, UINT32 taskID)
     struct OsMemNodeHead *tmpNode = NULL;
     struct OsMemUsedNodeHead *node = NULL;
     struct OsMemNodeHead *endNode = NULL;
-    UINT32 intSave;
+    UINT32 intSave = 0;
 
     MEM_LOCK(poolHead, intSave);
     endNode = OS_MEM_END_NODE(pool, poolHead->info.totalSize);
@@ -1494,7 +1501,7 @@ UINT32 LOS_MemTotalUsedGet(VOID *pool)
     struct OsMemPoolHead *poolInfo = (struct OsMemPoolHead *)pool;
     struct OsMemNodeHead *endNode = NULL;
     UINT32 memUsed = 0;
-    UINT32 intSave;
+    UINT32 intSave = 0;
 
     if (pool == NULL) {
         return LOS_NOK;
@@ -1546,13 +1553,13 @@ STATIC INLINE VOID OsMemMagicCheckPrint(struct OsMemNodeHead **tmpNode)
 
 STATIC UINT32 OsMemAddrValidCheckPrint(const VOID *pool, struct OsMemFreeNodeHead **tmpNode)
 {
-    if (!OsMemAddrValidCheck(pool, (*tmpNode)->prev)) {
+    if (((*tmpNode)->prev != NULL) && !OsMemAddrValidCheck(pool, (*tmpNode)->prev)) {
         PRINT_ERR("[%s], %d, memory check error!\n"
                   " freeNode.prev: 0x%x is out of legal mem range\n",
                   __FUNCTION__, __LINE__, (*tmpNode)->prev);
         return LOS_NOK;
     }
-    if (!OsMemAddrValidCheck(pool, (*tmpNode)->next)) {
+    if (((*tmpNode)->next != NULL) && !OsMemAddrValidCheck(pool, (*tmpNode)->next)) {
         PRINT_ERR("[%s], %d, memory check error!\n"
                   " freeNode.next: 0x%x is out of legal mem range\n",
                   __FUNCTION__, __LINE__, (*tmpNode)->next);
@@ -1699,7 +1706,7 @@ STATIC VOID OsMemNodeInfo(const struct OsMemNodeHead *tmpNode,
                usedNode->header.sizeAndFlag);
     } else {
         freeNode = (struct OsMemFreeNodeHead *)tmpNode;
-        PRINTK("\n broken node head: 0x%x  0x%x  "
+        PRINTK("\n broken node head: 0x%x  0x%x  0x%x  "
 #if (LOSCFG_BASE_MEM_NODE_INTEGRITY_CHECK == 1)
                "0x%x  "
 #endif
@@ -1725,7 +1732,7 @@ STATIC VOID OsMemNodeInfo(const struct OsMemNodeHead *tmpNode,
                usedNode->header.sizeAndFlag);
     } else {
         freeNode = (struct OsMemFreeNodeHead *)preNode;
-        PRINTK("prev node head: 0x%x  0x%x  "
+        PRINTK("prev node head: 0x%x  0x%x  0x%x  "
 #if (LOSCFG_BASE_MEM_NODE_INTEGRITY_CHECK == 1)
                "0x%x  "
 #endif
@@ -1791,10 +1798,10 @@ STATIC VOID OsMemIntegrityCheckError(struct OsMemPoolHead *pool,
     MEM_UNLOCK(pool, intSave);
     PRINT_ERR("cur node: 0x%x, pre node: 0x%x, pre node was allocated by task: %d, %s\n",
               tmpNode, preNode, taskCB->taskID, taskCB->taskName);
-    LOS_Panic("Memory interity check error!\n");
+    LOS_Panic("Memory integrity check error!\n");
 #else
     MEM_UNLOCK(pool, intSave);
-    LOS_Panic("Memory interity check error, cur node: 0x%x, pre node: 0x%x\n", tmpNode, preNode);
+    LOS_Panic("Memory integrity check error, cur node: 0x%x, pre node: 0x%x\n", tmpNode, preNode);
 #endif
 }
 
@@ -1880,9 +1887,11 @@ UINT32 LOS_MemInfoGet(VOID *pool, LOS_MEM_POOL_STATUS *poolStatus)
         return LOS_NOK;
     }
 
+    (VOID)memset_s(poolStatus, sizeof(LOS_MEM_POOL_STATUS), 0, sizeof(LOS_MEM_POOL_STATUS));
+
     struct OsMemNodeHead *tmpNode = NULL;
     struct OsMemNodeHead *endNode = NULL;
-    UINT32 intSave;
+    UINT32 intSave = 0;
 
     MEM_LOCK(poolInfo, intSave);
     endNode = OS_MEM_END_NODE(pool, poolInfo->info.totalSize);
@@ -1932,7 +1941,7 @@ STATIC VOID OsMemInfoPrint(VOID *pool)
            "max free node size   used node num     free node num      UsageWaterLine\n");
     PRINTK("---------------    --------     -------       --------     "
            "--------------       -------------      ------------      ------------\n");
-    PRINTK("%-16#x   0x%-8x   0x%-8x    0x%-8x   0x%-16x   0x%-13x    0x%-13x    0x%-13x\n",
+    PRINTK("0x%-16x   0x%-8x   0x%-8x    0x%-8x   0x%-16x   0x%-13x    0x%-13x    0x%-13x\n",
            poolInfo->info.pool, LOS_MemPoolSizeGet(pool), status.totalUsedSize,
            status.totalFreeSize, status.maxFreeNodeSize, status.usedNodeNum,
            status.freeNodeNum, status.usageWaterLine);
@@ -1962,7 +1971,7 @@ UINT32 LOS_MemFreeNodeShow(VOID *pool)
     struct OsMemFreeNodeHead *node = NULL;
     UINT32 countNum[OS_MEM_FREE_LIST_COUNT] = {0};
     UINT32 index;
-    UINT32 intSave;
+    UINT32 intSave = 0;
 
     MEM_LOCK(poolInfo, intSave);
     for (index = 0; index < OS_MEM_FREE_LIST_COUNT; index++) {
@@ -2010,17 +2019,21 @@ UINT32 OsMemSystemInit(VOID)
 
 #if (LOSCFG_SYS_EXTERNAL_HEAP == 0)
     m_aucSysMem0 = g_memStart;
+#elif LOS_BEKEN
+	extern UINT8 _empty_ram;
+	m_aucSysMem0 = (UINT8 *)&_empty_ram;
 #else
     m_aucSysMem0 = LOSCFG_SYS_HEAP_ADDR;
 #endif
 
-    if ((UINTPTR)m_aucSysMem0 & (OS_MEM_ALIGN_SIZE - 1)) {
-        m_aucSysMem0 = (UINT8 *)(((UINTPTR)m_aucSysMem0 + (OS_MEM_ALIGN_SIZE - 1)) &
-                       ~(OS_MEM_ALIGN_SIZE - 1));
-    }
-
+#if LOS_BEKEN
+	UINT32 HEAP_SIZE = (UINT32)LOSCFG_SYS_HEAP_ADDR_END - (UINT32)LOSCFG_SYS_HEAP_ADDR;
+    ret = LOS_MemInit(m_aucSysMem0, HEAP_SIZE);
+    PRINT_INFO("LiteOS heap memory address:0x%x,size:0x%x\n", m_aucSysMem0, HEAP_SIZE);
+#else
     ret = LOS_MemInit(m_aucSysMem0, LOSCFG_SYS_HEAP_SIZE);
     PRINT_INFO("LiteOS heap memory address:0x%x,size:0x%x\n", m_aucSysMem0, LOSCFG_SYS_HEAP_SIZE);
+#endif
     return ret;
 }
 
@@ -2029,7 +2042,7 @@ STATIC VOID OsMemExcInfoGetSub(struct OsMemPoolHead *pool, MemInfoCB *memExcInfo
 {
     struct OsMemNodeHead *tmpNode = NULL;
     UINT32 taskID = OS_TASK_ERRORID;
-    UINT32 intSave;
+    UINT32 intSave = 0;
 
     (VOID)memset_s(memExcInfo, sizeof(MemInfoCB), 0, sizeof(MemInfoCB));
 
@@ -2095,9 +2108,4 @@ UINT32 OsMemExcInfoGet(UINT32 memNumMax, MemInfoCB *memExcInfo)
 }
 #endif
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
diff --git a/kernel/liteos_m/ohos_config.json b/kernel/liteos_m/ohos_config.json
new file mode 100644
index 0000000..cd9f34d
--- /dev/null
+++ b/kernel/liteos_m/ohos_config.json
@@ -0,0 +1,9 @@
+{
+  "root_path": "/media/sf_workspace/Harmony/liteos_m",
+  "board": null,
+  "kernel": null,
+  "product": null,
+  "product_path": null,
+  "device_path": null,
+  "patch_cache": null
+}
\ No newline at end of file
diff --git a/kernel/liteos_m/port/mem_arch.c b/kernel/liteos_m/port/mem_arch.c
new file mode 100644
index 0000000..5cb3b04
--- /dev/null
+++ b/kernel/liteos_m/port/mem_arch.c
@@ -0,0 +1,59 @@
+#include "include.h"
+#include "arm_arch.h"
+#include <string.h>
+
+#include "sys_rtos.h"
+#include "uart_pub.h"
+#include "mem_pub.h"
+#include "rtos_pub.h"
+
+INT32 os_memcmp(const void *s1, const void *s2, UINT32 n)
+{
+    return memcmp(s1, s2, (unsigned int)n);
+}
+
+void *os_memmove(void *out, const void *in, UINT32 n)
+{
+    return memmove(out, in, n);
+}
+
+void *os_memcpy(void *out, const void *in, UINT32 n)
+{
+    return memcpy(out, in, n);
+}
+
+void *os_memset(void *b, int c, UINT32 len)
+{
+    return (void *)memset(b, c, (unsigned int)len);
+}
+
+int os_memcmp_const(const void *a, const void *b, size_t len)
+{
+    return memcmp(a, b, len);
+}
+
+void *os_realloc(void *ptr, size_t size)
+{
+	return beken_realloc(ptr, size);
+}
+
+void *os_malloc(size_t size)
+{
+    return (void *)beken_malloc(size);
+}
+
+void * os_zalloc(size_t size)
+{
+	void *n = (void *)os_malloc(size);
+
+	if (n)
+		os_memset(n, 0, size);
+	return n;
+}
+
+void os_free(void *ptr)
+{
+	beken_free(ptr);
+}
+// EOF
+
diff --git a/kernel/liteos_m/port/platform_stub.c b/kernel/liteos_m/port/platform_stub.c
new file mode 100644
index 0000000..bb38d37
--- /dev/null
+++ b/kernel/liteos_m/port/platform_stub.c
@@ -0,0 +1,84 @@
+/**
+ ******************************************************************************
+ * @file    platform_init.c
+ * @version V1.0.0
+ * @date    05-May-2014
+ * @brief   This file provide functions called by _BK_ to drive stm32f2xx
+ *          platform: - e.g. power save, reboot, platform initialize
+ ******************************************************************************
+ *  UNPUBLISHED PROPRIETARY SOURCE CODE
+ *  Copyright (c) 2016 BEKEN Inc.
+ *
+ *  The contents of this file may not be disclosed to third parties, copied or
+ *  duplicated in any form, in whole or in part, without the prior written
+ *  permission of BEKEN Corporation.
+ ******************************************************************************
+ */
+#include "include.h" 
+#include <sys/stat.h>
+#include <sys/times.h>
+#include <sys/unistd.h>
+
+#include "sys_rtos.h"
+#include "mem_pub.h"
+#include "uart_pub.h"
+#include "rtos_pub.h"
+
+/************** wrap C library functions **************/
+void * __wrap_malloc (size_t size)
+{
+	return os_malloc(size);
+}
+
+void * __wrap__malloc_r (void *p, size_t size)
+{
+	
+	return os_malloc(size);
+}
+
+void __wrap_free (void *pv)
+{
+	os_free(pv);
+}
+
+void * __wrap_calloc (size_t a, size_t b)
+{
+	void *pvReturn;
+
+    pvReturn = os_malloc( a*b );
+    if (pvReturn)
+    {
+        os_memset(pvReturn, 0, a*b);
+    }
+
+    return pvReturn;
+}
+
+void * __wrap_realloc (void* pv, size_t size)
+{
+	return os_realloc(pv, size);
+}
+
+void __wrap__free_r (void *p, void *x)
+{
+  __wrap_free(x);
+}
+
+void* __wrap__realloc_r (void *p, void* x, size_t sz)
+{
+  return __wrap_realloc (x, sz);
+}
+
+void * __wrap_zalloc(size_t size)
+{
+	return os_zalloc(size);
+}
+
+void __assert_func(const char *file, int line, const char *func, const char *failedexpr)
+{
+	os_printf("%s %d func %s expr %s\n", file, line, func, failedexpr);
+	ASSERT(0);
+}
+
+// eof
+
diff --git a/kernel/liteos_m/port/port.c b/kernel/liteos_m/port/port.c
new file mode 100644
index 0000000..604eb65
--- /dev/null
+++ b/kernel/liteos_m/port/port.c
@@ -0,0 +1,339 @@
+/*
+    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
+    All rights reserved
+*/
+
+/*-----------------------------------------------------------
+ * Implementation of functions defined in portable.h for the ST STR91x ARM9
+ * port.
+ *----------------------------------------------------------*/
+
+/* Standard includes. */
+#include <stdlib.h>
+#include <assert.h>
+#include "sys_rtos.h"
+#include "include.h"
+#include "ke_event.h"
+#include "fake_clock_pub.h"
+#include "osk_revision.h"
+#include "portmacro.h"
+
+#if (NX_POWERSAVE)
+#include "ps.h"
+#endif //(NX_POWERSAVE)
+
+/*-----------------------------------------------------------*/
+uint32_t platform_is_irq_enable( void )
+{
+    uint32_t interrupt;
+
+    __asm volatile(
+		"MRS %0,CPSR\n"
+		"AND %0,%0,#0xC0\n"
+		:"=r" (interrupt)
+		:
+		:"memory"
+	);
+
+    return (!(interrupt & ARM968_IRQ_ENABLE));
+}
+
+/*-----------------------------------------------------------*/
+uint32_t platform_is_fiq_enable( void )
+{
+    uint32_t interrupt;
+
+    __asm volatile(
+		"MRS %0,CPSR\n"
+		"AND %0,%0,#0xC0\n"
+		:"=r" (interrupt)
+		:
+		:"memory"
+	);
+
+    return (!(interrupt & ARM968_FIQ_ENABLE));
+}
+
+/*-----------------------------------------------------------*/
+void printf_lr_register(void)
+{
+    uint32_t value;
+
+    __asm volatile(
+		"MOV %0,lr\n"
+		:"=r" (value)
+		:
+		:"memory"
+	);
+
+	os_printf("lr:%x\r\n", value);
+}
+
+uint32_t platform_is_in_irq_context( void )
+{
+    uint32_t mode;
+
+    __asm volatile(
+		"MRS %0,CPSR\n"
+		"AND %0,%0,#0x1f\n"
+		:"=r" (mode)
+		:
+		:"memory"
+	);
+
+    return (ARM968_IRQ_MODE == mode);
+}
+
+/*-----------------------------------------------------------*/
+uint32_t platform_is_in_fiq_context( void )
+{
+    uint32_t mode;
+
+    __asm volatile(
+		"MRS %0,CPSR\n"
+		"AND %0,%0,#0x1f\n"
+		:"=r" (mode)
+		:
+		:"memory"
+	);
+
+    return (ARM968_FIQ_MODE == mode);
+}
+
+/*-----------------------------------------------------------*/
+uint32_t platform_entry_system_mode_zero_ptr(void)
+{
+	uint32_t system_md_value = 0xdf;
+	FUNCPTR boot = 0;
+
+    __asm volatile(
+		"MSR CPSR,%0\n"
+		:"=r" (system_md_value)
+		:
+		:"memory"
+	);
+
+	(*boot)();
+
+	return 0;
+}
+
+uint32_t platform_spsr_content( void )
+{
+    uint32_t mode;
+
+    __asm volatile(
+		"MRS %0,SPSR\n"
+		:"=r" (mode)
+		:
+		:"memory"
+	);
+
+    return mode;
+}
+
+/*-----------------------------------------------------------*/
+uint32_t platform_sp_content( void )
+{
+    uint32_t val;
+
+    __asm volatile(
+		"mov %0,SP\n"
+		:"=r" (val)
+		:
+		:"memory"
+	);
+
+    return val;
+}
+
+/*-----------------------------------------------------------*/
+uint32_t platform_cpsr_content( void )
+{
+    uint32_t mode;
+
+    __asm volatile(
+		"MRS %0,CPSR\n"
+		:"=r" (mode)
+		:
+		:"memory"
+	);
+
+    return mode;
+}
+
+uint32_t platform_interrupt_compare( void )
+{
+	uint32_t ret = 0;
+	uint32_t status = platform_cpsr_content();
+	uint32_t sta_irq = ((status & 0x80) >> 7);
+	uint32_t sta_fiq = ((status & 0x40) >> 6);
+
+	if(sta_fiq == sta_irq)
+	{
+		ret = 1;
+	}
+
+	return ret;
+}
+
+uint32_t platform_is_fiq_disable( void )
+{
+	uint32_t value = platform_cpsr_content();
+
+	return (value & 0x40);
+}
+
+uint32_t platform_is_irq_disable( void )
+{
+	uint32_t value = platform_cpsr_content();
+
+	return (value & 0x80);
+}
+
+uint32_t platform_is_in_interrupt_context( void )
+{
+    return ((platform_is_in_fiq_context())
+                || (platform_is_in_irq_context()));
+}
+
+void platform_enable_intc_at_restore_context(void)
+{
+	if(!platform_is_in_interrupt_context())
+		portENABLE_IRQ();
+
+	if(!platform_is_in_fiq_context())
+		portENABLE_FIQ();
+}
+
+void rtos_stack_overflow(char *taskname)
+{
+	os_printf("stack overflow: %s\r\n", taskname);
+	while(1);
+}
+
+#if CONTROL_IRQ_WITH_NORMAL_FUNCTION
+UINT32 HalIntLock(VOID)
+{
+	unsigned long temp;
+	unsigned long cpsr_val;
+
+	__asm volatile(
+	"mrs	%1, cpsr		@ \n"
+	"orr	%0, %1, #0xc0\n"
+	"msr	cpsr_c, %0"
+	: "=r" (temp),"=r" (cpsr_val)
+	:
+	: "memory");
+
+	return cpsr_val;
+}
+
+VOID HalIntRestore(UINT32 intSave)
+{
+	UINT32 cpsr_val = intSave;
+
+	__asm volatile(
+       "msr	cpsr_c, %0"
+	:
+	: "r" (cpsr_val)
+	: "memory");
+}
+
+/*
+ * Enable Interrupts
+ */
+void port_enable_interrupts_flag(int val)
+{
+	unsigned long cpsr_val;
+	unsigned long mask;
+
+	mask = val & ARM968_IF_MASK;
+	cpsr_val = platform_cpsr_content();
+	cpsr_val &= (~ARM968_IF_MASK);
+	cpsr_val += mask;
+
+	__asm volatile(
+	"msr	cpsr_c, %0"
+	::"r" (cpsr_val)
+	:);
+}
+
+void portENABLE_IRQ(void)
+{
+	unsigned long temp;
+	__asm volatile(
+	"mrs	%0, cpsr		@ local_irq_enable\n"
+       "bic	%0, %0, #0x80\n"
+       "msr	cpsr_c, %0"
+	: "=r" (temp)
+	:
+	: "memory");
+}
+
+void portENABLE_FIQ(void)
+{
+	unsigned long temp;
+	__asm volatile(
+	"mrs	%0, cpsr		@ local_irq_enable\n"
+       "bic	%0, %0, #0x40\n"
+       "msr	cpsr_c, %0"
+	: "=r" (temp)
+	:
+	: "memory");
+}
+
+/*
+ * Disable Interrupts
+ */
+int portDISABLE_FIQ(void)
+{
+	unsigned long temp;
+	unsigned long mask;
+
+	__asm volatile(
+	"mrs	%1, cpsr		@ local_irq_disable\n"
+	"orr	%0, %1, #0x40\n"
+	"msr	cpsr_c, %0"
+	: "=r" (temp),"=r" (mask)
+	:
+	: "memory");
+
+	return (!!(mask & 0x40));
+}
+
+int port_disable_interrupts_flag(void)
+{
+	unsigned long temp;
+	unsigned long mask;
+
+	__asm volatile(
+	"mrs	%1, cpsr		@ local_irq_disable\n"
+	"orr	%0, %1, #0xC0\n"
+	"msr	cpsr_c, %0"
+	: "=r" (temp),"=r" (mask)
+	:
+	: "memory");
+
+	return (mask & 0xC0);
+}
+
+int portDISABLE_IRQ(void)
+{
+	unsigned long temp;
+	unsigned long mask;
+
+	__asm volatile(
+	"mrs	%1, cpsr		@ local_irq_disable\n"
+	"orr	%0, %1, #0x80\n"
+	"msr	cpsr_c, %0"
+	: "=r" (temp),"=r" (mask)
+	:
+	: "memory");
+
+	return (!!(mask & 0x80));
+}
+#endif
+
+//eof
+
diff --git a/kernel/liteos_m/port/portmacro.h b/kernel/liteos_m/port/portmacro.h
new file mode 100644
index 0000000..8c704a5
--- /dev/null
+++ b/kernel/liteos_m/port/portmacro.h
@@ -0,0 +1,311 @@
+/*
+    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
+    All rights reserved
+
+    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
+
+    This file is part of the FreeRTOS distribution.
+
+    FreeRTOS is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License (version 2) as published by the
+    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
+
+    ***************************************************************************
+    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
+    >>!   distribute a combined work that includes FreeRTOS without being   !<<
+    >>!   obliged to provide the source code for proprietary components     !<<
+    >>!   outside of the FreeRTOS kernel.                                   !<<
+    ***************************************************************************
+
+    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
+    link: http://www.freertos.org/a00114.html
+
+    ***************************************************************************
+     *                                                                       *
+     *    FreeRTOS provides completely free yet professionally developed,    *
+     *    robust, strictly quality controlled, supported, and cross          *
+     *    platform software that is more than just the market leader, it     *
+     *    is the industry's de facto standard.                               *
+     *                                                                       *
+     *    Help yourself get started quickly while simultaneously helping     *
+     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
+     *    tutorial book, reference manual, or both:                          *
+     *    http://www.FreeRTOS.org/Documentation                              *
+     *                                                                       *
+    ***************************************************************************
+
+    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
+    the FAQ page "My application does not run, what could be wrong?".  Have you
+    defined configASSERT()?
+
+    http://www.FreeRTOS.org/support - In return for receiving this top quality
+    embedded software for free we request you assist our global community by
+    participating in the support forum.
+
+    http://www.FreeRTOS.org/training - Investing in training allows your team to
+    be as productive as possible as early as possible.  Now you can receive
+    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
+    Ltd, and the world's leading authority on the world's leading RTOS.
+
+    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
+    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
+    compatible FAT file system, and our tiny thread aware UDP/IP stack.
+
+    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
+    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
+
+    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
+    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
+    licenses offer ticketed support, indemnification and commercial middleware.
+
+    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
+    engineered and independently SIL3 certified version for use in safety and
+    mission critical applications that require provable dependability.
+
+    1 tab == 4 spaces!
+*/
+#ifndef __PORTMACRO_H__
+#define __PORTMACRO_H__
+
+/*-----------------------------------------------------------
+ * Port specific definitions.
+ *
+ * The settings in this file configure FreeRTOS correctly for the
+ * given hardware and compiler.
+ *
+ * These settings should not be altered.
+ *-----------------------------------------------------------
+ */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <arch.h>
+
+/**
+ * for compiling beken378 library with thumb instruction set
+ * bellow four code blocks can't be implemented with macro or inline function
+ * portENABLE_IRQ/portENABLE_FIQ/portDISABLE_FIQ/portDISABLE_IRQ
+ * so declare these lables as extended function and implement them in port.c
+ *
+ * this feature is controled with CONTROL_IRQ_WITH_NORMAL_FUNCTION,
+ * and it is disabled as default
+ *
+ * steps to compile thumb instruction set library
+ * a. replace -marm with -mthumb
+ * b. enable macro CONTROL_IRQ_WITH_NORMAL_FUNCTION
+ */
+#define CONTROL_IRQ_WITH_NORMAL_FUNCTION    1
+
+/* Type definitions. */
+#define portCHAR			char
+#define portFLOAT			float
+#define portDOUBLE			double
+#define portLONG			long
+#define portSHORT			short
+#define portSTACK_TYPE		uint32_t
+#define portBASE_TYPE		long
+
+typedef portSTACK_TYPE StackType_t;
+typedef long BaseType_t;
+typedef unsigned long UBaseType_t;
+typedef uint32_t TickType_t;
+#define portMAX_DELAY ( TickType_t )        0xffffffffUL
+
+/* Constants required to setup the initial stack. */
+#define portINITIAL_SPSR 			    ( ( StackType_t ) 0x1f ) /* System mode, ARM mode, interrupts enabled. */
+#define portINSTRUCTION_SIZE	        ( ( StackType_t ) 4 )
+
+#define ARM968_SYS_MODE 	 	        0x1f
+#define ARM968_MODE_MASK 	 	        0x1f
+#define ARM968_IF_MASK       	        0xC0
+#define ARM968_IRQ_ENABLE    	        0x80
+#define ARM968_IF_MASK       	        0xC0
+#define ARM968_FIQ_ENABLE    	        0x40
+#define ARM968_IRQ_MODE      	        0x12
+#define ARM968_FIQ_MODE     	        0x11
+
+/* Constants required to handle critical sections. */
+#define portNO_CRITICAL_NESTING 		((uint32_t ) 0 )
+
+/*-----------------------------------------------------------*/
+enum arm_mode {
+	ARM_MODE_USR = 16,
+	ARM_MODE_FIQ = 17,
+	ARM_MODE_IRQ = 18,
+	ARM_MODE_SVC = 19,
+	ARM_MODE_MON = 22,
+	ARM_MODE_ABT = 23,
+	ARM_MODE_HYP = 26,
+	ARM_MODE_UND = 27,
+	ARM_MODE_1176_MON = 28,
+	ARM_MODE_SYS = 31,
+
+	ARM_MODE_THREAD = 0,
+	ARM_MODE_USER_THREAD = 1,
+	ARM_MODE_HANDLER = 2,
+
+	ARMV8_64_EL0T = 0x0,
+	ARMV8_64_EL1T = 0x4,
+	ARMV8_64_EL1H = 0x5,
+	ARMV8_64_EL2T = 0x8,
+	ARMV8_64_EL2H = 0x9,
+	ARMV8_64_EL3T = 0xC,
+	ARMV8_64_EL3H = 0xD,
+
+	ARM_MODE_ANY = -1
+};
+
+/*-----------------------------------------------------------*/
+/* Critical section handling. */
+void vPortEnterCritical( void );
+void vPortExitCritical( void );
+
+#define portENTER_CRITICAL()        do{     \
+                                                GLOBAL_INT_DECLARATION();\
+                                                GLOBAL_INT_DISABLE(); 
+#define portEXIT_CRITICAL()                 \
+                                                GLOBAL_INT_RESTORE();\
+                                      }while(0)
+
+/*
+ * Enable Interrupts
+ */	
+#ifdef CONTROL_IRQ_WITH_NORMAL_FUNCTION
+extern void portENABLE_IRQ(void);
+extern void portENABLE_FIQ(void);
+extern int portDISABLE_FIQ(void);
+extern int portDISABLE_IRQ(void);
+
+extern int port_disable_interrupts_flag(void);
+extern void port_enable_interrupts_flag(int val);
+#else
+#define portENABLE_IRQ()					\
+	({							            \
+		unsigned long temp;				    \
+		__asm volatile(					    \
+		"mrs	%0, cpsr		@ local_irq_enable\n"	\
+	       "bic	%0, %0, #0x80\n"					    \
+	       "msr	cpsr_c, %0"					            \
+		: "=r" (temp)						            \
+		:							                    \
+		: "memory");						            \
+	})
+	
+#define port_enable_interrupts_flag(val)					\
+	({							              \
+		unsigned long temp;				\
+		unsigned long mask;				\
+		mask = val & 0xC0;				\
+		__asm volatile(					\
+		"mrs	%0, cpsr		@ local_irq_enable\n"	\
+	       "bic	%0, %0, %1\n"				        	\
+	       "msr	cpsr_c, %0"					            \
+		: "=r" (temp)						            \
+		: "r" (mask)				                    \
+		: );						            \
+	})
+	
+#define portENABLE_FIQ()					\
+	({							              \
+		unsigned long temp;				\
+		__asm volatile(					\
+		"mrs	%0, cpsr		@ local_irq_enable\n"	\
+	       "bic	%0, %0, #0x40\n"					\
+	       "msr	cpsr_c, %0"					       \
+		: "=r" (temp)						       \
+		:							              \
+		: "memory");						       \
+	})
+	
+static inline  int portDISABLE_FIQ(void)
+{						                     
+	unsigned long temp;				       
+	unsigned long mask;		
+	
+	__asm volatile(					
+	"mrs	%1, cpsr		@ local_irq_disable\n"	
+	"orr	%0, %1, #0x40\n"					
+	"msr	cpsr_c, %0"					       
+	: "=r" (temp),"=r" (mask)						       
+	:							              
+	: "memory");		
+
+	return (!!(mask & 0x40));
+}
+
+static inline  int port_disable_interrupts_flag(void)
+{						                     
+	unsigned long temp;				       
+	unsigned long mask;		
+	
+	__asm volatile(					
+	"mrs	%1, cpsr		@ local_irq_disable\n"	
+	"orr	%0, %1, #0xC0\n"					
+	"msr	cpsr_c, %0"					       
+	: "=r" (temp),"=r" (mask)						       
+	:							              
+	: "memory");		
+
+	return (mask & 0xC0);
+}
+
+static inline  int portDISABLE_IRQ(void)
+{						                     
+	unsigned long temp;				       
+	unsigned long mask;		
+	
+	__asm volatile(					
+	"mrs	%1, cpsr		@ local_irq_disable\n"	
+	"orr	%0, %1, #0x80\n"					
+	"msr	cpsr_c, %0"					       
+	: "=r" (temp),"=r" (mask)						       
+	:							              
+	: "memory");		
+
+	return (!!(mask & 0x80));
+}
+#endif
+
+extern uint32_t platform_is_in_interrupt_context( void );
+extern uint32_t platform_is_in_fiq_context( void );
+extern uint32_t platform_is_in_irq_context( void );
+extern uint32_t platform_interrupt_compare( void );
+
+#define portENABLE_INTERRUPTS()			do{		\
+												if(platform_is_in_fiq_context())\
+													break;\
+												if(platform_is_in_irq_context()) {\
+													portENABLE_FIQ();\
+													break;\
+												}\
+												portENABLE_IRQ();\
+												portENABLE_FIQ();\
+										    }while(0)
+            
+										    
+/*
+ * Disable Interrupts
+ */
+#define portDISABLE_INTERRUPTS()		do{		\
+												if(platform_is_in_fiq_context())\
+													break;\
+												if(platform_is_in_irq_context()) {\
+													portDISABLE_FIQ();\
+													break;\
+												}\
+												portDISABLE_FIQ();\
+												portDISABLE_IRQ();\
+										    }while(0)
+
+uint32_t platform_is_irq_disable( void );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PORTMACRO_H_ */
+// eof
diff --git a/kernel/liteos_m/port/rtos_pub.c b/kernel/liteos_m/port/rtos_pub.c
new file mode 100644
index 0000000..7497aba
--- /dev/null
+++ b/kernel/liteos_m/port/rtos_pub.c
@@ -0,0 +1,1177 @@
+#include "include.h"
+#include "rtos_pub.h"
+
+#include "los_config.h"
+#include "los_context.h"
+#include "los_task.h"
+#include "los_queue.h"
+#include "los_sem.h"
+#include "los_mux.h"
+#include "los_memory.h"
+#include "los_interrupt.h"
+#include "los_swtmr.h"
+#include "bk_los_timer.h"
+
+/* OS_TASK_PRIORITY_HIGHEST and OS_TASK_PRIORITY_LOWEST is reserved for internal TIMER and IDLE task use only. */
+#define ISVALID_LOS_PRIORITY(losPrio) ((losPrio) > OS_TASK_PRIORITY_HIGHEST && (losPrio) < OS_TASK_PRIORITY_LOWEST)
+/**
+* @brief Enumerates thread states.
+*
+*/
+typedef enum {
+  /** The thread is inactive. */
+  osThreadInactive        =  0,
+  /** The thread is ready. */
+  osThreadReady           =  1,
+  /** The thread is running. */
+  osThreadRunning         =  2,
+  /** The thread is blocked. */
+  osThreadBlocked         =  3,
+  /** The thread is terminated. */
+  osThreadTerminated      =  4,
+  /** The thread is abnormal. */
+  osThreadError           = -1,
+  /** Reserved */
+  osThreadReserved        = 0x7FFFFFFF
+} osThreadState_t;
+  
+#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
+  /**
+  * @brief Enumerates timer permissions.
+  *
+  * @since 1.0
+  * @version 1.0
+  */
+  typedef enum	{
+	/** The timer is not allowed to wake up the RTOS. */
+	osTimerRousesIgnore 	  = 	0,
+	/** The timer is allowed to wake up the RTOS. */
+	osTimerRousesAllow		  = 	1
+  } osTimerRouses_t;
+  
+  /**
+  * @brief Enumerates timer alignment modes.
+  *
+  */
+  typedef enum	{
+	/** The timer ignores alignment. */
+	osTimerAlignIgnore		  = 	0,
+	/** The timer allows alignment. */
+	osTimerAlignAllow		  = 	1
+  } osTimerAlign_t;
+#endif //(LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
+
+/******************************************************
+ *               Function Declarations
+ ******************************************************/
+uint32_t ms_to_tick_ratio = LOS_TICK_MS; // wangzhilei
+beken_time_t beken_time_offset = 0;
+
+/******************************************************
+ *               Function Definitions
+ ******************************************************/
+OSStatus rtos_create_thread( beken_thread_t *thread, uint8_t priority, const char *name, 
+						beken_thread_function_t function, uint32_t stack_size, beken_thread_arg_t arg )
+{
+    uint32_t uwTid;
+    UINT32 uwRet = LOS_OK;
+	OSStatus ret;
+    LosTaskCB *pstTaskCB = NULL;
+    TSK_INIT_PARAM_S stTskInitParam = {NULL};
+    UINT16 usPriority;
+
+	ret = kNoErr;
+    if (OS_INT_ACTIVE) {
+        ret = kGeneralErr;
+		goto tinit_exit;
+    }
+
+    usPriority = priority;
+    if (!ISVALID_LOS_PRIORITY(usPriority)) {
+        ret = kUnsupportedErr;/* unsupported priority */
+		goto tinit_exit;
+    }
+
+    stTskInitParam.pfnTaskEntry = (TSK_ENTRY_FUNC)function;
+    stTskInitParam.uwArg = (uint32_t)arg;
+    stTskInitParam.uwStackSize = stack_size;
+    stTskInitParam.pcName = (CHAR *)name;
+    stTskInitParam.usTaskPrio = usPriority;
+
+    uwRet = LOS_TaskCreate((UINT32 *)&uwTid, &stTskInitParam);
+	bk_printf("[wzl_debug]LOS_TaskCreate:%s:%d\r\n", name, uwRet);
+	if(LOS_OK != uwRet)
+	{
+		ret = kGeneralErr;
+		goto tinit_exit;
+	}
+    pstTaskCB = OS_TCB_FROM_TID(uwTid);
+
+	if(thread)
+	{
+		*thread = (beken_thread_t *)pstTaskCB;
+	}
+
+tinit_exit:
+	ASSERT(LOS_OK == uwRet);
+	return ret;
+}
+
+OSStatus rtos_delete_thread(beken_thread_t *thread)
+{
+    UINT32 uwRet;
+	uint32_t selfTid;
+    LosTaskCB *pstTaskCB = NULL;
+
+    if (OS_INT_ACTIVE) {
+        return kUnknownErr;
+    }
+
+    if (thread && (*thread == NULL)) {
+        return kParamErr;
+    }
+
+	if(NULL == thread)
+	{
+	    selfTid = LOS_CurTaskIDGet();
+	    pstTaskCB = OS_TCB_FROM_TID(selfTid);
+	}
+	else
+	{
+	    pstTaskCB = (LosTaskCB *)*thread;
+	}
+
+    uwRet = LOS_TaskDelete(pstTaskCB->taskID);
+
+    switch (uwRet) {
+        case LOS_ERRNO_TSK_OPERATE_IDLE:
+        case LOS_ERRNO_TSK_SUSPEND_SWTMR_NOT_ALLOWED:
+        case LOS_ERRNO_TSK_ID_INVALID:
+            return kParamErr;
+
+        case LOS_ERRNO_TSK_NOT_CREATED:
+            return kNoResourcesErr;
+
+        default:
+            return kNoErr;
+    }
+}
+
+uint32_t _thread_get_status(beken_thread_t *thread)
+{
+    UINT16 taskStatus;
+    osThreadState_t stState;
+    LosTaskCB *pstTaskCB = NULL;
+
+	ASSERT(thread);
+    if (OS_INT_ACTIVE || *thread == NULL) {
+        return osThreadError;
+    }
+
+    pstTaskCB = (LosTaskCB *)*thread;
+    taskStatus = pstTaskCB->taskStatus;
+
+    if (taskStatus & OS_TASK_STATUS_RUNNING) {
+        stState = osThreadRunning;
+    } else if (taskStatus & OS_TASK_STATUS_READY) {
+        stState = osThreadReady;
+    } else if (taskStatus &
+        (OS_TASK_STATUS_DELAY | OS_TASK_STATUS_PEND | OS_TASK_STATUS_SUSPEND)) {
+        stState = osThreadBlocked;
+    } else if (taskStatus & OS_TASK_STATUS_UNUSED) {
+        stState = osThreadInactive;
+    } else {
+        stState = osThreadError;
+    }
+
+    return stState;
+}
+
+OSStatus rtos_thread_join(beken_thread_t *thread)
+{
+	ASSERT(thread);
+    while ( _thread_get_status( *thread ) != osThreadInactive )
+    {
+        rtos_delay_milliseconds(10);
+    }
+    
+    return kNoErr;
+}
+
+BOOL rtos_is_current_thread( beken_thread_t *thread )
+{
+    uint32_t selfTid = LOS_CurTaskIDGet();
+    LosTaskCB *tcb = OS_TCB_FROM_TID(selfTid);
+	
+    if ( tcb == (LosTaskCB *)*thread )
+    {
+        return true;
+    }
+    else
+    {
+        return false;
+    }
+}
+
+beken_thread_t *rtos_get_current_thread(void)
+{
+    uint32_t selfTid = LOS_CurTaskIDGet();
+    LosTaskCB *tcb = OS_TCB_FROM_TID(selfTid);
+	
+    return (beken_thread_t *)tcb;
+}
+
+/* Re-write vTaskList to add a buffer size parameter */
+OSStatus rtos_print_threads_status( char* pcWriteBuffer, int xWriteBufferLen )
+{
+    return kNoErr;
+}
+
+OSStatus rtos_check_stack(void)
+{
+    //  TODO: Add stack checking here.
+    return kNoErr;
+}
+
+OSStatus rtos_thread_force_awake( beken_thread_t *thread )
+{
+    return kNoErr;
+}
+
+void rtos_thread_sleep(uint32_t seconds)
+{
+    UINT32 uwRet = LOS_OK;
+	
+	uwRet = LOS_TaskDelay(seconds * LOS_TICKS_PER_SECOND);
+	(void)uwRet;
+}
+
+void rtos_suspend_thread(beken_thread_t *thread)
+{
+    UINT32 uwRet;
+    LosTaskCB *pstTaskCB = NULL;
+	beken_thread_t bk_thread;
+
+    if (OS_INT_ACTIVE) {
+        return;
+    }
+
+	bk_thread = *thread;
+    if (bk_thread == NULL) {
+        bk_thread = rtos_get_current_thread();
+    }
+
+    pstTaskCB = (LosTaskCB *)bk_thread;
+    uwRet = LOS_TaskSuspend(pstTaskCB->taskID);
+    switch (uwRet) {
+        case LOS_ERRNO_TSK_OPERATE_IDLE:
+        case LOS_ERRNO_TSK_SUSPEND_SWTMR_NOT_ALLOWED:
+        case LOS_ERRNO_TSK_ID_INVALID:
+            return;
+
+        case LOS_ERRNO_TSK_NOT_CREATED:
+        case LOS_ERRNO_TSK_ALREADY_SUSPENDED:
+        case LOS_ERRNO_TSK_SUSPEND_LOCKED:
+            return;
+
+        default:
+            return;
+    }
+}
+
+void rtos_resume_thread(beken_thread_t *thread)
+{
+    UINT32 uwRet;
+    LosTaskCB *pstTaskCB = NULL;
+	beken_thread_t bk_thread;
+
+    if (OS_INT_ACTIVE) {
+        return;
+    }
+
+	bk_thread = *thread;
+    if (bk_thread == NULL) {
+        bk_thread = rtos_get_current_thread();
+    }
+
+
+    pstTaskCB = (LosTaskCB *)bk_thread;
+    uwRet = LOS_TaskResume(pstTaskCB->taskID);
+
+    switch (uwRet) {
+        case LOS_ERRNO_TSK_ID_INVALID:
+            return;
+
+        case LOS_ERRNO_TSK_NOT_CREATED:
+        case LOS_ERRNO_TSK_NOT_SUSPENDED:
+            return;
+
+        default:
+            return;
+    }
+}
+
+uint32_t rtos_get_tick_count(void)
+{
+	return (uint32_t)LOS_TickCountGet();
+}
+
+uint32_t beken_tick_ms(void)
+{
+	return ms_to_tick_ratio;
+}
+
+OSStatus beken_time_get_time(beken_time_t* time_ptr)
+{
+    *time_ptr = (beken_time_t) ( LOS_TickCountGet() * ms_to_tick_ratio ) + beken_time_offset;
+    return kNoErr;
+}
+
+OSStatus beken_time_set_time(beken_time_t* time_ptr)
+{
+    beken_time_offset = *time_ptr - (beken_time_t) ( LOS_TickCountGet() * ms_to_tick_ratio );
+    return kNoErr;
+}
+
+OSStatus rtos_init_semaphore(beken_semaphore_t *semaphore, int max_count )
+{
+    return rtos_init_semaphore_adv(semaphore, max_count, 0);
+}
+
+OSStatus rtos_init_semaphore_adv(beken_semaphore_t *semaphore, int max_count, int init_count)
+{
+    UINT32 uwRet;
+    UINT32 uwSemId;
+
+    if (OS_INT_ACTIVE) {
+        *semaphore = (beken_semaphore_t)NULL;
+		goto init_aexit;
+    }
+
+    if (1 == max_count) {
+        uwRet = LOS_BinarySemCreate((UINT16)init_count, &uwSemId);
+    } else {
+        uwRet = LOS_SemCreate((UINT16)init_count, &uwSemId);
+    }
+	ASSERT(LOS_OK == uwRet);
+
+    if (uwRet == LOS_OK) {
+        *semaphore = (beken_semaphore_t)(GET_SEM(uwSemId));
+    } else {
+        *semaphore = (beken_semaphore_t)NULL;
+    }
+
+init_aexit:
+    return ( *semaphore != NULL ) ? kNoErr : kGeneralErr;
+}
+
+OSStatus rtos_get_semaphore(beken_semaphore_t *semaphore, uint32_t timeout_ms )
+{
+    UINT32 uwRet;
+    uint32_t timeout;
+
+	ASSERT(semaphore);
+    if(timeout_ms == BEKEN_WAIT_FOREVER)
+        timeout = LOS_WAIT_FOREVER;
+    else
+        timeout = timeout_ms / ms_to_tick_ratio;     
+
+    if (*semaphore == NULL) {
+        return kParamErr;
+    }
+
+    if (OS_INT_ACTIVE && (timeout != LOS_NO_WAIT)) {
+        return kUnknownErr;
+    }
+
+    uwRet = LOS_SemPend(((LosSemCB *)*semaphore)->semID, timeout);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_SEM_TIMEOUT) {
+        return kTimeoutErr;
+    } else if (uwRet == LOS_ERRNO_SEM_INVALID) {
+        return kParamErr;
+    } else if (uwRet == LOS_ERRNO_SEM_PEND_INTERR) {
+        return kInProgressErr;
+    } else {
+        return kGeneralErr;
+    } 
+}
+
+int rtos_get_sema_count(beken_semaphore_t *semaphore )
+{
+    uint32_t uwIntSave;
+    uint32_t uwCount;
+
+    if (OS_INT_ACTIVE) {
+        return 0;
+    }
+
+	ASSERT(semaphore);
+
+    if (*semaphore == NULL) {
+        return 0;
+    }
+
+    uwIntSave = LOS_IntLock();
+    uwCount = ((LosSemCB *)*semaphore)->semCount;
+    LOS_IntRestore(uwIntSave);
+
+    return uwCount;
+}
+
+int rtos_set_semaphore(beken_semaphore_t *semaphore )
+{
+    UINT32 uwRet;
+
+	ASSERT(semaphore);
+
+    if (*semaphore == NULL) {
+        return kParamErr;
+    }
+
+    uwRet = LOS_SemPost(((LosSemCB *)*semaphore)->semID);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_SEM_INVALID) {
+        return kParamErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_deinit_semaphore(beken_semaphore_t *semaphore )
+{
+    UINT32 uwRet;
+
+    if (OS_INT_ACTIVE) {
+        return kGeneralErr;
+    }
+
+	ASSERT(semaphore);
+
+    if (*semaphore == NULL) {
+        return kParamErr;
+    }
+
+    uwRet = LOS_SemDelete(((LosSemCB *)*semaphore)->semID);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_SEM_INVALID) {
+        return kParamErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+void rtos_enter_critical(void)
+{
+}
+
+void rtos_exit_critical(void)
+{
+}
+
+OSStatus rtos_init_mutex(beken_mutex_t *mutex)
+{
+    UINT32 uwRet;
+    UINT32 uwMuxId;
+
+    if (OS_INT_ACTIVE) {
+        *mutex = NULL;
+		goto init_exit;
+    }
+
+	ASSERT(mutex);
+
+    uwRet = LOS_MuxCreate(&uwMuxId);
+    if (uwRet == LOS_OK) {
+        *mutex = (beken_mutex_t)(GET_MUX(uwMuxId));
+    } else {
+        *mutex = (beken_mutex_t)NULL;
+    }
+	ASSERT(LOS_OK == uwRet);
+
+init_exit:
+    if ( *mutex == NULL )
+    {
+        return kGeneralErr;
+    }
+
+    return kNoErr;
+}
+
+OSStatus rtos_trylock_mutex(beken_mutex_t *mutex)
+{
+    UINT32 uwRet;
+
+    if (*mutex == NULL) {
+        return kParamErr;
+    }
+
+	ASSERT(mutex);
+
+    uwRet = LOS_MuxPend(((LosMuxCB *)*mutex)->muxID, 0);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_MUX_TIMEOUT) {
+        return kTimeoutErr;
+    } else if (uwRet == LOS_ERRNO_MUX_INVALID) {
+        return kParamErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_lock_mutex(beken_mutex_t *mutex)
+{
+    UINT32 uwRet;
+
+	ASSERT(mutex);
+
+    if (*mutex == NULL) {
+        return kParamErr;
+    }
+
+    uwRet = LOS_MuxPend(((LosMuxCB *)*mutex)->muxID, LOS_WAIT_FOREVER);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_MUX_TIMEOUT) {
+        return kTimeoutErr;
+    } else if (uwRet == LOS_ERRNO_MUX_INVALID) {
+        return kParamErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_unlock_mutex(beken_mutex_t *mutex)
+{
+    UINT32 uwRet;
+
+    if (*mutex == NULL) {
+        return kParamErr;
+    }
+
+	ASSERT(mutex);
+
+    uwRet = LOS_MuxPost(((LosMuxCB *)*mutex)->muxID);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_deinit_mutex(beken_mutex_t *mutex)
+{
+    UINT32 uwRet;
+
+    if (OS_INT_ACTIVE) {
+        return kStateErr;
+    }
+
+	ASSERT(mutex);
+
+    if (*mutex == NULL) {
+        return kParamErr;
+    }
+
+    uwRet = LOS_MuxDelete(((LosMuxCB *)*mutex)->muxID);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_MUX_INVALID) {
+        return kParamErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_init_queue( beken_queue_t *queue, const char* name, uint32_t msg_size, uint32_t msg_count )
+{
+    UINT32 uwRet;
+    UINT32 uwQueueID;
+	OSStatus ret = kNoErr;
+
+	ASSERT(queue);
+
+    if (0 == msg_count || 0 == msg_size || OS_INT_ACTIVE) {
+        *queue = (beken_queue_t)NULL;
+		ret = kParamErr;
+		goto qinit_exit;
+    }
+
+    uwRet = LOS_QueueCreate((char *)name, (UINT16)msg_count, &uwQueueID, 0, (UINT16)msg_size);
+	bk_printf("[wzl_debug]LOS_QueueCreate:%s:%d\r\n", name, uwRet);
+    if (uwRet == LOS_OK) {
+        *queue = (beken_queue_t)(GET_QUEUE_HANDLE(uwQueueID));
+    } else {
+        *queue = (beken_queue_t)NULL;
+		ret = kNoResourcesErr;
+    }
+	ASSERT(LOS_OK == uwRet);
+
+qinit_exit:
+    return ret;
+}
+
+OSStatus rtos_push_to_queue( beken_queue_t *queue, void* msg_ptr, uint32_t timeout_ms )
+{
+    UINT32 uwRet;
+    uint32_t timeout;
+    uint32_t uwBufferSize;
+    LosQueueCB *pstQueue = (LosQueueCB *)*queue;
+
+	ASSERT(queue);
+
+    if(timeout_ms == BEKEN_WAIT_FOREVER)
+        timeout = LOS_WAIT_FOREVER;
+    else
+        timeout = timeout_ms / ms_to_tick_ratio;    
+
+    if (pstQueue == NULL || msg_ptr == NULL || ((OS_INT_ACTIVE) && (0 != timeout))) {
+        return kParamErr;
+    }
+    if (pstQueue->queueSize < sizeof(uint32_t)) {
+        return kParamErr;
+    }
+    uwBufferSize = (uint32_t)(pstQueue->queueSize - sizeof(uint32_t));
+    uwRet = LOS_QueueWriteCopy((uint32_t)pstQueue->queueID, (void *)msg_ptr, uwBufferSize, timeout);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_QUEUE_INVALID || uwRet == LOS_ERRNO_QUEUE_NOT_CREATE) {
+        return kParamErr;
+    } else if (uwRet == LOS_ERRNO_QUEUE_TIMEOUT) {
+        return kTimeoutErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_push_to_queue_front( beken_queue_t *queue, void *msg_ptr, uint32_t timeout_ms )
+{
+    UINT32 uwRet;
+    uint32_t timeout;
+    uint32_t uwBufferSize;
+    LosQueueCB *pstQueue = (LosQueueCB *)*queue;
+
+	ASSERT(queue);
+
+    if(timeout_ms == BEKEN_WAIT_FOREVER)
+        timeout = LOS_WAIT_FOREVER;
+    else
+        timeout = timeout_ms / ms_to_tick_ratio;    
+
+    if (pstQueue == NULL || msg_ptr == NULL || ((OS_INT_ACTIVE) && (0 != timeout))) {
+        return kParamErr;
+    }
+    if (pstQueue->queueSize < sizeof(uint32_t)) {
+        return kParamErr;
+    }
+    uwBufferSize = (uint32_t)(pstQueue->queueSize - sizeof(uint32_t));
+    uwRet = LOS_QueueWriteHead((uint32_t)pstQueue->queueID, (void *)msg_ptr, uwBufferSize, timeout);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_QUEUE_INVALID || uwRet == LOS_ERRNO_QUEUE_NOT_CREATE) {
+        return kParamErr;
+    } else if (uwRet == LOS_ERRNO_QUEUE_TIMEOUT) {
+        return kTimeoutErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_pop_from_queue( beken_queue_t *queue, void *msg_ptr, uint32_t timeout_ms )
+{
+    UINT32 uwRet;
+    uint32_t timeout;
+    UINT32 uwBufferSize;
+    LosQueueCB *pstQueue = (LosQueueCB *)*queue;
+
+	ASSERT(queue);
+
+    if(timeout_ms == BEKEN_WAIT_FOREVER)
+        timeout = LOS_WAIT_FOREVER;
+    else
+        timeout = timeout_ms / ms_to_tick_ratio;    
+
+    if (pstQueue == NULL || msg_ptr == NULL || ((OS_INT_ACTIVE) && (0 != timeout))) {
+        return kParamErr;
+    }
+
+    uwBufferSize = (uint32_t)(pstQueue->queueSize - sizeof(uint32_t));
+    uwRet = LOS_QueueReadCopy((uint32_t)pstQueue->queueID, msg_ptr, &uwBufferSize, timeout);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_QUEUE_INVALID || uwRet == LOS_ERRNO_QUEUE_NOT_CREATE) {
+        return kParamErr;
+    } else if (uwRet == LOS_ERRNO_QUEUE_TIMEOUT) {
+        return kTimeoutErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_deinit_queue(beken_queue_t *queue)
+{
+    UINT32 uwRet;
+    LosQueueCB *pstQueue = (LosQueueCB *)*queue;
+
+	ASSERT(queue);
+
+    if (pstQueue == NULL) {
+        return kParamErr;
+    }
+
+    if (OS_INT_ACTIVE) {
+        return kGeneralErr;
+    }
+
+    uwRet = LOS_QueueDelete((uint32_t)pstQueue->queueID);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_QUEUE_NOT_FOUND || uwRet == LOS_ERRNO_QUEUE_NOT_CREATE) {
+        return kParamErr;
+    } else {
+        return kUnknownErr;
+    }
+}
+
+uint32_t _queue_get_capacity(beken_queue_t *queue)
+{
+    uint32_t capacity;
+    LosQueueCB *pstQueue = (LosQueueCB *)*queue;
+
+    if (pstQueue == NULL) {
+        capacity = 0U;
+    } else {
+        capacity = pstQueue->queueLen;
+    }
+
+    return (capacity);
+}
+
+uint32_t _queue_get_count(beken_queue_t *queue)
+{
+    uint32_t count;
+    UINTPTR uwIntSave;
+    LosQueueCB *pstQueue = (LosQueueCB *)*queue;
+
+	ASSERT(queue);
+
+    if (pstQueue == NULL) {
+        count = 0U;
+    } else {
+        uwIntSave = LOS_IntLock();
+        count = (uint32_t)(pstQueue->readWriteableCnt[OS_QUEUE_READ]);
+        LOS_IntRestore(uwIntSave);
+    }
+    return count;
+}
+
+BOOL rtos_is_queue_full(beken_queue_t *queue)
+{
+	ASSERT(queue);
+    return ( _queue_get_capacity(queue) == _queue_get_count(queue) ) ? true : false;
+}
+
+BOOL rtos_is_queue_empty(beken_queue_t *queue)
+{
+	ASSERT(queue);
+    return ( 0 == _queue_get_count(queue) ) ? true : false;
+}
+
+static void timer_callback2( void *handle )
+{
+    beken2_timer_t *timer = (beken2_timer_t *) handle;
+
+	if(BEKEN_MAGIC_WORD != timer->beken_magic)
+	{
+		return;
+	}
+    if ( timer->function )
+    {
+        timer->function( timer->left_arg, timer->right_arg );
+    }
+}
+
+static void timer_callback1( void *handle )
+{
+    beken_timer_t *timer = (beken_timer_t*) handle;
+
+    if ( timer->function )
+    {
+        timer->function( timer->arg);
+    }
+}
+
+OSStatus rtos_init_oneshot_timer( beken2_timer_t *timer, 
+									uint32_t time_ms, 
+									timer_2handler_t func,
+									void* larg, 
+									void* rarg )
+{
+    SWTMR_CTRL_S *pstSwtmr;
+	OSStatus ret = kNoErr;
+    UINT32 usSwTmrID;
+    UINT8 mode;
+
+	timer->handle = NULL;
+    if (NULL == func) {
+		ret = kParamErr;
+		goto tinit_exit;
+    }
+
+    mode = LOS_SWTMR_MODE_NO_SELFDELETE;
+	timer->beken_magic = BEKEN_MAGIC_WORD;
+	timer->function = func;
+	timer->left_arg = larg;
+	timer->right_arg = rarg;
+	
+#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
+    if (LOS_OK != LOS_SwtmrCreate(1, mode, (SWTMR_PROC_FUNC)timer_callback2, &usSwTmrID, (uint32_t)(UINTPTR)timer,
+        osTimerRousesAllow, osTimerAlignIgnore)) {
+        ret = kGeneralErr;
+		goto tinit_exit;
+    }
+#else
+    if (LOS_OK != LOS_SwtmrCreate(1, mode, (SWTMR_PROC_FUNC)func, &usSwTmrID, (uint32_t)(UINTPTR)larg)) {
+        ret = kGeneralErr;
+		goto tinit_exit;
+    }
+#endif
+
+	pstSwtmr = (SWTMR_CTRL_S *)OS_SWT_FROM_SID(usSwTmrID);
+    timer->handle = (void *)pstSwtmr;
+
+	if(pstSwtmr){
+		pstSwtmr->uwInterval = time_ms / ms_to_tick_ratio;
+	}
+
+tinit_exit:
+    return ret;
+}
+
+OSStatus rtos_start_oneshot_timer(beken2_timer_t *timer)
+{
+	return rtos_start_timer((beken_timer_t *)timer);
+}
+
+OSStatus rtos_deinit_oneshot_timer(beken2_timer_t *timer)
+{
+	timer->beken_magic = 0;
+	timer->left_arg = 0;
+	timer->right_arg = 0;
+	timer->function = NULL;
+	
+	return rtos_deinit_timer((beken_timer_t *)timer);
+}
+
+OSStatus rtos_stop_oneshot_timer(beken2_timer_t *timer)
+{
+    return rtos_stop_timer((beken_timer_t *)timer);
+}
+
+BOOL rtos_is_oneshot_timer_init(beken2_timer_t *timer)
+{
+    return (NULL != timer->handle) ? true : false;
+}
+
+BOOL rtos_is_oneshot_timer_running(beken2_timer_t *timer)
+{
+    return rtos_is_timer_running((beken_timer_t *)timer);
+}
+
+OSStatus rtos_oneshot_reload_timer(beken2_timer_t *timer)
+{
+    return rtos_start_timer((beken_timer_t *)timer);
+}
+
+OSStatus rtos_oneshot_reload_timer_ex(beken2_timer_t *timer,
+										uint32_t time_ms,
+										timer_2handler_t function,
+										void *larg,
+										void *rarg)
+{
+	return kUnsupportedErr;
+}
+
+OSStatus rtos_init_timer(beken_timer_t *timer, 
+									uint32_t time_ms, 
+									timer_handler_t func, 
+									void* argument )
+{
+    SWTMR_CTRL_S *pstSwtmr;
+	OSStatus ret = kNoErr;
+    UINT32 usSwTmrID;
+    UINT8 mode;
+
+	timer->handle = NULL;
+	
+    if (NULL == func) {
+		ret = kParamErr;
+		goto tinit_exit;
+    }
+
+    mode = LOS_SWTMR_MODE_PERIOD;
+	timer->function = func;
+	timer->arg = argument;
+	
+#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
+    if (LOS_OK != LOS_SwtmrCreate(1, mode, (SWTMR_PROC_FUNC)timer_callback1, &usSwTmrID, (uint32_t)(UINTPTR)timer,
+        osTimerRousesAllow, osTimerAlignIgnore)) {
+		ret = kGeneralErr;
+		goto tinit_exit;
+    }
+#else
+    if (LOS_OK != LOS_SwtmrCreate(1, mode, (SWTMR_PROC_FUNC)timer_callback1, &usSwTmrID, (uint32_t)(UINTPTR)timer)) {
+		ret = kGeneralErr;
+		goto tinit_exit;
+    }
+#endif
+
+    timer->handle = (void *)OS_SWT_FROM_SID(usSwTmrID);
+	pstSwtmr = (SWTMR_CTRL_S *)timer->handle;
+
+
+	if(pstSwtmr){
+		pstSwtmr->uwInterval = time_ms / ms_to_tick_ratio;
+	}
+
+tinit_exit:
+    return ret;
+}
+
+OSStatus rtos_start_timer(beken_timer_t *timer)
+{
+    UINT32 uwRet;
+    SWTMR_CTRL_S *pstSwtmr;
+
+    if (NULL == timer) {
+        return kParamErr;
+    }
+
+    UINTPTR intSave = LOS_IntLock();
+    pstSwtmr = (SWTMR_CTRL_S *)timer;
+    uwRet = LOS_SwtmrStart(pstSwtmr->usTimerID);
+    LOS_IntRestore(intSave);
+    if (LOS_OK == uwRet) {
+        return kNoErr;
+    } else if (LOS_ERRNO_SWTMR_ID_INVALID == uwRet) {
+        return kParamErr;
+    } else {
+        return kTimeoutErr;
+    }
+}
+
+OSStatus rtos_stop_timer(beken_timer_t *timer)
+{
+    UINT32 uwRet;
+    SWTMR_CTRL_S *pstSwtmr;
+
+    if (NULL == timer) {
+        return kParamErr;
+    }
+
+	pstSwtmr = (SWTMR_CTRL_S *)timer->handle;
+    uwRet = LOS_SwtmrStop(pstSwtmr->usTimerID);
+    if (LOS_OK == uwRet) {
+        return kNoErr;
+    } else if (LOS_ERRNO_SWTMR_ID_INVALID == uwRet) {
+        return kParamErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_reload_timer(beken_timer_t *timer)
+{
+    return rtos_start_timer(timer);
+}
+
+OSStatus rtos_change_period(beken_timer_t *timer, uint32_t time_ms)
+{
+    UINT32 uwRet;
+	UINTPTR intSave;
+    SWTMR_CTRL_S *pstSwtmr;
+	
+    if (NULL == timer) {
+        return kParamErr;
+    }
+	rtos_stop_timer(timer);
+
+    intSave = LOS_IntLock();
+    pstSwtmr = (SWTMR_CTRL_S *)timer->handle;
+    pstSwtmr->uwInterval = time_ms / ms_to_tick_ratio;
+    uwRet = LOS_SwtmrStart(pstSwtmr->usTimerID);
+    LOS_IntRestore(intSave);
+    if (LOS_OK == uwRet) {
+        return kNoErr;
+    } else if (LOS_ERRNO_SWTMR_ID_INVALID == uwRet) {
+        return kParamErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_deinit_timer(beken_timer_t *timer)
+{
+    UINT32 uwRet;
+    SWTMR_CTRL_S *pstSwtmr;
+
+	pstSwtmr = (SWTMR_CTRL_S *)timer->handle;
+    if (NULL == pstSwtmr) {
+        return kParamErr;
+    }
+
+    uwRet = LOS_SwtmrDelete(pstSwtmr->usTimerID);
+    if (LOS_OK == uwRet) {
+		timer->handle = NULL;
+		timer->arg = 0;
+		timer->function = NULL;
+        return kNoErr;
+    } else if (LOS_ERRNO_SWTMR_ID_INVALID == uwRet) {
+        return kParamErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+uint32_t rtos_get_timer_expiry_time(beken_timer_t *timer)
+{
+	uint32_t val;
+    UINTPTR intSave;
+    SWTMR_CTRL_S *pstSwtmr;
+
+	intSave = LOS_IntLock();
+    pstSwtmr = (SWTMR_CTRL_S *)timer->handle;
+    val = pstSwtmr->uwInterval;
+    LOS_IntRestore(intSave);
+	
+    return val;
+}
+
+uint32_t rtos_get_next_expire_time(void)
+{
+    return kGeneralErr;
+}
+
+uint32_t rtos_get_current_timer_count(void)
+{
+    return kGeneralErr;
+}
+
+BOOL rtos_is_timer_init(beken_timer_t *timer)
+{
+    return (NULL != timer->handle) ? true : false;
+}
+
+BOOL rtos_is_timer_running(beken_timer_t *timer)
+{
+    if (NULL == timer->handle) {
+        return 0;
+    }
+
+    return (OS_SWTMR_STATUS_TICKING == ((SWTMR_CTRL_S *)timer->handle)->ucState);
+}
+
+OSStatus rtos_init_event_flags( beken_event_flags_t* event_flags )
+{
+    UNUSED_PARAMETER( event_flags );
+	
+    return kUnsupportedErr;
+}
+
+OSStatus rtos_wait_for_event_flags( beken_event_flags_t* event_flags, uint32_t flags_to_wait_for, uint32_t* flags_set, beken_bool_t clear_set_flags, beken_event_flags_wait_option_t wait_option, uint32_t timeout_ms )
+{
+    UNUSED_PARAMETER( event_flags );
+    UNUSED_PARAMETER( flags_to_wait_for );
+    UNUSED_PARAMETER( flags_set );
+    UNUSED_PARAMETER( clear_set_flags );
+    UNUSED_PARAMETER( wait_option );
+    UNUSED_PARAMETER( timeout_ms );
+
+    return kUnsupportedErr;
+}
+
+OSStatus rtos_set_event_flags( beken_event_flags_t* event_flags, uint32_t flags_to_set )
+{
+    UNUSED_PARAMETER( event_flags );
+    UNUSED_PARAMETER( flags_to_set );
+	
+    return kUnsupportedErr;
+}
+
+OSStatus rtos_deinit_event_flags( beken_event_flags_t* event_flags )
+{
+    UNUSED_PARAMETER( event_flags );
+	
+    return kUnsupportedErr;
+}
+
+/**
+ * Gets time in milliseconds since RTOS start
+ *
+ * @Note: since this is only 32 bits, it will roll over every 49 days, 17 hours.
+ *
+ * @returns Time in milliseconds since RTOS started.
+ */
+beken_time_t rtos_get_time(void)
+{
+    return (beken_time_t) ( LOS_TickCountGet() * ms_to_tick_ratio );
+}
+
+/**
+ * Delay for a number of milliseconds
+ *
+ * Processing of this function depends on the minimum sleep
+ * time resolution of the RTOS.
+ * The current thread sleeps for the longest period possible which
+ * is less than the delay required, then makes up the difference
+ * with a tight loop
+ *
+ * @return OSStatus : kNoErr if delay was successful
+ *
+ */
+OSStatus rtos_delay_milliseconds( uint32_t num_ms )
+{
+    uint32_t ticks;
+
+    ticks = num_ms / ms_to_tick_ratio;
+    if (ticks == 0)
+        ticks = 1;
+
+    LOS_TaskDelay( ticks );
+
+    return kNoErr;
+}
+
+/*-----------------------------------------------------------*/
+void *beken_malloc( size_t xWantedSize )
+{
+	return (void *)LOS_MemAlloc(m_aucSysMem0, xWantedSize);;
+}
+
+/*-----------------------------------------------------------*/
+void beken_free( void *pv )
+{
+	LOS_MemFree(m_aucSysMem0, pv);
+}
+
+/*-----------------------------------------------------------*/
+void *beken_realloc( void *pv, size_t xWantedSize )
+{
+	return LOS_MemRealloc(m_aucSysMem0, pv, xWantedSize);
+}
+
+void rtos_dump_all_thread(void)
+{
+	//To be completed
+}
+
+void rtos_dump_stack(beken_thread_t *task)
+{
+}
+
+// eof
+
diff --git a/kernel/liteos_m/port/str_arch.c b/kernel/liteos_m/port/str_arch.c
new file mode 100644
index 0000000..63b232c
--- /dev/null
+++ b/kernel/liteos_m/port/str_arch.c
@@ -0,0 +1,139 @@
+#include "include.h"
+#include "arm_arch.h"
+
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include "str_pub.h"
+#include "mem_pub.h"
+
+char *os_strchr(const char *s, int c)
+{
+    return strchr(s, c);
+}
+
+UINT32 os_strlen(const char *str)
+{
+    return strlen(str);
+}
+
+INT32 os_strcmp(const char *s1, const char *s2)
+{
+    return strcmp(s1, s2);
+}
+
+UINT32 os_strtoul(const char *nptr, char **endptr, int base)
+{
+    return strtoul(nptr, endptr, base);
+}
+
+char *os_strcpy(char *out, const char *in)
+{
+    return strcpy(out, in);
+}
+
+char *os_strncpy(char *out, const char *in, const UINT32 n)
+{
+    return strncpy(out, in, (unsigned int)n);
+}
+
+size_t os_strlcpy(char *dest, const char *src, size_t siz)
+{
+    const char *s = src;
+    size_t left = siz;
+
+    if (left)
+    {
+        /* Copy string up to the maximum size of the dest buffer */
+        while (--left != 0)
+        {
+            if ((*dest++ = *s++) == '\0')
+                break;
+        }
+    }
+
+    if (left == 0)
+    {
+        /* Not enough room for the string; force NUL-termination */
+        if (siz != 0)
+            *dest = '\0';
+
+        while (*s++)
+            ; /* determine total src string length */
+    }
+
+    return s - src - 1;
+}
+
+INT32 os_strncmp(const char *s1, const char *s2, const UINT32 n)
+{
+    return strncmp(s1, s2, (unsigned int)n);
+}
+
+INT32 os_snprintf(char *buf, UINT32 size, const char *fmt, ...)
+{
+    va_list args;
+    INT32 rc;
+
+    va_start(args, fmt);
+    rc = vsnprintf(buf, size, fmt, args);
+    va_end(args);
+
+    /* if want to print more than the limitation */
+    if (rc > size)
+        rc = (INT32)size - rc;
+
+    return rc;
+}
+
+INT32 os_vsnprintf(char *buf, UINT32 size, const char *fmt, va_list ap)
+{
+    return vsnprintf(buf, size, fmt, ap);
+}
+
+char *os_strdup(const char *s)
+{
+    char *res;
+    size_t len;
+
+    if (s == NULL)
+        return NULL;
+
+    len = os_strlen(s);
+    res = os_malloc(len + 1);
+    if (res)
+        os_memcpy(res, s, len + 1);
+
+    return res;
+}
+
+
+int os_strcasecmp(const char *s1, const char *s2)
+{
+    /*
+     * Ignoring case is not required for main functionality, so just use
+     * the case sensitive version of the function.
+     */
+    return os_strcmp(s1, s2);
+}
+
+
+int os_strncasecmp(const char *s1, const char *s2, size_t n)
+{
+    /*
+     * Ignoring case is not required for main functionality, so just use
+     * the case sensitive version of the function.
+     */
+    return os_strncmp(s1, s2, n);
+}
+
+char *os_strrchr(const char *s, int c)
+{
+    return strrchr(s, c);
+}
+
+char *os_strstr(const char *haystack, const char *needle)
+{
+    return strstr(haystack, needle);
+}
+// EOF
diff --git a/kernel/liteos_m/targets/bk72xx/bk_los_timer.c b/kernel/liteos_m/targets/bk72xx/bk_los_timer.c
new file mode 100644
index 0000000..08e9e39
--- /dev/null
+++ b/kernel/liteos_m/targets/bk72xx/bk_los_timer.c
@@ -0,0 +1,100 @@
+#include "include.h"
+#include "bk_los_timer.h"
+#include "bk_timer.h"
+#include "los_context.h"
+#include "rtos_pub.h"
+#include "arm_arch.h"
+
+static OS_TICK_HANDLER g_tickHandler = NULL;
+
+void HalTickHandler(u8 param)
+{
+    if (g_tickHandler != NULL) {
+        g_tickHandler();
+    }
+}
+
+unsigned int HalTickStart(OS_TICK_HANDLER handler)
+{
+    unsigned int intSave;
+    UINT32 timer_channel;
+
+	intSave = LOS_IntLock();
+    timer_param_t param;
+    param.channel = LOS_TICK_TIMER_ID;
+    param.div = 1;
+    param.period = LOS_TICK_MS;
+    param.t_Int_Handler= HalTickHandler;
+    g_tickHandler = handler;
+
+    bk_timer_ctrl( CMD_TIMER_INIT_PARAM, &param);
+    timer_channel = param.channel;
+    bk_timer_ctrl( CMD_TIMER_UNIT_ENABLE, &timer_channel);
+    LOS_IntRestore(intSave);
+
+    return 0;
+}
+
+void HalTickLock(void)
+{
+    unsigned int timer_channel = LOS_TICK_TIMER_ID;
+    (void)bk_timer_ctrl(CMD_TIMER_UNIT_DISABLE, &timer_channel);
+}
+
+void HalTickUnlock(void)
+{
+    unsigned int timer_channel = LOS_TICK_TIMER_ID;
+    (void)bk_timer_ctrl(CMD_TIMER_UNIT_ENABLE, &timer_channel);
+}
+
+static void HalClockIrqClear(void)
+{
+    unsigned int status1 = 0x7 << TIMERCTLB_INT_POSI;
+
+    do {
+        REG_WRITE(LOS_TICK_CTRL_REG, (REG_READ(LOS_TICK_CTRL_REG) & (~(0x7 << TIMERCTLB_INT_POSI))) | status1);
+    } while (REG_READ(LOS_TICK_CTRL_REG) & status1 & (0x7 << TIMERCTLB_INT_POSI));
+}
+
+void HalSysTickReload(unsigned long long nextResponseTime)
+{
+	UINT32 inSave;
+
+	inSave = HalIntLock();
+    HalTickLock();
+	
+	HalClockIrqClear();
+    REG_WRITE(REG_TIMERCTL_PERIOD_ADDR(LOS_TICK_TIMER_GROUP, LOS_TICK_TIMER_ID), nextResponseTime);
+    HalTickUnlock();
+	HalIntRestore(inSave);
+}
+
+unsigned long long HalGetTickCycle(unsigned int *period)
+{
+    unsigned int val = 0;
+    unsigned int i_time_out = 0;
+
+    *period = REG_READ(REG_TIMERCTL_PERIOD_ADDR(LOS_TICK_TIMER_GROUP, LOS_TICK_TIMER_ID));
+
+    //get val
+    REG_WRITE(LOS_TICK_RD_CTRL_REG, (LOS_TICK_TIMER_RD_ID << 2) | 1);
+    while (REG_READ(LOS_TICK_RD_CTRL_REG) & 1) {
+         i_time_out++;
+         if (i_time_out > (120 * 1000)) {
+             break;
+         }
+    }
+
+    if (i_time_out <= (120 * 1000)) {
+        val = REG_READ(LOS_TICK_RD_VAL_REG);
+    }
+
+    return (unsigned long long)val;
+}
+
+UINT64 OsGetCurrSecond(VOID)
+{
+	return rtos_get_tick_count() * LOS_TICK_MS / 1000;
+}
+// eof
+
diff --git a/kernel/liteos_m/targets/bk72xx/bk_los_timer.h b/kernel/liteos_m/targets/bk72xx/bk_los_timer.h
new file mode 100644
index 0000000..4abf6b9
--- /dev/null
+++ b/kernel/liteos_m/targets/bk72xx/bk_los_timer.h
@@ -0,0 +1,30 @@
+#ifndef _BK_LOS_TIMER_H_
+#define _BK_LOS_TIMER_H_
+
+#include "include.h"
+#include "bk_timer_pub.h"
+
+#if CFG_HUAWEI_ORIGINAL_ADAPT
+#define LOS_TICK_TIMER_ID                  BKTIMER3
+#define LOS_TICK_CTRL_REG                  TIMER3_5_CTL
+#define LOS_TICK_RD_CTRL_REG               TIMER3_5_READ_CTL
+#define LOS_TICK_RD_VAL_REG                TIMER3_5_READ_VALUE
+#define LOS_TICK_UNIT_CLOCK                32000 
+#else
+#define LOS_TICK_TIMER_ID                  BKTIMER0
+#define LOS_TICK_CTRL_REG                  TIMER0_2_CTL
+#define LOS_TICK_RD_CTRL_REG               TIMER0_2_READ_CTL
+#define LOS_TICK_RD_VAL_REG                TIMER0_2_READ_VALUE
+#define LOS_TICK_UNIT_CLOCK                26000000 
+#endif
+
+#define LOS_TICK_TIMER_GROUP               ((LOS_TICK_TIMER_ID) >= 3 ? 1 : 0)
+#define LOS_TICK_TIMER_RD_ID               (LOS_TICK_TIMER_ID - 3 * (LOS_TICK_TIMER_GROUP))
+
+#define LOS_TICK_MS                        2
+#define LOS_TICKS_PER_SECOND              (1000UL/LOS_TICK_MS)
+
+extern UINT64 OsGetCurrSecond(VOID);
+
+#endif // _BK_LOS_TIMER_H_
+// eof
diff --git a/kernel/liteos_m/utils/BUILD.gn b/kernel/liteos_m/utils/BUILD.gn
index 86fa369..202eab8 100644
--- a/kernel/liteos_m/utils/BUILD.gn
+++ b/kernel/liteos_m/utils/BUILD.gn
@@ -31,12 +31,13 @@ static_library("utils") {
   sources = [
     "los_debug.c",
     "los_error.c",
+    "los_hook.c",
   ]
 
   include_dirs = [
     "../kernel/include",
     "../kernel/arch/include",
-    "./",
+    ".",
     "//third_party/bounds_checking_function/include",
   ]
 }
diff --git a/kernel/liteos_m/utils/internal/los_hook_types.h b/kernel/liteos_m/utils/internal/los_hook_types.h
new file mode 100644
index 0000000..ca4760d
--- /dev/null
+++ b/kernel/liteos_m/utils/internal/los_hook_types.h
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_HOOK_TYPES_H
+#define _LOS_HOOK_TYPES_H
+
+#include "los_compiler.h"
+#include "los_config.h"
+#include "los_context.h"
+#include "los_event.h"
+#include "los_mux.h"
+#include "los_queue.h"
+#include "los_sem.h"
+#include "los_task.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#if (LOSCFG_DEBUG_HOOK == 1)
+#define LOS_HOOK_ALL_TYPES_DEF                                                                              \
+    /* Hook types supported by memory modules */                                                            \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MEM_INIT, (VOID *pool, UINT32 size))                                    \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MEM_DEINIT, (VOID *pool))                                               \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MEM_ALLOC, (VOID *pool, UINT32 size))                                   \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MEM_FREE, (VOID *pool, VOID *ptr))                                      \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MEM_REALLOC, (VOID *pool, VOID *ptr, UINT32 size))                      \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MEM_ALLOCALIGN, (VOID *pool, UINT32 size, UINT32 boundary))             \
+    /* Hook types supported by event modules */                                                             \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_EVENT_INIT, (VOID))                                                     \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_EVENT_READ, (PEVENT_CB_S eventCB, UINT32 eventMask, UINT32 mode))       \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_EVENT_WRITE, (PEVENT_CB_S eventCB))                                     \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_EVENT_CLEAR, (PEVENT_CB_S eventCB))                                     \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_EVENT_DESTROY, (VOID))                                                  \
+    /* Hook types supported by queue modules */                                                             \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_QUEUE_CREATE, (const LosQueueCB *queueCB))                              \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_QUEUE_READ, (const LosQueueCB *queueCB))                                \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_QUEUE_WRITE, (const LosQueueCB *queueCB))                               \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_QUEUE_DELETE, (const LosQueueCB *queueCB))                              \
+    /* Hook types supported by semphore modules */                                                          \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_SEM_CREATE, (const LosSemCB *semCreated))                               \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_SEM_POST, (const LosSemCB *semPosted, const LosTaskCB *resumedTask))    \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_SEM_PEND, (const LosSemCB *semPended, const LosTaskCB *runningTask))    \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_SEM_DELETE, (const LosSemCB *semDeleted))                               \
+    /* Hook types supported by mutex modules */                                                             \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MUX_CREATE, (const LosMuxCB *muxCreated))                               \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MUX_POST, (const LosMuxCB *muxPosted))                                  \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MUX_PEND, (const LosMuxCB *muxPended))                                  \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MUX_DELETE, (const LosMuxCB *muxDeleted))                               \
+    /* Hook types supported by task modules */                                                              \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_TASK_CREATE, (const LosTaskCB *taskCB))                                 \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_TASK_DELAY, (UINT32 tick))                                              \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_TASK_PRIMODIFY, (const LosTaskCB *pxTask, UINT32 uxNewPriority))        \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_TASK_DELETE, (const LosTaskCB *taskCB))                                 \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_TASK_SWITCHEDIN, (VOID))                                                \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MOVEDTASKTOREADYSTATE, (const LosTaskCB *pstTaskCB))                    \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MOVEDTASKTODELAYEDLIST, (const LosTaskCB *pstTaskCB))                   \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MOVEDTASKTOSUSPENDEDLIST, (const LosTaskCB *pstTaskCB))                 \
+    /* Hook types supported by interrupt modules */                                                         \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_ISR_EXITTOSCHEDULER, (VOID))                                            \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_ISR_ENTER, (UINT32 hwiIndex))                                           \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_ISR_EXIT, (UINT32 hwiIndex))
+
+/**
+ * Defines the types of all hooks.
+ */
+#define LOS_HOOK_TYPE_DEF(type, paramList)                  type,
+
+typedef enum {
+    /* Used to manage hook pools */
+    LOS_HOOK_TYPE_START = 0,
+    /* All supported hook types */
+    LOS_HOOK_ALL_TYPES_DEF
+    /* Used to manage hook pools */
+    LOS_HOOK_TYPE_END
+} HookType;
+
+#undef LOS_HOOK_TYPE_DEF
+
+/**
+ * Declare the type and interface of the hook functions.
+ */
+#define LOS_HOOK_TYPE_DEF(type, paramList)                  \
+    typedef VOID (*type##_FN) paramList;                    \
+    extern UINT32 type##_RegHook(type##_FN func);           \
+    extern UINT32 type##_UnRegHook(type##_FN func);         \
+    extern VOID type##_CallHook paramList;
+
+LOS_HOOK_ALL_TYPES_DEF
+
+#undef LOS_HOOK_TYPE_DEF
+
+#endif /* LOSCFG_DEBUG_HOOK */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _LOS_HOOK_TYPES_H */
diff --git a/kernel/liteos_m/utils/internal/los_hook_types_parse.h b/kernel/liteos_m/utils/internal/los_hook_types_parse.h
new file mode 100644
index 0000000..287ad81
--- /dev/null
+++ b/kernel/liteos_m/utils/internal/los_hook_types_parse.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_HOOK_TYPES_PARSE_H
+#define _LOS_HOOK_TYPES_PARSE_H
+
+#define ADDR(a) (&(a))
+#define ARGS(a) (a)
+#define ADDRn(...) _CONCAT(ADDR, _NARGS(__VA_ARGS__))(__VA_ARGS__)
+#define ARGSn(...) _CONCAT(ARGS, _NARGS(__VA_ARGS__))(__VA_ARGS__)
+#define ARGS0()
+#define ADDR0()
+#define ARGS1(a) ARGS(a)
+#define ADDR1(a) ADDR(a)
+
+#define ARG_const _ARG_const(
+#define _ARG_const(a) ARG_CP_##a)
+#define ARG_CP_LosSemCB ADDR(
+#define ARG_CP_LosTaskCB ADDR(
+#define ARG_CP_UINT32 ADDR(
+#define ARG_CP_LosMuxCB ADDR(
+#define ARG_CP_LosQueueCB ADDR(
+#define ARG_UINT32 ARGS(
+#define ARG_PEVENT_CB_S ARGS(
+#define ARG_void ADDRn(
+#define ARG(a) ARG_##a)
+
+#define PARAM_TO_ARGS1(a) ARG(a)
+#define PARAM_TO_ARGS2(a, b) ARG(a), PARAM_TO_ARGS1(b)
+#define PARAM_TO_ARGS3(a, b, c) ARG(a), PARAM_TO_ARGS2(b, c)
+#define PARAM_TO_ARGS4(a, b, c, d) ARG(a), PARAM_TO_ARGS3(b, c, d)
+#define PARAM_TO_ARGS5(a, b, c, d, e) ARG(a), PARAM_TO_ARGS4(b, c, d, e)
+#define PARAM_TO_ARGS6(a, b, c, d, e, f) ARG(a), PARAM_TO_ARGS5(b, c, d, e, f)
+#define PARAM_TO_ARGS7(a, b, c, d, e, f, g) ARG(a), PARAM_TO_ARGS6(b, c, d, e, f, g)
+
+#define _ZERO_ARGS  7, 6, 5, 4, 3, 2, 1, 0
+#define ___NARGS(a, b, c, d, e, f, g, h, n, ...)    n
+#define __NARGS(...) ___NARGS(__VA_ARGS__)
+#define _NARGS(...) __NARGS(x, __VA_ARGS__##_ZERO_ARGS, 7, 6, 5, 4, 3, 2, 1, 0)
+#define __CONCAT(a, b) a##b
+#define _CONCAT(a, b) __CONCAT(a, b)
+
+#define PARAM_TO_ARGS(...) _CONCAT(PARAM_TO_ARGS, _NARGS(__VA_ARGS__))(__VA_ARGS__)
+#define OS_HOOK_PARAM_TO_ARGS(paramList) (PARAM_TO_ARGS paramList)
+
+#endif /* _LOS_HOOK_TYPES_PARSE_H */
diff --git a/kernel/liteos_m/utils/los_compiler.h b/kernel/liteos_m/utils/los_compiler.h
old mode 100755
new mode 100644
index 94d0841..faf58bb
--- a/kernel/liteos_m/utils/los_compiler.h
+++ b/kernel/liteos_m/utils/los_compiler.h
@@ -70,6 +70,14 @@ extern "C" {
 #define CLZ           __iar_builtin_CLZ
 #endif
 
+#ifndef NORETURN
+#define NORETURN      __attribute__ ((__noreturn__))
+#endif
+
+#ifndef UNREACHABLE
+#define UNREACHABLE   while (1)
+#endif
+
 /* for ARM Compiler */
 #elif defined(__CC_ARM)
 
@@ -97,6 +105,14 @@ extern "C" {
 #define CLZ           __clz
 #endif
 
+#ifndef NORETURN
+#define NORETURN      __declspec(noreturn)
+#endif
+
+#ifndef UNREACHABLE
+#define UNREACHABLE   while (1)
+#endif
+
 #pragma anon_unions
 
 /* for GNU Compiler */
@@ -126,6 +142,14 @@ extern "C" {
 #define CLZ           __builtin_clz
 #endif
 
+#ifndef NORETURN
+#define NORETURN      __attribute__ ((__noreturn__))
+#endif
+
+#ifndef UNREACHABLE
+#define UNREACHABLE   __builtin_unreachable()
+#endif
+
 #else
 #error Unknown compiler.
 #endif
diff --git a/kernel/liteos_m/utils/los_debug.c b/kernel/liteos_m/utils/los_debug.c
old mode 100755
new mode 100644
index 3bb28b6..fbd7886
--- a/kernel/liteos_m/utils/los_debug.c
+++ b/kernel/liteos_m/utils/los_debug.c
@@ -33,11 +33,6 @@
 #include "stdarg.h"
 #include "los_context.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
 #if (LOSCFG_KERNEL_PRINTF == 1)
 STATIC const CHAR *g_logString[] = {
@@ -72,7 +67,7 @@ VOID OsBackTraceHookCall(UINTPTR *LR, UINT32 LRSize, UINT32 jumpCount, UINTPTR S
 
 VOID OsExcHookRegister(ExcHookFn excHookFn)
 {
-    UINTPTR intSave = LOS_IntLock();
+    UINT32 intSave = LOS_IntLock();
     if (!g_excHook) {
         g_excHook = excHookFn;
     }
@@ -81,7 +76,7 @@ VOID OsExcHookRegister(ExcHookFn excHookFn)
 
 VOID OsDoExcHook(EXC_TYPE excType)
 {
-    UINTPTR intSave = LOS_IntLock();
+    UINT32 intSave = LOS_IntLock();
     if (g_excHook) {
         g_excHook(excType);
     }
@@ -109,8 +104,3 @@ WEAK VOID HalConsoleOutput(LogModuleType type, INT32 level, const CHAR *fmt, ...
 }
 #endif
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/utils/los_debug.h b/kernel/liteos_m/utils/los_debug.h
old mode 100755
new mode 100644
index 5528763..aa96a60
--- a/kernel/liteos_m/utils/los_debug.h
+++ b/kernel/liteos_m/utils/los_debug.h
@@ -98,7 +98,7 @@ VOID OsDoExcHook(EXC_TYPE excType);
 #define LOG_DEBUG_LEVEL     (LOG_INFO_LEVEL + 1)
 
 #ifndef PRINT_LEVEL
-#define PRINT_LEVEL         LOG_ERR_LEVEL
+#define PRINT_LEVEL         LOG_DEBUG_LEVEL
 #endif
 
 typedef enum {
@@ -129,12 +129,13 @@ typedef enum {
  * @see LOS_Printf
  * @since none
  */
-#if (LOSCFG_KERNEL_PRINTF == 1)
-extern INT32 printf(const CHAR *fmt, ...);
+#if ((LOS_BEKEN) && (LOSCFG_KERNEL_PRINTF == 1))
+extern void bk_printf(const char *fmt, ...);
+
 extern INT32 OsLogLevelCheck(INT32 level);
 #define LOS_Printf(type, level, fmt, args...)   do { \
     if (!OsLogLevelCheck(level)) {                   \
-        printf(fmt, ##args);                         \
+        bk_printf(fmt, ##args);                      \
     }                                                \
 } while (0)
 #elif (LOSCFG_KERNEL_PRINTF == 0)
@@ -185,7 +186,7 @@ extern VOID OsBackTraceHookCall(UINTPTR *LR, UINT32 LRSize, UINT32 jumpCount, UI
  *
  * Value: 0x02001401
  *
- * Solution: Use valid type to regeister the new trace.
+ * Solution: Use valid type to register the new trace.
  */
 #define  LOS_ERRNO_TRACE_TYPE_INVALID           LOS_ERRNO_OS_ERROR(LOS_MOD_TRACE, 0x01)
 
@@ -196,7 +197,7 @@ extern VOID OsBackTraceHookCall(UINTPTR *LR, UINT32 LRSize, UINT32 jumpCount, UI
  *
  * Value: 0x02001402
  *
- * Solution: Use valid callback function to regeister the new trace.
+ * Solution: Use valid callback function to register the new trace.
  */
 #define  LOS_ERRNO_TRACE_FUNCTION_NULL          LOS_ERRNO_OS_ERROR(LOS_MOD_TRACE, 0x02)
 
@@ -206,7 +207,7 @@ extern VOID OsBackTraceHookCall(UINTPTR *LR, UINT32 LRSize, UINT32 jumpCount, UI
  *
  * Value: 0x02001403
  *
- * Solution: Use valid filled size to regeister the new trace.
+ * Solution: Use valid filled size to register the new trace.
  */
 #define  LOS_ERRNO_TRACE_MAX_SIZE_INVALID       LOS_ERRNO_OS_ERROR(LOS_MOD_TRACE, 0x03)
 
@@ -218,7 +219,7 @@ extern VOID OsBackTraceHookCall(UINTPTR *LR, UINT32 LRSize, UINT32 jumpCount, UI
 
 /**
  * @ingroup los_trace
- * It's the legth of tag, filled by los_trace system
+ * It's the length of tag, filled by los_trace system
  */
 #define LOS_TRACE_TAG_LENGTH  sizeof(UINT32)
 
@@ -228,7 +229,7 @@ extern VOID OsBackTraceHookCall(UINTPTR *LR, UINT32 LRSize, UINT32 jumpCount, UI
  */
 typedef enum enTraceType {
     LOS_TRACE_SWITCH = 0,         /**< trace for task switch, 0 is reserved for taskswitch   */
-    LOS_TRACE_INTERRUPT = 1,      /**< trace for Interrrupt, 1 is reserved for interrupt      */
+    LOS_TRACE_INTERRUPT = 1,      /**< trace for Interrupt, 1 is reserved for interrupt      */
     LOS_TRACE_TYPE_NUM =  10,     /**< num for the register type, user can use 2~ LOS_TRACE_TYPE_NUM-1 */
 } TRACE_TYPE_E;
 
@@ -238,8 +239,8 @@ typedef enum enTraceType {
  * struct to store the task switch infomation
  */
 typedef struct tagTraceTaskSwitch {
-    UINT8  ucSrcTaskId;           /**< source taskid    */
-    UINT8  ucDestTaskId;          /**< destination taskid    */
+    UINT8  ucSrcTaskId;           /**< source taskId    */
+    UINT8  ucDestTaskId;          /**< destination taskId    */
     UINT32 uwSwitchTick;          /**< Time at which the task switch happens    */
 } TRACE_TASKSWITCH_S;
 
@@ -261,13 +262,13 @@ typedef struct tagTraceInterrupt {
 typedef struct tagTrace {
     union {
         TRACE_TASKSWITCH_S  stTraceTask;       /**< It used for trace the task    */
-        TRACE_INTERRUPT_S   stTraceInterrupt;  /**< It used for trace the interrrupt    */
+        TRACE_INTERRUPT_S   stTraceInterrupt;  /**< It used for trace the interrupt    */
     };
 } TRACE_S;
 
 /**
  * @ingroup los_trace
- * Main struct to store the interrupt and task swithc infomation
+ * Main struct to store the interrupt and task switch infomation
  */
 typedef struct tagTraceBuffer {
     UINT16            usTracePos;
@@ -278,7 +279,7 @@ typedef struct tagTraceBuffer {
 
 /**
  * @ingroup los_trace
- * Struct to store the trace infomaion for each trace type
+ * Struct to store the trace information for each trace type
  */
 typedef struct tagTraceInfo {
     TRACE_TYPE_E  eType;                             /**< trace type, selected from TRACE_TYPE_E */
@@ -289,10 +290,10 @@ typedef struct tagTraceInfo {
 
 /**
  * @ingroup los_trace
- * @brief  Intialize the trace when the system startup.
+ * @brief  Initialize the trace when the system startup.
  *
  * @par Description:
- * This API is used to intilize the trace for system level.
+ * This API is used to initialize the trace for system level.
  * @attention
  * <ul>
  * <li>This API can be called only after the memory is initialized. Otherwise, the CPU usage fails to be obtained.</li>
@@ -300,8 +301,8 @@ typedef struct tagTraceInfo {
  *
  * @param None.
  *
- * @retval #LOS_ERRNO_TRACE_NO_MEMORY         0x02001400: The memory is not enough for initilize.
- * @retval #LOS_OK                            0x00000000: The intialization is successful.
+ * @retval #LOS_ERRNO_TRACE_NO_MEMORY         0x02001400: The memory is not enough for initialization.
+ * @retval #LOS_OK                            0x00000000: The initialization is successful.
  * @par Dependency:
  * <ul><li>los_trace.h: the header file that contains the API declaration.</li></ul>
  * @see LOS_TraceInit
@@ -349,12 +350,12 @@ extern VOID LOS_Trace(TRACE_TYPE_E traceType, VOID *traceInfo);
  *                            information
  * @param  size          [IN] UINT16. The maximum size the trace will use for the specific trace type.
  *
- * @retval #LOS_ERRNO_TRACE_NO_MEMORY          0x02001400: The memory is not enough for initilize.
+ * @retval #LOS_ERRNO_TRACE_NO_MEMORY          0x02001400: The memory is not enough for initialization.
  * @retval #LOS_ERRNO_TRACE_TYPE_INVALID       0x02001401: The trace type is invalid. Valid type is from
  *                                                         LOS_TRACE_TYPE_NUM-1
  * @retval #LOS_ERRNO_TRACE_FUNCTION_NULL      0x02001402: The input callback function is NULL
  * @retval #LOS_ERRNO_TRACE_MAX_SIZE_INVALID   0x02001403: The information maxmum size is 0 to store.
- * @retval #LOS_OK                             0x00000000: The registeration is successful.
+ * @retval #LOS_OK                             0x00000000: The register is successful.
  *
  * @par Dependency:
  * <ul><li>los_trace.h: the header file that contains the API declaration.</li></ul>
diff --git a/kernel/liteos_m/utils/los_error.c b/kernel/liteos_m/utils/los_error.c
index 38cf2cd..0b783b3 100644
--- a/kernel/liteos_m/utils/los_error.c
+++ b/kernel/liteos_m/utils/los_error.c
@@ -31,11 +31,6 @@
 
 #include "los_error.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
 LITE_OS_SEC_BSS UserErrFunc      g_userErrFunc;
 
@@ -65,8 +60,3 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_ErrHandle(CHAR  *fileName,
     return LOS_OK;
 }
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/utils/los_error.h b/kernel/liteos_m/utils/los_error.h
index 3c09072..aa8b7de 100644
--- a/kernel/liteos_m/utils/los_error.h
+++ b/kernel/liteos_m/utils/los_error.h
@@ -168,7 +168,7 @@ typedef struct tagUserErrFunc {
 } UserErrFunc;
 
 
-enum LOS_MOUDLE_ID {
+enum LOS_MODULE_ID {
     LOS_MOD_SYS              = 0x0,
     LOS_MOD_MEM              = 0x1,
     LOS_MOD_TSK              = 0x2,
@@ -203,10 +203,11 @@ enum LOS_MOUDLE_ID {
     LOS_MOD_EVENT            = 0x1c,
     LOS_MOD_MUX              = 0X1d,
     LOS_MOD_CPUP             = 0x1e,
+    LOS_MOD_HOOK             = 0x1f,
     LOS_MOD_SHELL            = 0x31,
     LOS_MOD_BUTT
 };
-			
+
 /**
  * @ingroup los_err
  * Define the error magic word.
@@ -288,7 +289,7 @@ enum LOS_MOUDLE_ID {
         goto ERR_HANDLER; \
     } while (0)
 
-			
+
 #ifdef __cplusplus
 #if __cplusplus
 }
diff --git a/kernel/liteos_m/utils/los_hook.c b/kernel/liteos_m/utils/los_hook.c
new file mode 100644
index 0000000..3d646a7
--- /dev/null
+++ b/kernel/liteos_m/utils/los_hook.c
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "los_hook.h"
+#include "internal/los_hook_types_parse.h"
+
+
+#if (LOSCFG_DEBUG_HOOK == 1)
+#define LOS_HOOK_TYPE_DEF(type, paramList)                  \
+    STATIC type##_FN g_fn##type;                            \
+    UINT32 type##_RegHook(type##_FN func) {                 \
+        if ((func) == NULL) {                               \
+            return LOS_ERRNO_HOOK_REG_INVALID;              \
+        }                                                   \
+        if (g_fn##type) {                                   \
+            return LOS_ERRNO_HOOK_POOL_IS_FULL;             \
+        }                                                   \
+        g_fn##type = (func);                                \
+        return LOS_OK;                                      \
+    }                                                       \
+    UINT32 type##_UnRegHook(type##_FN func) {               \
+        if (((func) == NULL) || (g_fn##type != (func))) {   \
+            return LOS_ERRNO_HOOK_UNREG_INVALID;            \
+        }                                                   \
+        g_fn##type = NULL;                                  \
+        return LOS_OK;                                      \
+    }                                                       \
+    VOID type##_CallHook paramList {                        \
+        if (g_fn##type) {                                   \
+            g_fn##type(PARAM_TO_ARGS paramList);            \
+        }                                                   \
+    }
+
+LOS_HOOK_ALL_TYPES_DEF;
+
+#undef LOS_HOOK_TYPE_DEF
+
+#endif /* LOSCFG_DEBUG_HOOK */
+
diff --git a/kernel/liteos_m/utils/los_hook.h b/kernel/liteos_m/utils/los_hook.h
new file mode 100644
index 0000000..3b3693b
--- /dev/null
+++ b/kernel/liteos_m/utils/los_hook.h
@@ -0,0 +1,137 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_HOOK_H
+#define _LOS_HOOK_H
+
+#include "internal/los_hook_types.h"
+#include "los_config.h"
+#include "los_error.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#if (LOSCFG_DEBUG_HOOK == 1)
+/**
+ * @ingroup los_hook
+ * Hook error code: The hook pool is insufficient.
+ *
+ * Value: 0x02001f00
+ *
+ * Solution: Deregister the registered hook.
+ */
+#define LOS_ERRNO_HOOK_POOL_IS_FULL             LOS_ERRNO_OS_ERROR(LOS_MOD_HOOK, 0x00)
+
+/**
+ * @ingroup los_hook
+ * Hook error code: Invalid parameter.
+ *
+ * Value: 0x02001f01
+ *
+ * Solution: Check the input parameters of LOS_HookReg.
+ */
+#define LOS_ERRNO_HOOK_REG_INVALID              LOS_ERRNO_OS_ERROR(LOS_MOD_HOOK, 0x01)
+
+/**
+ * @ingroup los_hook
+ * Hook error code: Invalid parameter.
+ *
+ * Value: 0x02001f02
+ *
+ * Solution: Check the input parameters of LOS_HookUnReg.
+ */
+#define LOS_ERRNO_HOOK_UNREG_INVALID            LOS_ERRNO_OS_ERROR(LOS_MOD_HOOK, 0x02)
+
+/**
+ * @ingroup los_hook
+ * @brief Registration of hook function.
+ *
+ * @par Description:
+ * This API is used to register hook function.
+ *
+ * @attention
+ * <ul>
+ * <li> None.</li>
+ * </ul>
+ *
+ * @param hookType  [IN] Register the type of the hook.
+ * @param hookFn  [IN] The function to be registered.
+ *
+ * @retval None.
+ * @par Dependency:
+ * <ul><li>los_hook.h: the header file that contains the API declaration.</li></ul>
+ * @see
+ */
+#define LOS_HookReg(hookType, hookFn)           hookType##_RegHook(hookFn)
+
+/**
+ * @ingroup los_hook
+ * @brief Deregistration of hook function.
+ *
+ * @par Description:
+ * This API is used to deregister hook function.
+ *
+ * @attention
+ * <ul>
+ * <li> None.</li>
+ * </ul>
+ *
+ * @param hookType  [IN] Deregister the type of the hook.
+ * @param hookFn  [IN] The function to be deregistered.
+ *
+ * @retval None.
+ * @par Dependency:
+ * <ul><li>los_hook.h: the header file that contains the API declaration.</li></ul>
+ * @see
+ */
+#define LOS_HookUnReg(hookType, hookFn)         hookType##_UnRegHook(hookFn)
+
+/**
+ * Call hook functions.
+ */
+#define OsHookCall(hookType, ...)               hookType##_CallHook(__VA_ARGS__)
+
+#else
+#define LOS_HookReg(hookType, hookFn)
+#define LOS_HookUnReg(hookType, hookFn)
+#define OsHookCall(hookType, ...)
+#endif
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _LOS_HOOK_H */
